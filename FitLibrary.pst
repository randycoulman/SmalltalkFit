<?xml version="1.0"?><st-source><!-- Name: FitLibraryNotice:                     GNU GENERAL PUBLIC LICENSE                       Version 2, June 1991 Copyright (C) 1989, 1991 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.                            Preamble  The licenses for most software are designed to take away yourfreedom to share and change it.  By contrast, the GNU General PublicLicense is intended to guarantee your freedom to share and change freesoftware- to make sure the software is free for all its users.  ThisGeneral Public License applies to most of the Free SoftwareFoundation's software and to any other program whose authors commit tousing it.  (Some other Free Software Foundation software is covered bythe GNU Lesser General Public License instead.)  You can apply it toyour programs, too.  When we speak of free software, we are referring to freedom, notprice.  Our General Public Licenses are designed to make sure that youhave the freedom to distribute copies of free software (and charge forthis service if you wish), that you receive source code or can get itif you want it, that you can change the software or use pieces of itin new free programs; and that you know you can do these things.  To protect your rights, we need to make restrictions that forbidanyone to deny you these rights or to ask you to surrender the rights.These restrictions translate to certain responsibilities for you if youdistribute copies of the software, or if you modify it.  For example, if you distribute copies of such a program, whethergratis or for a fee, you must give the recipients all the rights thatyou have.  You must make sure that they, too, receive or can get thesource code.  And you must show them these terms so they know theirrights.  We protect your rights with two steps: (1) copyright the software, and(2) offer you this license which gives you legal permission to copy,distribute and/or modify the software.  Also, for each author's protection and ours, we want to make certainthat everyone understands that there is no warranty for this freesoftware.  If the software is modified by someone else and passed on, wewant its recipients to know that what they have is not the original, sothat any problems introduced by others will not reflect on the originalauthors' reputations.  Finally, any free program is threatened constantly by softwarepatents.  We wish to avoid the danger that redistributors of a freeprogram will individually obtain patent licenses, in effect making theprogram proprietary.  To prevent this, we have made it clear that anypatent must be licensed for everyone's free use or not licensed at all.  The precise terms and conditions for copying, distribution andmodification follow.                    GNU GENERAL PUBLIC LICENSE   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION  0. This License applies to any program or other work which containsa notice placed by the copyright holder saying it may be distributedunder the terms of this General Public License.  The "Program", below,refers to any such program or work, and a "work based on the Program"means either the Program or any derivative work under copyright law:that is to say, a work containing the Program or a portion of it,either verbatim or with modifications and/or translated into anotherlanguage.  (Hereinafter, translation is included without limitation inthe term "modification".)  Each licensee is addressed as "you".Activities other than copying, distribution and modification are notcovered by this License; they are outside its scope.  The act ofrunning the Program is not restricted, and the output from the Programis covered only if its contents constitute a work based on theProgram (independent of having been made by running the Program).Whether that is true depends on what the Program does.  1. You may copy and distribute verbatim copies of the Program'ssource code as you receive it, in any medium, provided that youconspicuously and appropriately publish on each copy an appropriatecopyright notice and disclaimer of warranty; keep intact all thenotices that refer to this License and to the absence of any warranty;and give any other recipients of the Program a copy of this Licensealong with the Program.You may charge a fee for the physical act of transferring a copy, andyou may at your option offer warranty protection in exchange for a fee.  2. You may modify your copy or copies of the Program or any portionof it, thus forming a work based on the Program, and copy anddistribute such modifications or work under the terms of Section 1above, provided that you also meet all of these conditions:    a) You must cause the modified files to carry prominent notices    stating that you changed the files and the date of any change.    b) You must cause any work that you distribute or publish, that in    whole or in part contains or is derived from the Program or any    part thereof, to be licensed as a whole at no charge to all third    parties under the terms of this License.    c) If the modified program normally reads commands interactively    when run, you must cause it, when started running for such    interactive use in the most ordinary way, to print or display an    announcement including an appropriate copyright notice and a    notice that there is no warranty (or else, saying that you provide    a warranty) and that users may redistribute the program under    these conditions, and telling the user how to view a copy of this    License.  (Exception: if the Program itself is interactive but    does not normally print such an announcement, your work based on    the Program is not required to print an announcement.)These requirements apply to the modified work as a whole.  Ifidentifiable sections of that work are not derived from the Program,and can be reasonably considered independent and separate works inthemselves, then this License, and its terms, do not apply to thosesections when you distribute them as separate works.  But when youdistribute the same sections as part of a whole which is a work basedon the Program, the distribution of the whole must be on the terms ofthis License, whose permissions for other licensees extend to theentire whole, and thus to each and every part regardless of who wrote it.Thus, it is not the intent of this section to claim rights or contestyour rights to work written entirely by you; rather, the intent is toexercise the right to control the distribution of derivative orcollective works based on the Program.In addition, mere aggregation of another work not based on the Programwith the Program (or with a work based on the Program) on a volume ofa storage or distribution medium does not bring the other work underthe scope of this License.  3. You may copy and distribute the Program (or a work based on it,under Section 2) in object code or executable form under the terms ofSections 1 and 2 above provided that you also do one of the following:    a) Accompany it with the complete corresponding machine-readable    source code, which must be distributed under the terms of Sections    1 and 2 above on a medium customarily used for software interchange; or,    b) Accompany it with a written offer, valid for at least three    years, to give any third party, for a charge no more than your    cost of physically performing source distribution, a complete    machine-readable copy of the corresponding source code, to be    distributed under the terms of Sections 1 and 2 above on a medium    customarily used for software interchange; or,    c) Accompany it with the information you received as to the offer    to distribute corresponding source code.  (This alternative is    allowed only for noncommercial distribution and only if you    received the program in object code or executable form with such    an offer, in accord with Subsection b above.)The source code for a work means the preferred form of the work formaking modifications to it.  For an executable work, complete sourcecode means all the source code for all modules it contains, plus anyassociated interface definition files, plus the scripts used tocontrol compilation and installation of the executable.  However, as aspecial exception, the source code distributed need not includeanything that is normally distributed (in either source or binaryform) with the major components (compiler, kernel, and so on) of theoperating system on which the executable runs, unless that componentitself accompanies the executable.If distribution of executable or object code is made by offeringaccess to copy from a designated place, then offering equivalentaccess to copy the source code from the same place counts asdistribution of the source code, even though third parties are notcompelled to copy the source along with the object code.  4. You may not copy, modify, sublicense, or distribute the Programexcept as expressly provided under this License.  Any attemptotherwise to copy, modify, sublicense or distribute the Program isvoid, and will automatically terminate your rights under this License.However, parties who have received copies, or rights, from you underthis License will not have their licenses terminated so long as suchparties remain in full compliance.  5. You are not required to accept this License, since you have notsigned it.  However, nothing else grants you permission to modify ordistribute the Program or its derivative works.  These actions areprohibited by law if you do not accept this License.  Therefore, bymodifying or distributing the Program (or any work based on theProgram), you indicate your acceptance of this License to do so, andall its terms and conditions for copying, distributing or modifyingthe Program or works based on it.  6. Each time you redistribute the Program (or any work based on theProgram), the recipient automatically receives a license from theoriginal licensor to copy, distribute or modify the Program subject tothese terms and conditions.  You may not impose any furtherrestrictions on the recipients' exercise of the rights granted herein.You are not responsible for enforcing compliance by third parties tothis License.  7. If, as a consequence of a court judgment or allegation of patentinfringement or for any other reason (not limited to patent issues),conditions are imposed on you (whether by court order, agreement orotherwise) that contradict the conditions of this License, they do notexcuse you from the conditions of this License.  If you cannotdistribute so as to satisfy simultaneously your obligations under thisLicense and any other pertinent obligations, then as a consequence youmay not distribute the Program at all.  For example, if a patentlicense would not permit royalty-free redistribution of the Program byall those who receive copies directly or indirectly through you, thenthe only way you could satisfy both it and this License would be torefrain entirely from distribution of the Program.If any portion of this section is held invalid or unenforceable underany particular circumstance, the balance of the section is intended toapply and the section as a whole is intended to apply in othercircumstances.It is not the purpose of this section to induce you to infringe anypatents or other property right claims or to contest validity of anysuch claims; this section has the sole purpose of protecting theintegrity of the free software distribution system, which isimplemented by public license practices.  Many people have madegenerous contributions to the wide range of software distributedthrough that system in reliance on consistent application of thatsystem; it is up to the author/donor to decide if he or she is willingto distribute software through any other system and a licensee cannotimpose that choice.This section is intended to make thoroughly clear what is believed tobe a consequence of the rest of this License.  8. If the distribution and/or use of the Program is restricted incertain countries either by patents or by copyrighted interfaces, theoriginal copyright holder who places the Program under this Licensemay add an explicit geographical distribution limitation excludingthose countries, so that distribution is permitted only in or amongcountries not thus excluded.  In such case, this License incorporatesthe limitation as if written in the body of this License.  9. The Free Software Foundation may publish revised and/or new versionsof the General Public License from time to time.  Such new versions willbe similar in spirit to the present version, but may differ in detail toaddress new problems or concerns.Each version is given a distinguishing version number.  If the Programspecifies a version number of this License which applies to it and "anylater version", you have the option of following the terms and conditionseither of that version or of any later version published by the FreeSoftware Foundation.  If the Program does not specify a version number ofthis License, you may choose any version ever published by the Free SoftwareFoundation.  10. If you wish to incorporate parts of the Program into other freeprograms whose distribution conditions are different, write to the authorto ask for permission.  For software which is copyrighted by the FreeSoftware Foundation, write to the Free Software Foundation; we sometimesmake exceptions for this.  Our decision will be guided by the two goalsof preserving the free status of all derivatives of our free software andof promoting the sharing and reuse of software generally.                            NO WARRANTY  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTYFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHENOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIESPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSEDOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK ASTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THEPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,REPAIR OR CORRECTION.  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITINGWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/ORREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISINGOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITEDTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BYYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHERPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THEPOSSIBILITY OF SUCH DAMAGES.                     END OF TERMS AND CONDITIONS            How to Apply These Terms to Your New Programs  If you develop a new program, and you want it to be of the greatestpossible use to the public, the best way to achieve this is to make itfree software which everyone can redistribute and change under these terms.  To do so, attach the following notices to the program.  It is safestto attach them to the start of each source file to most effectivelyconvey the exclusion of warranty; and each file should have at leastthe "copyright" line and a pointer to where the full notice is found.    <one line to give the program's name and a brief idea of what it does.>    Copyright (C) <year>  <name of author>    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.Also add information on how to contact you by electronic and paper mail.If the program is interactive, make it output a short notice like thiswhen it starts in an interactive mode:    Gnomovision version 69, Copyright (C) year name of author    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.    This is free software, and you are welcome to redistribute it    under certain conditions; type `show c' for details.The hypothetical commands `show w' and `show c' should show the appropriateparts of the General Public License.  Of course, the commands you use maybe called something other than `show w' and `show c'; they could even bemouse-clicks or menu items- whatever suits your program.You should also get your employer (if you work as a programmer) or yourschool, if any, to sign a "copyright disclaimer" for the program, ifnecessary.  Here is a sample; alter the names:  Yoyodyne, Inc., hereby disclaims all copyright interest in the program  `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989  Ty Coon, President of ViceThis General Public License does not permit incorporating your program intoproprietary programs.  If your program is a subroutine library, you mayconsider it more useful to permit linking proprietary applications with thelibrary.  If this is what you want to do, use the GNU Lesser GeneralPublic License instead of this License.Comment: This package provides a Smalltalk implementation of Rick Mugridge's [FitLibrary](http://fitlibrary.sourceforge.net).# Smalltalk FitSmalltalk Fit is a Smalltalk implementation of Ward Cunningham's [Framework for Integrated Tests](http://fit.c2.com), [Fitnesse](http://www.fitnesse.org), and Rick Mugridge's [FitLibrary](http://fitlibrary.sourceforge.net).This version contains the equivalent features of:* fit-java-1.1* fitnesse-20121220* FitLibrary-2.0# License   Copyright (C) 2004-2013 Randy Coulman    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.See the copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.I am using the GPL because this software is considered a derivative work of the original Fit and FitLibrary implementations in Java, and they are both licensed under the GPL, so I must use it.  The use of the GPL in Smalltalk is complicated, and I am not a lawyer.  My intention is that you may write Fit/FitLibrary tests for your software without causing your software to come under the terms of the GPL.  The test fixture code you write necessarily comes under the GPL, because it likely inherits from base classes provided in the library.  However, I consider there to be a "firewall" between the fixture code and the domain code as long as you keep them in separate packages.  I believe that this is consistent with the original Java implementation, where your domain code would be in a separate .jar file from your test fixture code.  If you have any questions about this, please contact me (see below for contact information).# IntroductionSmalltalk Fit's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).  Check there for the latest version.  It is also on [GitHub](https://github.com/randycoulman/SmalltalkFit).SmalltalkFit was developed in VW 7.9.1, but is compatible with VW 7.7 and later.  If you find any incompatibilities with VW 7.7 or later, let me know (see below for contact information) or file an issue on GitHub.# FitLibraryThis is an almost-complete implementation of FitLibrary 2.  Missing features include:* Dot Graphics* Arithmetic expressions in table cells* Recording dynamic variables to file* Full Unicode support* The "define actions slowly" actionIn order to use the DefinedActions feature where the actions are specified on a different page, it is necessary to tell the Smalltalk FitLibrary code where to find your fitnesse implementation, especially when running from a development image.  There are two options:1. On platforms which support symbolic links, make a symlink from FitNesseRoot in your image's working directory to the FitNesseRoot directory of your Fitnesse installation.2. Send DefineActions class>>fitnesseDirectory: with the path to your fitnesse installation (the parent directory of your FitNesseRoot directory).If you are upgrading from the previous version of FitLibrary, you'll need to adjust for the following incompatibilities:* Any suites that use FitLibrary must define `TEST_RUNNER` to be fitlibrary.suite.FitLibraryServer.* Your `COMMAND_PATTERN` must make use of the `%m` argument so that the proper `TEST_RUNNER` is passed to it.     If you were using `%m` for something else, you'll need to change that.* Any method signatures that specify `Collection` need to specify a more concrete collection type instead (such as `OrderedCollection`).* Any method that returns a collection of a domain class must now specify the type of the elements in the collection.  Thus, instead of taking or returning `OrderedCollection`, take or return `#(#OrderedCollection #MyDomainClass)`.* FitLibrary fixtures no longer have a `systemUnderTest` instance variable.  Use `self systemUnderTest` in your subclasses instead.* `FitLibraryFixture` no longer implements `#tearDown`, so any super-sends in your subclasses will need to be removed.* `ArrayFixture`/`ListFixture`/etc: The `#actualCollection:` instance creation method has been renamed to `#actuals:`.  You'll need to adjust for this rename.* Overly permissive `#signatureFor:` methods will need to be restricted.  If your implementation returns a default method signature, you wll begin to see errors in your tests for completely unrelated methods.  This version of FitLibrary uses a more flexible approach to finding methods and will attempt to find signatures for methods that it hadn't considered in the past.  Your `#signatureFor:` methods should either answer `super` or `nil` if a specific match isn't found.  I recommend switching over to the new pragma method signatures instead, but `#signatureFor:` will continue to work as long as no instance-specific actions are required to compute a proper `MethodSignature`.* `#signatureFor:` methods must not do anything instance-specific, or they will not work correctly due to several caches that were implemented for   optimization purposes.This version of FitLibrary is designed to work with Fitnesse-20121220 or later.  It will work with earlier versions of Fitnesse as well, with one minor exception: The "show as after table" feature generates explicit HTML markup for collapsible sections, which changed in Fitnesse 20121220.  To use the older markup, you can evaluate `FoldingTexts useOldMarkup: true`.  Or, modify `FitLibraryServer>>initialize` to include the line `batching useOldFoldingTextMarkup: true`.The internal implementation details of FitLibrary have been moved into the FitLibrary-Internals package.  If you find that you need to depend on something in FitLibrary-Internals, I consider that a bug.  Please let me know so I can fix it.# UsageSee the package comment on the Fit package for usage instructions.# AcknowledgementsI inherited Smalltalk Fit from Dave Astels.  He had a mostly working port of Fit done.  I enhanced it and added Fitnesse and FitLibrary support.Alan Wostenberg devised the simple file-based scheme that is used for running tests against a development image.# ContributingI'm happy to receive bug fixes and improvements to this package.  Ifyou'd like to contribute, please publish your changes as a "branch"(non-integer) version in the Public Store Repository and contact me asoutlined below to let me know.  I will merge your changes back intothe "trunk" as soon as I can review them.# Contact InformationIf you have any questions about SmalltalkFit and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1691DbUsername: randyDbVersion: 43DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Fit' '') #(#any 'FitLibrary-Internals' ''))IgnoredPrerequisites: #()Namespace: Smalltalk.FitlibraryPackageName: FitLibraryParcel: #('FitLibrary')ParcelName: FitLibraryPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Fit') #(#name 'FitLibrary-Internals' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Fit' '') #('FitLibrary-Internals' ''))PrintStringCache: (43,randy)Version: 43Date: 8:18:50 AM May 13, 2014 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.10.1 of February 6, 2014 on May 13, 2014 at 8:18:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Fitlibrary</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fitlibrary.FitlibraryInternals.*			private FitlibraryInternals.Utility.*			private Fitlibrary.Traverse.*			private Fitlibrary.Traverse.Workflow.*			</imports><category></category><attributes><package>FitLibrary</package></attributes></name-space><name-space><name>Suite</name><environment>Fitlibrary</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.*			private Fit.*			private Fitlibrary.FitlibraryInternals.*			</imports><category></category><attributes><package>FitLibrary</package></attributes></name-space><name-space><name>Traverse</name><environment>Fitlibrary</environment><private>false</private><imports>			private Smalltalk.*			private FitlibraryInternals.*			</imports><category></category><attributes><package>FitLibrary</package></attributes></name-space><name-space><name>Workflow</name><environment>Fitlibrary.Traverse</environment><private>false</private><imports>			private Smalltalk.*			private FitlibraryInternals.*			private Fit.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary</package></attributes></name-space><name-space><name>FitlibraryGeneric</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private FitlibraryInternals.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary</package></attributes></name-space><name-space><name>Spec</name><environment>Fitlibrary</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.*			private Fitlibrary.Suite.*			private Fit.*			private Fitlibrary.FitlibraryInternals.*			</imports><category></category><attributes><package>FitLibrary</package></attributes></name-space><class><name>TraverseBase</name><environment>Fitlibrary.Traverse</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext typedObjectUnderTest </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Traverse.TraverseBase</class-id><body>The abstract base class of all table traverses (a.k.a. fixtures).Subclasses must implement the following messages:	running		interpretAfterFirstRow:resultsInto:Instance Variables:	runtimeContext	&lt;RuntimeContextContainer&gt;	The runtime context for the current test suite run.</body></comment><class><name>DefineAction</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pageName wikiClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DefineAction</class-id><body>A Traverse for creating DefinedActions.</body></comment><class><name>FitLibraryServer</name><environment>Fitlibrary.Suite</environment><super>FitlibraryInternals.FitServerBridge</super><private>false</private><indexed-type>none</indexed-type><inst-vars>batching </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Suite.FitLibraryServer</class-id><body>A FitServerBridge that runs storytests using a BatchFitLibrary.Instance Variables	batching	&lt;BatchFitLibrary&gt;	The storytest runner.</body></comment><class><name>DomainInjectionTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>domainTraverser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainInjectionTraverse</class-id><body>A Traverse for setting up domain objects from a table.  This is the analogue to DomainObjectCheckTraverse as used in domain workflow.Instance Variables	domainTraverser	&lt;DoFlow&gt;	The DoFlow that is driving the workflow in the current test.</body></comment><class><name>DoTraverse</name><environment>Fitlibrary.Traverse.Workflow</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatchRowInFlow doAutoWrapper prefixSpecialAction sequencing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id><body>Implements the interpretation of DoFixture tables.Instance Variables	dispatchRowInFlow	&lt;DispatchRowInFlow&gt;	Helper for evaulating individual rows of the table.</body></comment><class><name>CompareFilesTraverse</name><environment>Fitlibrary.Traverse</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Traverse.CompareFilesTraverse</class-id><body>A Traverse for comparing file and directory contents. </body></comment><class><name>FitLibraryFixture</name><environment>Fitlibrary</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typedObjectUnderTest traverse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.FitLibraryFixture</class-id><body>The superclass of all flow-style Fixtures.  FitLibraryFixture is actually now just a simple wrapper/forwarder around Traverse, but is retained for backwards compatibility with FitLibrary1.Instance Variables	systemUnderTest	&lt;Object&gt;	An object from the system being tested.  Any test actions are looked up on this object before looking at the fixture.	traverse	&lt;Traverse&gt;	The Traverse that implements the actual flow interpretation.</body></comment><class><name>FunctionFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.FunctionFixture</class-id><body>Base class of Fixtures that essentially implement a function of some sort.  Wraps FunctionTraverse.</body></comment><class><name>ConstraintFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ConstraintFixture</class-id><body>A Fixture for testing business rule constraints.  Wraps ConstraintTraverse.</body></comment><class><name>FunctionTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exceptionString repeatString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.FunctionTraverse</class-id><body>The abstract base class of Traverses that evaluate a table as a function.</body></comment><class><name>GenericListSetUpTraverse</name><environment>FitlibraryGeneric</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentClass list targets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>FitlibraryGeneric.GenericListSetUpTraverse</class-id><body>A traverse that sets up objects of a specific type in an OrderedCollection.  "Generic" here refers to Java Generics, where we know the actual type of of the objects we're working with.Instance Variables	componentClass	&lt;Class&gt;	The class of the objects in the collection.	list	&lt;OrderedCollection&gt;	The collection of objects being created.	targets	&lt;(Array of: CalledMethodTarget)&gt;	The methods to be called on the objects.</body></comment><class><name>ArraySetUpTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>array valueParser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ArraySetUpTraverse</class-id><body>A Traverse for turning a nested table into an array.Instance Variables	array	&lt;Array&gt;	The array that was extracted from the nested table.	valueParser	&lt;Parser&gt;	The Parser used to parse the individual cell values.</body></comment><class><name>PrimitiveArrayFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.PrimitiveArrayFixture</class-id><body>A fixture that checks the contents of any array of primitives.</body></comment><class><name>GridFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.GridFixture</class-id><body>A fixture that checks the values in a table against the values in a 2D array.  Wraps a GridTraverse.</body></comment><class><name>ImageFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.GridFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ImageFixture</class-id><body>A specialized GridFixture whose cells contain HTML image links.</body></comment><class><name>CollectionTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actuals usedFields showSurplus componentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CollectionTraverse</class-id><body>An abstract Traverse for checking the contents of a Collection of non-"primtive" objects.Subclasses must implement the following messages:	running		interpretRow:getters:resultsInto:Instance Variables	actuals	&lt;(Collection of: Object)&gt;	The collection of actual values to compare with the table.	usedFields	&lt;(Array of: Boolean)&gt;	The columns of the table that have been matched to the object being represented.</body></comment><class><name>DomainObjectSetUpTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainObjectSetUpTraverse</class-id><body>A Traverse for setting up a domain object for later use within a test.Instance Variables	type	&lt;Class&gt;	The class of the domain object to create.</body></comment><class><name>CalculateTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argCount targets methods boundOK notesPermitted hasNotes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CalculateTraverse</class-id><body>A traverse similar in function to ColumnFixture, except that: o It separates the given and calculated columns by an empty column o It doesn't treat any strings as special by default o Special strings can be defined for repeats and exception-expected. o A single method call is made for each expected column, rather than   using public instance variables for the givens, as with ColumnFixture.   With the header row:       |g1 |g2 ||e1 |e2 |       |1.1|1.2||2.3|0.1|   Each row will lead to a call of the following methods with two (given)   double arguments:       e1G1:g2: and e2G1:g2:* o As with WorkflowTraverse, a systemUnderTest (SUT) may be associated with the  domain object and any method calls not available on the domain object are   called on the SUT.  See the FitLibrary specifications for examplesInstance Variables	argCount	&lt;Integer&gt;	Number of arguments expected by the calculation methods.	boundOK	&lt;Boolean&gt;	True if any of the methods were found; false otherwise.	methods	&lt;Integer&gt;	The number of calculation methods expected.	targets	&lt;(Array of: CalledMethodTarget)&gt;	The method targets to be called.</body></comment><class><name>Show</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>htmlString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Show</class-id><body>The container of explanatory text to show when a FitLibraryShowException is raised.Instance Variables	htmlString	&lt;String&gt;	The text to show.</body></comment><class><name>NestingSetTraverse</name><environment>FitlibraryGeneric</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>set typeAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>FitlibraryGeneric.NestingSetTraverse</class-id><body>A Traverse for checking nested sets of objects.Instance Variables	set	&lt;Set&gt;	The set of nested elements to check.	typeAdapter	&lt;TypeAdapter&gt;	The type of the nested sets.</body></comment><class><name>DomainCheckTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainCheckTraverse</class-id><body>A Traverse for checking domain objects in a table.</body></comment><class><name>CollectionSetUpTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argCount target boundOK collection embedded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CollectionSetUpTraverse</class-id><body>A traverse for setting up a collection of objects.Instance Variables	argCount	&lt;SmallInteger&gt;	The number of arguments required by the setup method.	boundOK	&lt;Boolean&gt;	True if the setup method was bound correctly; false otherwise.	target	&lt;CalledMethodTarget&gt;	The setup method to call.</body></comment><class><name>ExplicitSelf</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actualSelf </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ExplicitSelf</class-id><body>In MethodClosure&gt;&gt;invokeOnArguments:, we guard against Smalltalk's typical implicit return of self by returning nil in that case.  Otherwise,an implicitly-returned object can become the main "fixture" of a test when that wasn't intended.Sometimes, however, you really do want to return self and have that object be used in the rest of the test.  ExplictSelf is used for this case.  Instead of explicitly doing a ^self, use ^ExplicitSelf for: self instead. Instance Variables	actualSelf	&lt;Object&gt;	The value "self" that is being explicitly returned.</body></comment><class><name>SetVariableTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SetVariableTraverse</class-id><body>A Traverse that allows a number of variables to be set in a table.</body></comment><class><name>MapTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>map keyParser valueParser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.MapTraverse</class-id><body>A Traverse for checking Dictionary contents.  MapTraverse tables should have two columns with no headings.  The first column corresponds to the key, and the second to the value.Instance Variables	keyParser	&lt;Parser&gt;	The parser for the key column.	map	&lt;Dictionary&gt;	The dictionary to be checked.	valueParser	&lt;Parser&gt;	The parser for the value column.</body></comment><class><name>SubsetMapTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.MapTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SubsetMapTraverse</class-id><body>A MapTraverse that ignores any extra elements in the map.</body></comment><class><name>CompareFilesFixture</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>traverse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CompareFilesFixture</class-id><body>A Fixture for comparing file and directory contents.  Wraps a CompareFilesTraverse.Instance Variables	traverse	&lt;CompareFilesTraverse&gt;	The wrapped Traverse that all actions delegate to.</body></comment><class><name>DoFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DoFixture</class-id><body>A Fixture for interpreting tables in a flow style.  DoFixture is actually now just a simple wrapper/forwarder around DoTraverse, but is retained for backwards compatibility with FitLibrary1.Instance Variables	doTraverse	&lt;DoTraverse&gt;	The DoTraverse that implements the flow style.</body></comment><class><name>SetUpFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SetUpFixture</class-id><body>A Fixture for setting up a collection of objects.  Wraps a CollectionSetUpTraverse.</body></comment><class><name>CommentFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CommentFixture</class-id><body>A Fixture that does not process the rest of its table, treating it as a comment.  Wraps a CommentTraverse.</body></comment><class><name>ListOfMapsTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maps </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ListOfMapsTraverse</class-id><body>A Traverse for checking the contents of an OrderedCollection that contains Dictionaries.Instance Variables	maps	&lt;OrderedCollection&gt;	The dictionaries to check.</body></comment><class><name>DefaultPackages</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DefaultPackages</class-id><body>The FitLibrary equivalent of Fit's ImportFixture.  Called by its string name from CreateFromClassNameCaller.</body></comment><class><name>CollectionFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CollectionFixture</class-id><body>An abstract Fixture for testing various types of collections of non-primitive objects.</body></comment><class><name>ArrayFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ArrayFixture</class-id><body>A Fixture for checking the contents of a SequenceableCollection of non-"primtive" objects.</body></comment><class><name>DomainObjectSetUpFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainObjectSetUpFixture</class-id><body>A Fixture for setting up a domain object for later use within a test.  Wraps a DomainObjectSetUpTraverse.</body></comment><class><name>OnError</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.OnError</class-id><body>The base class of error handlers for the tests.Subclasses must implement the following messages:	accessing		stopOnFailures:errors:Instance Variables	runtimeContext	&lt;RuntimeContext&gt;	The context of the currently running test suite.</body></comment><class><name>MultiDefinedActionRunnerTraverse</name><environment>Fitlibrary.Traverse.Workflow</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Traverse.Workflow.MultiDefinedActionRunnerTraverse</class-id><body>A Traverse that invokes a MultiDefinedAction (whose name is in the first row of the table) using parameters (named by the second row of the table) whose values are specified in the remaining rows of fthe table.Instance Variables	binder	&lt;ParameterBinder&gt;	The ParameterBinder that represents the DefinedAction to call.</body></comment><class><name>CalculateFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CalculateFixture</class-id><body>A Fixture for performing business rule calculations.  Simple wrapper around CalculateTraverse.</body></comment><class><name>PropertyEditor</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.PropertyEditor</class-id><body>Simulates part of the Java PropertyEditor interface/PropertyEditorSupport base class.  Used to convert objects to/from strings.Subclasses must implement the following messages:	accessing		getAsText		setAsText:Instance Variables	value	&lt;Object&gt;	The value to be converted.</body></comment><class><name>ArrayTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser array componentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ArrayTraverse</class-id><body>A Traverse for checking the contents of an Array or other SequenceableCollection of "primitives".Instance Variables	parser	&lt;ArrayParser&gt;	The parser used to parse/display the elements of the Array.	typedArray	&lt;TypedObject&gt;	The typed wrapper around the Array to check.</body></comment><class><name>DomainFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainFixture</class-id><body>A Fixture for testing domain objects directly.</body></comment><class><name>CombinationTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodTarget firstParser methodOK topValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CombinationTraverse</class-id><body>A Traverse for testing combinations of values.  The values to be combined are in the top row and leftmost column of the test table.  Values are combined using the #combine:and: method.Instance Variables	firstParser	&lt;Parser&gt;	The parser for the left-column values.	methodOK	&lt;Boolean&gt;	true if the #combine:and: method was found; false otherwise.	methodTarget	&lt;CalledMethodTarget&gt;	The CalledMethodTarget representing #combine:and:.	topValues	&lt;Collection&gt;	The parsed values from the top row of the table.</body></comment><class><name>BatchFitLibrary</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableListener doFlow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.BatchFitLibrary</class-id><body>Runs a single storytest.Instance Variables	doFlow	&lt;DoFlow&gt;	Runs the storytest in flow mode.	tableListener	&lt;TableListener&gt;	Object to notify upon completion of each table and the storytest.</body></comment><class><name>MapSetUpTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyParser valueParser theMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.MapSetUpTraverse</class-id><body>A Traverse for building up a Dictionary out of a two-column table.Instance Variables	keyParser	&lt;Parser&gt;	The Parser for the key column values.	theMap	&lt;Dictionary&gt;	The Dictionary being constructed.	valueParser	&lt;Parser&gt;	The Parser for the value column values.</body></comment><class><name>DomainFixtured</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainFixtured</class-id><body>A base class for objects that are treated as domain objects in FitLibrary tables.  This is a marker interface in Java, but actually has behavior in Smalltalk.</body></comment><class><name>CombinationFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.CombinationFixture</class-id><body>A Fixture for testing combinations of values.  Wraps a ConstraintTraverse.</body></comment><class><name>NestingListTraverse</name><environment>FitlibraryGeneric</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list typeAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>FitlibraryGeneric.NestingListTraverse</class-id><body>A Traverse for checking nested collections of objects.Instance Variables	list	&lt;OrderedCollection&gt;	The collection of nested collections to check.	typeAdapter	&lt;TypeAdapter&gt;	The type of the nested collections.</body></comment><class><name>Rule</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Rule</class-id><body>Base class/interface of objects which get automatically wrapped in a RuleTable.</body></comment><class><name>ParamRowFixture</name><environment>Fitlibrary</environment><super>Fit.RowFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects targetClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ParamRowFixture</class-id><body>A RowFixture that can be constructed with the list of objects to validate and the class of those objects, rather than having to make a specialized subclass of RowFixture.Instance Variables	objects	&lt;OrderedCollection&gt;	The objects to validate.	targetClass	&lt;Class&gt;	The class of the objects in the collection.</body></comment><class><name>FitLibraryShowException</name><environment>Fitlibrary</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars>show </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.FitLibraryShowException</class-id><body>An exception that will also append some explanatory text to the end of the row.Instance Variables	show	&lt;Show&gt;	The explanatory text to show.</body></comment><class><name>SequenceTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SequenceTraverse</class-id><body>Exactly the same as DoTraverse, except that actions don't have keywords in every second cell.</body></comment><class><name>SpecifyFixture</name><environment>Fitlibrary.Spec</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runner tablesCompare errorReport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Spec.SpecifyFixture</class-id><body>A Fixture used for running specification tests for Fit and FitLibrary.  Tests typically contain nested tables indicating the Fit test to run and the expected results.Instance Variables	errorReport	&lt;SpecifyErrorReport&gt;	 The error report that later gets added to the end of the test.	runner	&lt;BatchFitLibrary&gt;	The storytest runner that runs the Fit test that is being checked.	tablesCompare	&lt;TablesCompare&gt;	Helper for comparing actual and expected tests result tables.</body></comment><class><name>SpecifySuiteFixture</name><environment>Fitlibrary.Spec</environment><super>Fitlibrary.Spec.SpecifyFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Spec.SpecifySuiteFixture</class-id><body>Like SpecifyFixture, except that:* It handles multiple rows, where each row corresponds to a storytest* The first row will usually hold the SuiteSetUp tables, which will register a new FixtureSupplier* It uses BatchFitLibrary to doTables()</body></comment><class><name>TaggedString</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.TaggedString</class-id><body>A string that contains HTML tags and is displayed as such.Instance Variables	string	&lt;String&gt;	The HTML string.</body></comment><class><name>SelectFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SelectFixture</class-id><body>A now-obsolete DoFixture for implementing the 'select' special action.  Its functionality is now handled by DoFlow/ScopeStack.</body></comment><class><name>NullOnErrorHandler</name><environment>Fitlibrary</environment><super>Fitlibrary.OnError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.NullOnErrorHandler</class-id><body>A no-op version of OnError (null object pattern).</body></comment><class><name>RuleTable</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasErrors columnTargets resetMethod executeMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.RuleTable</class-id><body>A Traverse for specifying business rules in a test table.  The table has input and output columns that represent methods on the system under test..  If defined, #reset is sent at the beginning of each row, and #execute is sent just prior to evaluating the first output column in the row.Instance Variables	columnTargets	&lt;Collection&gt;	The method targets for each column.	executeMethod	&lt;CalledMethodTarget&gt;	The method target representing the #execute method.	hasErrors	&lt;Boolean&gt;	true if errors were encountered when binding the columns; false otherwise.	resetMethod	&lt;CalledMethodTarget&gt;	The method target representing the #execute method.</body></comment><class><name>NestingListSetUpTraverse</name><environment>FitlibraryGeneric</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list componentAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>FitlibraryGeneric.NestingListSetUpTraverse</class-id><body>A Traverse that sets up a nested collection of objects.Instance Variables	componentAdapter	&lt;TypeAdapter&gt;	The type of the nested collection.	list	&lt;OrderedCollection&gt;	The collection containing the nested collections.</body></comment><class><name>SetFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SetFixture</class-id><body>A fixture for checking unordered collections of objects.</body></comment><class><name>ConstraintTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argCount target methodOK expected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ConstraintTraverse</class-id><body>A Traverse that checks a constraint in the form of a method that returns true or false.Instance Variables	argCount	&lt;Number&gt;	The number of arguments the method takes.	methodOK	&lt;Boolean&gt;	True if the method was found and validated; false otherwise.	target	&lt;CalledMethodTarget&gt;	The method target to call.</body></comment><class><name>RandomSelectTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.RandomSelectTraverse</class-id><body>A Traverse for a single-column table that randomly selects one of its elements and assigns it to a dynamic variable.Instance Variables	variable	&lt;String&gt;	The name of the dynamic variable to assign to.</body></comment><class><name>DomainTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainTraverse</class-id><body>A Traverse for checking domain objects directly.</body></comment><class><name>SubsetFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SubsetFixture</class-id><body>A Fixture that checks a subset of items in a collection of objects.</body></comment><class><name>SetTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SetTraverse</class-id><body>A Traverse for checking the contents of a Set.</body></comment><class><name>DomainObjectCheckFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainObjectCheckFixture</class-id><body>A Fixture for checking a single domain object.  Wraps a DomainObjectCheckTraverse.</body></comment><class><name>DomainObjectCheckTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.DomainObjectCheckTraverse</class-id><body>A Traverse for checking a single domain object.Instance Variables	type	&lt;TypeAdapter&gt;	description of type</body></comment><class><name>SequenceFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.SequenceFixture</class-id><body>Exactly the same as DoFixture, except that actions don't have keywords in every second cell.</body></comment><class><name>ClassPropertyEditor</name><environment>Fitlibrary</environment><super>Fitlibrary.PropertyEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ClassPropertyEditor</class-id><body>A PropertyEditor for converting classes to/from strings.</body></comment><class><name>ListTraverse</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.ListTraverse</class-id><body>A Traverse for checking the contents of a SequenceableCollection of non-"primtive" objects.</body></comment><class><name>CommentTraverse</name><environment>Fitlibrary.Traverse</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>markAsIgnored </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Traverse.CommentTraverse</class-id><body>A Traverse that does not process the rest of its table, treating it as a comment.</body></comment><class><name>SuiteFixture</name><environment>Fitlibrary.Suite</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Suite.SuiteFixture</class-id><body>A DoFixture that allows selective execution of parts of a test based on keywords.Instance Variables	keys	&lt;Set&gt;	The keywords that are currently selected for execution.</body></comment><class><name>GridTraverse</name><environment>Fitlibrary.Traverse</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid parser elementType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><comment><class-id>Fitlibrary.Traverse.GridTraverse</class-id><body>A Traverse that checks the values in a table against the values in a 2D array.Instance Variables	grid	&lt;Array&gt;	The 2D array to check against the table.	parser	&lt;Parser&gt;	The Parser to use to intepret cell values.</body></comment><shared-variable><name>RandomGenerator</name><environment>Fitlibrary.RandomSelectTraverse</environment><private>false</private><constant>false</constant><category>random</category><attributes><package>FitLibrary</package></attributes></shared-variable><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	^self subclassResponsibility</body><body package="FitLibrary">interpretInnerTableWithinScope: aTable runtimeContext: aRuntimeContext resultsInto: aTestResults	| row |	row := FitlibraryInternals.Row new.	aTable add: row at: 1.	row beHidden.		[self		interpretWithinScope: aTable		runtimeContext: aRuntimeContext		resultsInto: aTestResults]			ensure: [aTable removeElementAt: 1]</body><body package="FitLibrary">interpretWithinScope: aTable runtimeContext: aRuntimeContext resultsInto: aTestResults	self runtimeContext: aRuntimeContext.	runtimeContext scope temporarilyAdd: self.	[self interpretAfterFirstRow: aTable resultsInto: aTestResults]		ensure: [runtimeContext scope removeTemporary: self]</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>accessing</category><body package="FitLibrary">extendedCamel: aString	^runtimeContext extendedCamel: aString</body><body package="FitLibrary">fitHandler	^FitlibraryInternals.FitHandler new</body><body package="FitLibrary">runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext</body><body package="FitLibrary">scope	^self runtimeContext scope</body><body package="FitLibrary">systemUnderTest	^typedObjectUnderTest ifNotNil: #subject</body><body package="FitLibrary">systemUnderTest: anObject	typedObjectUnderTest := anObject asFitLibraryTypedObject</body><body package="FitLibrary">typedSystemUnderTest	^typedObjectUnderTest</body><body package="FitLibrary">typedSystemUnderTest: aTypedObject	(self isSUTCycleBetween: self and: aTypedObject subject)		ifTrue: 			[^CycleException				cycle: 'systemUnderTest'				between: self				and: aTypedObject subject].	typedObjectUnderTest := aTypedObject</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>private</category><body package="FitLibrary">global	^self runtimeContext global</body><body package="FitLibrary">isSUTCycleBetween: aDomainAdapter and: anObject	aDomainAdapter == anObject ifTrue: [^true].	(anObject respondsTo: #systemUnderTest) ifFalse: [^false].	^self isSUTCycleBetween: aDomainAdapter and: anObject systemUnderTest</body><body package="FitLibrary">runtimeContext	runtimeContext		ifNil: 			[^self error: 'Runtime has not been injected into ' , self printString						, '. See .FitLibrary.AdvancedTutorials.RuntimeInjection.'].	^runtimeContext</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>dynamic variables</category><body package="FitLibrary">dynamicVariableAt: aString	^self dynamicVariables at: aString</body><body package="FitLibrary">dynamicVariableAt: aString put: anObject	self dynamicVariables at: aString put: anObject</body><body package="FitLibrary">dynamicVariables	^self runtimeContext dynamicVariables</body><body package="FitLibrary">resolve: aString	^self variableResolver resolve: aString</body><body package="FitLibrary">variableResolver	^self dynamicVariables</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryAutoWrappedFor: aTypedObject evaluator: anEvaluator	^self</body><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	aDoFlowOnTable		runEvaluator: self		typedResult: anInnerTableContext typedSubject		onTable: anInnerTableContext table		fromRow: anInnerTableContext rowIndex		resultsInto: aTestResults.	^true</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>testing</category><body package="FitLibrary">doesInnerTablePass: aTable runtimeContext: aRuntimeContext resultsInto: aTestResults	| innerResults |	innerResults := FitlibraryInternals.TestResults new.	self		interpretInnerTableWithinScope: aTable		runtimeContext: aRuntimeContext		resultsInto: innerResults.	aTestResults add: innerResults.	^innerResults hasPassed</body><body package="FitLibrary">doesTablePass: aTable runtimeContext: aRuntimeContext resultsInto: aTestResults	| innerResults |	innerResults := FitlibraryInternals.TestResults new.	self		interpretWithinScope: aTable		runtimeContext: aRuntimeContext		resultsInto: innerResults.	aTestResults add: innerResults.	^innerResults hasPassed</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>special actions</category><body package="FitLibrary">show: aString	runtimeContext show: aString</body><body package="FitLibrary">showAfterTable: aString	self showAsAfterTableTitle: 'Logs' contents: aString</body><body package="FitLibrary">showAsAfterTableTitle: titleString contents: contentsString	self global showAsAfterTableTitle: titleString contents: contentsString</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase</class-id> <category>parse delegates</category><body package="FitLibrary">registerParseDelegateClass: delegateClass forClass: aClass	ParseDelegation registerParseDelegateClass: delegateClass forClass: aClass</body><body package="FitLibrary">registerParseDelegateObject: anObject forClass: aClass	ParseDelegation registerParseDelegateObject: anObject forClass: aClass</body><body package="FitLibrary">registerSuperParseDelegate: anObject forClass: aClass	ParseDelegation registerSuperParseDelegate: anObject forClass: aClass</body></methods><methods><class-id>Fitlibrary.Traverse.TraverseBase class</class-id> <category>instance creation</category><body package="FitLibrary">new	^super new initialize</body><body package="FitLibrary">systemUnderTest: anObject	^self new systemUnderTest: anObject</body></methods><methods><class-id>Fitlibrary.DefineAction</class-id> <category>private</category><body package="FitLibrary">checkSizeWithRegardToTheClass: aTable	| hasClass bodyRow |	(aTable size between: 2 and: 3)		ifFalse: 			[^FitLibraryException				raiseErrorString: 'Table for DefineAction needs to be two or three rows, but is '						, aTable size printString , '.'].	hasClass := aTable size = 3.	bodyRow := aTable size.	(aTable at: 2) size = 1		ifFalse: 			[^FitLibraryException				raiseErrorString: 'Second row of table for DefineAction needs to contain one cell.'].	(hasClass and: [(aTable at: 3) size ~= 1])		ifTrue: 			[^FitLibraryException				raiseErrorString: 'Third row of table for DefineAction needs to contain one cell.'].	((aTable at: bodyRow) first hasEmbeddedTables: self)		ifFalse: 			[^FitLibraryException				raiseErrorString: 'Last row of table for DefineAction needs to contain nested tables.'].	hasClass		ifTrue: [wikiClassName := (aTable at: 2) resolvedTextAt: 0 resolver: self]</body><body package="FitLibrary">copyBody: aTables	| row |	(aTables existsAt: 2) ifTrue: [^(aTables from: 2) deepCopy].	row := Row new.	row addCellWithString: 'comment'.	^Tables withTable: (Table withRow: row)</body><body package="FitLibrary">define: aTable resultsInto: aTestResults	| tables headerTable |	self checkSizeWithRegardToTheClass: aTable.	tables := (aTable at: 2) first embeddedTables.	headerTable := tables first.	headerTable size &gt; 1		ifTrue: 			[self processMultiDefinedActionHeader: headerTable				body: (self copyBody: tables)]		ifFalse: 			[self				processDefinedActionHeader: headerTable				body: (self copyBody: tables)				resultsInto: aTestResults]</body><body package="FitLibrary">error: aString inRow: aRow	^FitLibraryExceptionInHtml		raiseErrorString: aString , ' in &lt;b&gt;'				, (aRow methodNameForCamel: self runtimeContext) , '&lt;/b&gt; in '				, (DefinedActionCaller link2: pageName)</body><body package="FitLibrary">formalParametersIn: aRow from: startInteger by: incrementInteger	| formalParameters |	formalParameters := OrderedCollection new.	self wikiClassBased ifTrue: [formalParameters add: 'this'].	startInteger to: aRow size		by: incrementInteger		do: 			[:index |			| parameter |			parameter := aRow resolvedTextAt: index resolver: self.			parameter isEmpty				ifTrue: [^self error: 'Parameter name is blank' inRow: aRow].			(formalParameters includes: parameter)				ifTrue: 					[^self error: 'Parameter name ''&lt;b&gt;' , parameter , '&lt;/b&gt;'' is duplicated'						inRow: aRow].			formalParameters add: parameter].	^formalParameters</body><body package="FitLibrary">processDefinedActionHeader: aTable body: aTables resultsInto: aTestResults	| parametersRow formalParameters binder |	parametersRow := aTable first.	parametersRow passKeywords: aTestResults.	formalParameters := self formalParametersIn: parametersRow from: 2 by: 2.	((self dynamicVariableAt: self class autoTranslateDefinedActionParameters)		= 'true' and: 				[DefinedActionParameterTranslation					needToTranslateParameters: formalParameters					inTables: aTables])		ifTrue: 			[formalParameters := DefinedActionParameterTranslation						translateParameters: formalParameters						inTables: aTables].	binder := ParameterBinder				formalParameters: formalParameters				tables: aTables				pageName: pageName.	self repository		defineFromRow: parametersRow		wikiClassName: wikiClassName		binder: binder		runtimeContext: self runtimeContext		absoluteFileName: pageName</body><body package="FitLibrary">processMultiDefinedActionHeader: aTable body: aTables	| definedActionName formalParameters binder |	aTable size &gt; 2		ifTrue: 			[self error: 'Unexpected rows in first table of defined action'				inRow: aTable first].	definedActionName := aTable first first text.	formalParameters := self				formalParametersIn: (aTable at: 2)				from: 1				by: 1.	binder := ParameterBinder				formalParameters: formalParameters				tables: aTables				pageName: pageName.	self repository defineMultiDefinedActionNamed: definedActionName		binder: binder</body><body package="FitLibrary">repository	^TemporaryPlugBoardForRuntime definedActionsRepository</body><body package="FitLibrary">wikiClassBased	^wikiClassName notEmpty</body></methods><methods><class-id>Fitlibrary.DefineAction</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	[self define: aTable resultsInto: aTestResults] on: Error		do: [:ex | aTable error: ex resultsInto: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.DefineAction</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	wikiClassName := ''.	pageName := self class storytestBased</body><body package="FitLibrary">setWikiClassName: classNameString pageName: pageNameString	wikiClassName := classNameString.	pageName := pageNameString</body></methods><methods><class-id>Fitlibrary.DefineAction class</class-id> <category>constants</category><body package="FitLibrary">autoTranslateDefinedActionParameters	^'auto-translate defined action parameters'</body><body package="FitLibrary">storytestBased	^'storytest table'</body></methods><methods><class-id>Fitlibrary.DefineAction class</class-id> <category>instance creation</category><body package="FitLibrary">new	^super new initialize</body><body package="FitLibrary">wikiClassName: aString	^self wikiClassName: aString pageName: self storytestBased</body><body package="FitLibrary">wikiClassName: classNameString pageName: pageNameString	^self new setWikiClassName: classNameString pageName: pageNameString</body></methods><methods><class-id>Fitlibrary.DefineAction class</class-id> <category>accessing</category><body package="FitLibrary">fitnesseDirectory	^DefineActionsOnPageSlowly fitnesseDirectory</body><body package="FitLibrary">fitnesseDirectory: aFilenameOrString	DefineActionsOnPageSlowly fitnesseDirectory: aFilenameOrString</body></methods><methods><class-id>Fitlibrary.Suite.FitLibraryServer</class-id> <category>initialize-release</category><body package="FitLibrary">doTables: aTables	| tableListener |	tableListener := TableListener listener: reportListener.	batching doTables: aTables withListener: tableListener.	^tableListener testResults</body><body package="FitLibrary">initialize	super initialize.	batching := BatchFitLibrary new</body></methods><methods><class-id>Fitlibrary.Suite.FitLibraryServer</class-id> <category>private</category><body package="FitLibrary">doTablesInHtml: aString	^[self doTables: (Tables fromString: aString)] on: ParseError		do: 			[:ex |			"print exception"			ex return: TestResults new]</body><body package="FitLibrary">exit	batching exit.	super exit</body></methods><methods><class-id>Fitlibrary.DomainInjectionTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	aTable error: (Error new errorString: 'Don''t expect to have this called')		resultsInto: aTestResults.	^nil</body><body package="FitLibrary">runTable: aTable resultsInto: aTestResults	(self switchOnActions: aTable) ifTrue: [^domainTraverser setCurrentAction].	(self switchOnChecks: aTable) ifTrue: [^domainTraverser setCurrentCheck].		[[aTable do: [:each | self processRow: each resultsInto: aTestResults]]		on: IgnoredException		do: [:ex | ]]			on: Error			do: [:ex | aTable error: ex resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.DomainInjectionTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setDomainTraverser: aDoFlow	domainTraverser := aDoFlow</body></methods><methods><class-id>Fitlibrary.DomainInjectionTraverse</class-id> <category>private</category><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	aRow withResults: aTestResults		pairsDo: 			[:cell :nextCell |						[| target |			target := PlugBoard lookupTarget findSetter: (cell resolvedText: self)						onSutOf: self.						[[target invokeOnCell: nextCell resultsInto: aTestResults]				on: IgnoredException				do: [:ex | ]]					on: Error					do: [:ex | nextCell error: ex resultsInto: aTestResults]]					on: Error					do: [:ex | cell error: ex resultsInto: aTestResults]]</body><body package="FitLibrary">switchOnActions: aTable	domainTraverser ifNil: [^false].	aTable size = 1 ifFalse: [^false].	aTable first size = 1 ifFalse: [^false].	^aTable first first matchesTextInLowerCase: 'actions'		variableResolver: self</body><body package="FitLibrary">switchOnChecks: aTable	domainTraverser ifNil: [^false].	aTable size = 1 ifFalse: [^false].	aTable first size = 1 ifFalse: [^false].	^aTable first first matchesTextInLowerCase: 'checks' variableResolver: self</body></methods><methods><class-id>Fitlibrary.DomainInjectionTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">domainTraverser: aDoFlow	^self new setDomainTraverser: aDoFlow</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>accessing</category><body package="FitLibrary">becomesTimeout	^self global becomesTimeout</body><body package="FitLibrary">fitVariableAt: aString put: anObject	self global fitVariableAt: aString put: anObject</body><body package="FitLibrary">getSymbolNamed: aString	^self global getSymbolNamed: aString</body><body package="FitLibrary">setSystemProperty: nameString to: valueString	self global setSystemProperty: nameString to: valueString</body><body package="FitLibrary">timoutAt: aString	^self global timeoutAt: aString</body><body package="FitLibrary">timoutAt: aString put: anInteger	^self global timeoutAt: aString put: anInteger</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>special actions</category><body package="FitLibrary">abandonStorytest	self global abandonStorytest</body><body package="FitLibrary">clearDynamicVariables	^self global clearDynamicVariables</body><body package="FitLibrary">harvest: anArray usingPattern: patternString from: aString	^self global harvest: anArray usingPattern: patternString from: aString</body><body package="FitLibrary">logText: aString	self global logText: aString</body><body package="FitLibrary">setStopOnError: aBoolean	self global setStopOnError: aBoolean</body><body package="FitLibrary">sleepFor: aMilliseconds	^self global sleepFor: aMilliseconds</body><body package="FitLibrary">startStopWatch	self global startStopWatch</body><body package="FitLibrary">stopWatch	^self global stopWatch</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>special action support</category><body package="FitLibrary">callMethodInRow: aRow catchParseError: aBoolean operatorCell: aCell resultsInto: aTestResults	^(self findMethodFromRow222: aRow from: 2 using: 2)		invokeForSpecial: (aRow from: 3)		catchParseError: aBoolean		operatorCell: aCell		resultsInto: aTestResults</body><body package="FitLibrary">findMethodFromRow222: aRow from: fromInteger using: usingInteger	| extraCellsOnEnd |	extraCellsOnEnd := usingInteger - fromInteger.	^FitlibraryInternals.PlugBoard lookupTarget		findMethodByArityIn: aRow		from: fromInteger		to: aRow size - extraCellsOnEnd		doStyle: dispatchRowInFlow isDynamicSequencing not		evaluator: self</body><body package="FitLibrary">findMethodFromRow: aRow from: fromInteger extraCellsAtEnd: extraCellsInteger	^FitlibraryInternals.PlugBoard lookupTarget		findMethodByArityIn: aRow		from: fromInteger		to: aRow size - extraCellsInteger		doStyle: dispatchRowInFlow isDynamicSequencing not		evaluator: self</body><body package="FitLibrary">operatorCellIn: aRow	^aRow at: aRow size - 1</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>running</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	self class == DoTraverse		ifTrue: 			[aDoFlowOnTable				handleActualDoFixture: self				row: anInnerTableContext row				resultsInto: aTestResults]		ifFalse: 			[aDoFlowOnTable				pushOnScope: anInnerTableContext typedSubject				row: anInnerTableContext row				resultsInto: aTestResults].	^false</body><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	"Now handled by DoFlow"	^self</body><body package="FitLibrary">interpretInFlow: aTable resultsInto: aTestResults	"Subclasses may want to do more with this"	^nil</body><body package="FitLibrary">interpretRow: aRow resultsInto: aTestResults	^doAutoWrapper		wrap: (self interpretRowBeforeWrapping: aRow resultsInto: aTestResults)</body><body package="FitLibrary">interpretRowBeforeWrapping: aRow resultsInto: aTestResults	^dispatchRowInFlow interpretRow: aRow resultsInto: aTestResults</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	prefixSpecialAction := PrefixSpecialAction actionContext: self.	doAutoWrapper := DoAutoWrapper evaluator: self.	self setSequencing: false</body><body package="FitLibrary">setSequencing: aBoolean	sequencing := aBoolean.	dispatchRowInFlow := DispatchRowInFlow evaluator: self sequencing: aBoolean</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>dynamic variables</category><body package="FitLibrary">addDynamicVariablesFromFile: aString	self global addDynamicVariablesFromFile: aString</body><body package="FitLibrary">addDynamicVariablesFromUnicodeFile: aString	self global addDynamicVariablesFromUnicodeFile: aString</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>defined actions</category><body package="FitLibrary">clearDefinedActions	self global clearDefinedActions</body><body package="FitLibrary">defineAction	^self global defineAction</body><body package="FitLibrary">defineAction: aString	^self global defineAction: aString</body><body package="FitLibrary">defineActionsAt: aString	^self global defineActionsAt: aString</body><body package="FitLibrary">defineActionsAt: pageNameString from: rootLocationString	^self global defineActionsAt: pageNameString from: rootLocationString</body><body package="FitLibrary">defineActionsSlowlyAt: aString	^self global defineActionsSlowlyAt: aString</body><body package="FitLibrary">setExpandDefinedActions: aBoolean	self global setExpandDefinedActions: aBoolean</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>fixture selection</category><body package="FitLibrary">file: aString	^self global file: aString</body><body package="FitLibrary">selectRandomly: aString	^self global selectRandomly: aString</body><body package="FitLibrary">setVariables	^self global setVariables</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse class</class-id> <category>accessing</category><body package="FitLibrary">methodsThatAreVisible	^#(#calculate #start: #constraint #failingConstraint)</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject sequencing: aBoolean	^(self new)		systemUnderTest: anObject;		setSequencing: aBoolean;		yourself</body></methods><methods><class-id>Fitlibrary.Traverse.CompareFilesTraverse</class-id> <category>private</category><body package="FitLibrary">addSurplusFilesIn: aDictionary to: aCollection	aDictionary		keysAndValuesDo: [:tail :filename | aCollection add: (self surplus: filename)]</body><body package="FitLibrary">compareContentsOfDirectory: aFilename to: bFilename	| children fileMap title |	children := OrderedCollection new.	fileMap := self mappedFilesIn: bFilename.	(self sortedFilesIn: aFilename)		do: [:each | self matchFile: each to: fileMap resultsInto: children].	self addSurplusFilesIn: fileMap to: children.	title := self htmlLink: aFilename.	^(children anySatisfy: #isError)		ifTrue: [FitlibraryInternals.ListTreeError title: title children: children]		ifFalse: [FitlibraryInternals.ListTree title: (self htmlLink: aFilename)]</body><body package="FitLibrary">compareContentsOfFile: aFilename to: bFilename	| rs1 rs2 position |	rs1 := aFilename readStream binary.	rs2 := bFilename readStream binary.	position := 0.		[[rs1 atEnd or: [rs2 atEnd]] whileFalse: 			[rs1 next = rs2 next				ifFalse: 					[^self						error: ('Files differ at byte position &lt;1p&gt;' expandMacrosWith: position)						forFiles: aFilename						and: bFilename].			position := position + 1]]			ensure: 				[rs1 close.				rs2 close].	^self ok</body><body package="FitLibrary">compareDirectory: aFilename to: bFilename	aFilename isDirectory		ifFalse: 			[bFilename isDirectory				ifFalse: [^self filename: aFilename sameAs: bFilename]				ifTrue: [^self error: 'Must be a folder' forFile: aFilename]]		ifTrue: 			[bFilename isDirectory				ifFalse: [^self error: 'Must be a folder' forFile: bFilename]].	^self compareContentsOfDirectory: aFilename to: bFilename</body><body package="FitLibrary">compareFile: aFilename to: bFilename	| lengthDifference |	aFilename exists		ifFalse: [^self error: 'File doesn''t exist' forFile: aFilename].	bFilename exists		ifFalse: [^self error: 'File doesn''t exist' forFile: bFilename].	aFilename isReadable		ifFalse: [^self error: 'File may be locked' forFile: aFilename].	bFilename isReadable		ifFalse: [^self error: 'File may be locked' forFile: bFilename].	lengthDifference := bFilename fileSize - aFilename fileSize.	lengthDifference &gt; 0		ifTrue: 			[^self				error: ('File shorter by &lt;1p&gt; bytes than:'						expandMacrosWith: lengthDifference)				forFiles: aFilename				and: bFilename].	lengthDifference &lt; 0		ifTrue: 			[^self				error: ('File longer by &lt;1p&gt; bytes than:'						expandMacrosWith: lengthDifference negated)				forFiles: aFilename				and: bFilename].	^self compareContentsOfFile: aFilename to: bFilename</body><body package="FitLibrary">filename: aFilename sameAs: bFilename	aFilename isDirectory		ifTrue: 			[bFilename isDirectory				ifTrue: [^self compareDirectory: aFilename to: bFilename].			^self error: 'One is a folder' forFile: aFilename].	^self compareFile: aFilename to: bFilename</body><body package="FitLibrary">mappedFilesIn: aFilename	^Dictionary withAll: ((self visibleContentsOf: aFilename)				collect: [:each | each tail -&gt; each])</body><body package="FitLibrary">matchFile: aFilename to: aDictionary resultsInto: aCollection	| bFilename filesSame |	bFilename := aDictionary at: aFilename tail				ifAbsent: [^aCollection add: (self missing: aFilename)].	aDictionary removeKey: aFilename tail.	(aFilename isDirectory and: [bFilename isDirectory])		ifTrue: 			[^aCollection				add: (self compareContentsOfDirectory: aFilename to: bFilename)].	(aFilename isDirectory not and: [bFilename isDirectory not])		ifFalse: 			[^aCollection add: (self						error: 'Can''t compare a folder with a file'						forFiles: aFilename						and: bFilename)].	filesSame := self compareFile: aFilename to: bFilename.	aCollection add: (filesSame isError				ifTrue: [filesSame]				ifFalse: [FitlibraryInternals.ListTree title: (self htmlLink: aFilename)])</body><body package="FitLibrary">missing: aFilename	^self error: (aFilename isDirectory				ifTrue: ['Missing folder']				ifFalse: ['Missing'])		forFile: aFilename</body><body package="FitLibrary">sortedFilesIn: aFilename	^(self visibleContentsOf: aFilename)		asSortedCollection: [:a :b | a asString &lt; b asString]</body><body package="FitLibrary">surplus: aFilename	^self error: (aFilename isDirectory ifTrue: ['Surplus folder'] ifFalse: ['Surplus']) forFile: aFilename</body><body package="FitLibrary">visibleContentsOf: aFilename	^(aFilename directoryContents reject: [:each | each first = $.])		collect: [:each | aFilename construct: each]</body></methods><methods><class-id>Fitlibrary.Traverse.CompareFilesTraverse</class-id> <category>constants</category><body package="FitLibrary">ok	^FitlibraryInternals.ListTree title: 'OK'</body></methods><methods><class-id>Fitlibrary.Traverse.CompareFilesTraverse</class-id> <category>comparing</category><body package="FitLibrary">directory: aString sameAs: bString	^self folder: aString sameAs: bString</body><body package="FitLibrary">file: aString sameAs: bString	^self filename: (FitlibraryInternals.LocalFile named: aString) asFilename		sameAs: (FitlibraryInternals.LocalFile named: bString) asFilename</body><body package="FitLibrary">folder: aString sameAs: bString	^self compareDirectory: (FitlibraryInternals.LocalFile named: aString) asFilename		to: (FitlibraryInternals.LocalFile named: bString) asFilename</body></methods><methods><class-id>Fitlibrary.Traverse.CompareFilesTraverse</class-id> <category>errors</category><body package="FitLibrary">error: aString forFile: aFilename	^FitlibraryInternals.ListTreeError title: (self htmlLink: aFilename)		children: (OrderedCollection				with: (FitlibraryInternals.ListTree title: '&lt;i&gt;' , aString , '&lt;/i&gt;'))</body><body package="FitLibrary">error: aString forFiles: aFilename and: bFilename	^(self error: aString forFile: aFilename)		addChild: (FitlibraryInternals.ListTree title: (self htmlLink: bFilename));		yourself</body><body package="FitLibrary">htmlLink: aFilename	^(FitlibraryInternals.LocalFile filename: aFilename) htmlLink</body></methods><methods><class-id>Fitlibrary.FitLibraryFixture</class-id> <category>accessing</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	^traverse interpretAfterFirstRow: aTable resultsInto: aTestResults</body><body package="FitLibrary">runtimeContext	^self traverse runtimeContext</body><body package="FitLibrary">runtimeContext: aRuntimeContext	traverse runtimeContext: aRuntimeContext</body><body package="FitLibrary">scope	^self runtimeContext scope</body><body package="FitLibrary">systemUnderTest	^typedObjectUnderTest subject</body><body package="FitLibrary">systemUnderTest: anObject	typedObjectUnderTest := anObject asFitLibraryTypedObject</body><body package="FitLibrary">traverse	^traverse</body><body package="FitLibrary">typedSystemUnderTest	^typedObjectUnderTest</body></methods><methods><class-id>Fitlibrary.FitLibraryFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	typedObjectUnderTest := TypedObject null</body><body package="FitLibrary">setTraverse: aTraverse	traverse := aTraverse</body></methods><methods><class-id>Fitlibrary.FitLibraryFixture</class-id> <category>enumerating</category><body package="FitLibrary">doTable: aParse	self error: 'Please use FitLibraryServer instead of FitServer'</body></methods><methods><class-id>Fitlibrary.FitLibraryFixture</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	aDoFlowOnTable		runEvaluator: self		typedResult: anInnerTableContext typedSubject		onTable: anInnerTableContext table		fromRow: anInnerTableContext rowIndex		resultsInto: aTestResults.	^true</body></methods><methods><class-id>Fitlibrary.FitLibraryFixture</class-id> <category>dynamic variables</category><body package="FitLibrary">dynamicVariableAt: aString put: anObject	^self runtimeContext dynamicVariableAt: aString put: anObject</body><body package="FitLibrary">dynamicVariables	^self runtimeContext dynamicVariables</body><body package="FitLibrary">resolve: aString	^traverse resolve: aString</body></methods><methods><class-id>Fitlibrary.FitLibraryFixture</class-id> <category>parse delegates</category><body package="FitLibrary">registerParseDelegateClass: delegateClass forClass: aClass	ParseDelegation registerParseDelegateClass: delegateClass forClass: aClass</body><body package="FitLibrary">registerParseDelegateObject: anObject forClass: aClass	ParseDelegation registerParseDelegateObject: anObject forClass: aClass</body><body package="FitLibrary">registerSuperParseDelegate: anObject forClass: aClass	ParseDelegation registerSuperParseDelegate: anObject forClass: aClass</body></methods><methods><class-id>Fitlibrary.FunctionFixture</class-id> <category>initialize-release</category><body package="FitLibrary">exceptionString: aString	traverse exceptionString: aString</body><body package="FitLibrary">repeatString: aString	traverse repeatString: aString</body></methods><methods><class-id>Fitlibrary.FunctionFixture</class-id> <category>accessing</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	traverse interpretWithSetUp: aTable resultsInto: aTestResults</body></methods><methods><class-id>Fitlibrary.FunctionFixture class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject	^(self basicNew)		initialize;		systemUnderTest: anObject;		yourself</body></methods><methods><class-id>Fitlibrary.ConstraintFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (ConstraintTraverse systemUnderTest: self)</body><body package="FitLibrary">setExpected: aBoolean	traverse setExpected: aBoolean</body></methods><methods><class-id>Fitlibrary.ConstraintFixture class</class-id> <category>instance creation</category><body package="FitLibrary">expected: aBoolean	^(self basicNew)		initialize;		setExpected: aBoolean;		yourself</body><body package="FitLibrary">systemUnderTest: anObject expected: aBoolean	^(self systemUnderTest: anObject) setExpected: aBoolean</body></methods><methods><class-id>Fitlibrary.FunctionTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">exceptionString: aString	exceptionString := aString</body><body package="FitLibrary">repeatString: aString	repeatString := aString</body></methods><methods><class-id>Fitlibrary.FunctionTraverse</class-id> <category>running</category><body package="FitLibrary">interpretWithSetUp: aTable resultsInto: aTestResults	^[self interpretAfterFirstRow: aTable resultsInto: aTestResults] on: Error		do: 			[:ex |			aTable first error: ex resultsInto: aTestResults.			nil]</body></methods><methods><class-id>FitlibraryGeneric.GenericListSetUpTraverse</class-id> <category>private</category><body package="FitLibrary">bindFirstRow: firstRow toTargets: aRow forObject: anObject resultsInto: aTestResults	self systemUnderTest: anObject.	targets := Array new: firstRow size.	firstRow keysAndValuesDo: 			[:index :each |			(DomainObjectSetUpTraverse givesClass: each variableResolver: self)				ifFalse: 					[					[targets at: index						put: (PlugBoard lookupTarget findSetter: (each resolvedText: self)								onSutOf: self)]							on: Error							do: [:ex | (aRow at: index) error: ex resultsInto: aTestResults]]]</body><body package="FitLibrary">createElementFromRow: aRow firstRow: firstRow classColumn: anInteger resultsInto: aTestResults	| typeName findClass |	anInteger isZero ifTrue: [^componentClass fitLibraryCreateElement: self].	typeName := aRow resolvedTextAt: anInteger resolver: self.	findClass := (PlugBoard lookupTarget				findClassFromFactoryMethod: typeName				baseType: componentClass				evaluator: self)					ifNil: [^(NullFromClassFactoryMethod forClass: typeName) raise].	(findClass inheritsFrom: componentClass)		ifFalse: 			[^(NotSubclassFromClassFactoryMethod class: findClass				superclass: componentClass) raise].		[| sut |	sut := findClass fitLibraryCreateElement: self.	self		bindFirstRow: firstRow		toTargets: aRow		forObject: sut		resultsInto: aTestResults.	^sut]			on: Error			do: 				[:ex |				aRow first error: ex resultsInto: aTestResults.				IgnoredException raise]</body><body package="FitLibrary">findClassColumn: aRow	aRow keysAndValuesDo: 			[:index :each |			(DomainObjectSetUpTraverse givesClass: each variableResolver: self)				ifTrue: [^index]].	^0</body><body package="FitLibrary">processRow: aRow firstRow: firstRow classColumn: anInteger resultsInto: aTestResults	| element |	element := self				createElementFromRow: aRow				firstRow: firstRow				classColumn: anInteger				resultsInto: aTestResults.	self systemUnderTest: element.	list add: element.	aRow keysAndValuesDo: 			[:index :each |			(index = anInteger or: [(targets at: index) isNil])				ifFalse: 					[(targets at: index) subject: element.					[(targets at: index) invokeOnCell: each resultsInto: aTestResults]						on: Error						do: [:ex | each error: ex resultsInto: aTestResults]]]</body></methods><methods><class-id>FitlibraryGeneric.GenericListSetUpTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setComponentClass: aClass	componentClass := aClass.	list := OrderedCollection new</body></methods><methods><class-id>FitlibraryGeneric.GenericListSetUpTraverse</class-id> <category>accessing</category><body package="FitLibrary">results	^list</body></methods><methods><class-id>FitlibraryGeneric.GenericListSetUpTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| firstRow classColumn |		[	[firstRow := aTable first.	classColumn := self findClassColumn: firstRow.	classColumn isZero		ifTrue: 			[| element |			element := componentClass fitLibraryCreateElement: self.			self				bindFirstRow: firstRow				toTargets: firstRow				forObject: element				resultsInto: aTestResults].	(aTable from: 2) do: 			[:eachRow |			self				processRow: eachRow				firstRow: firstRow				classColumn: classColumn				resultsInto: aTestResults]]			on: IgnoredException			do: [:ex | ]]			on: Error			do: [:ex | aTable error: ex resultsInto: aTestResults].	^list</body></methods><methods><class-id>FitlibraryGeneric.GenericListSetUpTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">forClass: aClass	^self new setComponentClass: aClass</body></methods><methods><class-id>Fitlibrary.ArraySetUpTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setValueParser: aParser	valueParser := aParser</body></methods><methods><class-id>Fitlibrary.ArraySetUpTraverse</class-id> <category>accessing</category><body package="FitLibrary">results	^array</body></methods><methods><class-id>Fitlibrary.ArraySetUpTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	array := (aTable collect: 					[:each |										[each size = 1 ifFalse: [^(RowWrongWidthException expectedWidth: 1) raise].					valueParser parse: each first resultsInto: aTestResults]							on: Error							do: 								[:ex |								each error: ex resultsInto: aTestResults.								0]])				asArray.	^array</body></methods><methods><class-id>Fitlibrary.ArraySetUpTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">valueParser: aParser	^self new setValueParser: aParser</body></methods><methods><class-id>Fitlibrary.PrimitiveArrayFixture class</class-id> <category>instance creation</category><body package="FitLibrary">actuals: anArray componentType: aClass	^(self basicNew)		initialize;		setTraverse: (aClass fitLibraryIsPrimitive					ifTrue: [ArrayTraverse array: anArray componentType: aClass]					ifFalse: 						[ArrayTraverse array: (anArray collect: #fitToString) componentType: String])</body></methods><methods><class-id>Fitlibrary.GridFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (GridTraverse systemUnderTest: self)</body><body package="FitLibrary">setGrid: anArray elementType: aClass	traverse setGrid: anArray elementType: aClass</body></methods><methods><class-id>Fitlibrary.GridFixture class</class-id> <category>instance creation</category><body package="FitLibrary">grid: anArray elementType: aClass	^self new setGrid: anArray elementType: aClass</body></methods><methods><class-id>Fitlibrary.ImageFixture class</class-id> <category>instance creation</category><body package="FitLibrary">filenames: anArray	| grid |	grid := anArray collect: 					[:eachRow |					eachRow collect: [:eachCell | ImageNameGraphic expectedFilename: eachCell]].	^self grid: grid elementType: ImageNameGraphic</body></methods><methods><class-id>Fitlibrary.CollectionTraverse</class-id> <category>private-surplus</category><body package="FitLibrary">addSurplusRowsFor: aCollection in: aTable resultsInto: aTestResults	aCollection do: 			[:each |			| row |			row := aTable newRow.			self				buildSurplusRow: row				values: (self valuesFrom: each)				resultsInto: aTestResults.			row first actualElementMissing: aTestResults]</body><body package="FitLibrary">buildSurplusRow: aRow values: aCollection resultsInto: aTestResults	| cell |	aCollection isEmpty ifTrue: [^aRow addCell: 'null' spanningColumns: 0].	aCollection do: 			[:each |			cell := aRow addCellWithString: '&amp;nbsp;'.			each				ifNil: [cell ignore: aTestResults]				ifNotNil: 					[(each isKindOf: Error)						ifTrue: [cell error: each resultsInto: aTestResults]						ifFalse: [cell unvisitedEscapedText: each fitToString]]]</body><body package="FitLibrary">showSurplus: aCollection in: aTable resultsInto: aTestResults	aCollection isEmpty ifTrue: [^self].	self addSurplusRowsFor: aCollection in: aTable resultsInto: aTestResults</body><body package="FitLibrary">valuesFrom: aCollection	^aCollection		collect: [:each | each ifNotNil: [[each result] on: Error do: [:ex | ex]]]</body></methods><methods><class-id>Fitlibrary.CollectionTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| firstRow getters |	actuals		ifNil: [^FitLibraryException raiseErrorString: 'Actual list missing'].	firstRow := aTable at: 2.	getters := OrderedCollection new.		[	[actuals isEmpty		ifTrue: [(aTable existsAt: 3) ifFalse: [firstRow pass: aTestResults]]		ifFalse: 			[getters := (self bindGettersForAllActualsIn: firstRow						resultsInto: aTestResults) asOrderedCollection].	(aTable from: 3) do: 			[:each |			firstRow := each.			self interpretRow: each getters: getters resultsInto: aTestResults].	showSurplus		ifTrue: [self showSurplus: getters in: aTable resultsInto: aTestResults]]			on: IgnoredException			do: [:ex | ]]			on: Error			do: [:ex | firstRow error: ex resultsInto: aTestResults].	^actuals</body><body package="FitLibrary">interpretRow: aRow getters: aCollection resultsInto: aTestResults	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.CollectionTraverse</class-id> <category>private-binding</category><body package="FitLibrary">bindGettersForAllActualsIn: aRow resultsInto: aTestResults	| bindings |	usedFields := Array new: aRow size withAll: false.	bindings := actuals collect: 					[:each |					self bindGettersForOneElementIn: aRow actual: each asFitLibraryTypedObject].	usedFields keysAndValuesDo: 			[:index :isUsed |			isUsed				ifFalse: 					[| propertyName classNames |					propertyName := runtimeContext								extendedCamel: ((aRow at: index) resolvedText: self).					classNames := self elementClassNames: actuals.					(aRow at: index)						error: (NoSuchPropertyException name: propertyName classNames: classNames)						resultsInto: aTestResults.					IgnoredException raise]].	^bindings</body><body package="FitLibrary">bindGettersForOneElementIn: aRow actual: aTypedObject	| columnBindings |	columnBindings := Array new: aRow size.	aRow keysAndValuesDo: 			[:index :each |			(componentType notNil				and: [DomainObjectSetUpTraverse givesClass: each variableResolver: self])					ifTrue: 						[columnBindings at: index							put: (ClassMethodTarget									forClass: componentType									evaluator: self									actual: aTypedObject).						usedFields at: index put: true]					ifFalse: 						[(self bindPropertyGetterNamed: (each resolvedText: self)							forTypedObject: aTypedObject)								ifNotNil: 									[:binding |									usedFields at: index put: true.									columnBindings at: index put: binding]]].	^columnBindings</body><body package="FitLibrary">bindPropertyGetterNamed: aString forTypedObject: aTypedObject	| methodSpec mappedName subject value |	subject := aTypedObject subject.	mappedName := runtimeContext extendedCamel: aString.	(subject isKindOf: Dictionary)		ifTrue: 			[value := subject at: mappedName						ifAbsent: [subject at: aString ifAbsent: [^nil]].			^ConstantMethodTarget value: value evaluator: self].	methodSpec := MethodSpec				baseName: aString				numArgs: 0				runtimeContext: self runtimeContext.	^methodSpec findIn: subject evaluator: self</body></methods><methods><class-id>Fitlibrary.CollectionTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">componentType: aClass	componentType := aClass</body><body package="FitLibrary">setActuals: aCollection	showSurplus := true.	aCollection fitLibraryActualsInto: self</body><body package="FitLibrary">setCollectionActuals: aCollection	actuals := aCollection</body><body package="FitLibrary">setDictionaryActuals: aDictionary	self setCollectionActuals: (self mapDictionaryToSet: aDictionary)</body><body package="FitLibrary">showSurplus: aBoolean	showSurplus := aBoolean</body></methods><methods><class-id>Fitlibrary.CollectionTraverse</class-id> <category>private-utility</category><body package="FitLibrary">elementClassNames: aCollection	| names ws |	(aCollection anySatisfy: #isNil)		ifTrue: 			[^FitLibraryException				raiseErrorString: 'An element of the collection is null'].	names := OrderedSet				withAll: (aCollection collect: [:each | each class name]).	ws := String new writeStream.	names do: [:each | ws nextPutAll: each] separatedBy: [ws nextPutAll: ', '].	^ws contents</body><body package="FitLibrary">mapDictionaryToSet: aDictionary	| result |	result := OrderedCollection new.	aDictionary		keysAndValuesDo: [:key :value | result add: (MapElement key: key value: value)].	^result</body></methods><methods><class-id>Fitlibrary.CollectionTraverse</class-id> <category>private-matching</category><body package="FitLibrary">matchRow: aRow bindings: aCollection resultsInto: aTestResults	| matchedAlready |	matchedAlready := false.	aCollection keysAndValuesDo: 			[:index :each |			| expectedCell |			expectedCell := aRow at: index.			each				ifNil: [expectedCell passOrFailIfBlank: aTestResults variableResolver: self]				ifNotNil: 					[| matched |					matched := each								invokeAndCheckCell: expectedCell								matchedAlready: matchedAlready								resultsInto: aTestResults.					(matchedAlready or: [matched]) ifFalse: [^false].					matchedAlready := true]].	^true</body></methods><methods><class-id>Fitlibrary.CollectionTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject actuals: aCollection	^(self systemUnderTest: anObject)		setActuals: aCollection;		yourself</body></methods><methods><class-id>Fitlibrary.DomainObjectSetUpTraverse</class-id> <category>private</category><body package="FitLibrary">callSetter: aMethodTarget onCell: aCell resultsInto: aTestResults		[[aMethodTarget invokeOnCell: aCell resultsInto: aTestResults]		on: IgnoredException		do: [:ex | ]]			on: Error			do: [:ex | aCell error: ex resultsInto: aTestResults]</body><body package="FitLibrary">createObjectOfSpecifiedType: aTable resultsInto: aTestResults	(aTable from: 2) do: 			[:each |			1 to: each size				by: 2				do: 					[:index |					(self class givesClass: (each at: index) variableResolver: self)						ifTrue: 							[^self createSystemUnderTest: (each at: index + 1) resultsInto: aTestResults]]].	self systemUnderTest ifNil: [^(NoNullaryConstructor forClass: type) raise]</body><body package="FitLibrary">createSystemUnderTest: aCell resultsInto: aTestResults	| typeName sutClass newInstance |		[	[typeName := aCell resolvedText: self.	sutClass := (PlugBoard lookupTarget				findClassFromFactoryMethod: typeName				baseType: type				evaluator: self)					ifNil: [^(NullFromClassFactoryMethod forClass: typeName) raise].	(sutClass inheritsFrom: type)		ifFalse: 			[^(NotSubclassFromClassFactoryMethod class: sutClass superclass: type)				raise].	newInstance := sutClass fitLibraryCreateElement: self.	self systemUnderTest: newInstance]			on: Fit.Exceptions.ShouldNotImplement			do: 				[:ex |				aCell error: (NoNullaryConstructor className: sutClass name)					resultsInto: aTestResults]]			on: Error			do: [:ex | aCell error: ex resultsInto: aTestResults]</body><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	aRow withResults: aTestResults		pairsDo: 			[:cell :nextCell |			(self class givesClass: cell variableResolver: self)				ifFalse: 					[self systemUnderTest						ifNil: [cell ignore: aTestResults]						ifNotNil: 							[							[| target |							target := PlugBoard lookupTarget findSetter: (cell resolvedText: self)										onSutOf: self.							self callSetter: target onCell: nextCell resultsInto: aTestResults]									on: Error									do: [:ex | cell error: ex resultsInto: aTestResults]]]]</body></methods><methods><class-id>Fitlibrary.DomainObjectSetUpTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	type		ifNotNil: [self createObjectOfSpecifiedType: aTable resultsInto: aTestResults].	(aTable from: 2)		do: [:each | self processRow: each resultsInto: aTestResults].	^self systemUnderTest</body></methods><methods><class-id>Fitlibrary.DomainObjectSetUpTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setType: aClass	type := aClass</body></methods><methods><class-id>Fitlibrary.DomainObjectSetUpTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject type: aTypeAdapter	^(self systemUnderTest: anObject) setType: aTypeAdapter type</body></methods><methods><class-id>Fitlibrary.DomainObjectSetUpTraverse class</class-id> <category>utility</category><body package="FitLibrary">givesClass: aCell variableResolver: aVariableResolver	^(aCell isBlank: aVariableResolver)		and: [(aCell hasEmbeddedTables: aVariableResolver) not]</body></methods><methods><class-id>Fitlibrary.CalculateTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	methods := 0.	self bindFirstRowToTarget: (aTable at: 2) resultsInto: aTestResults.	(aTable from: 3)		do: [:each | self processRow: each resultsInto: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.CalculateTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	methods := 0.	notesPermitted := false.	hasNotes := false.	argCount := -1.	boundOK := false</body></methods><methods><class-id>Fitlibrary.CalculateTraverse</class-id> <category>private</category><body package="FitLibrary">bindFirstRowToTarget: aRow resultsInto: aTestResults	| pastDoubleColumn rowLength arguments |	pastDoubleColumn := false.	rowLength := aRow size.	arguments := OrderedCollection new.	aRow keysAndValuesDo: 			[:index :eachCell |			| name |			hasNotes				ifFalse: 					[name := eachCell resolvedText: self.										[name isEmpty						ifTrue: 							[(pastDoubleColumn and: [notesPermitted])								ifTrue: [hasNotes := true]								ifFalse: 									[argCount := index - 1.									targets := Array new: rowLength - index.									pastDoubleColumn := true]]						ifFalse: 							[notesPermitted := true.							pastDoubleColumn								ifFalse: [arguments add: name]								ifTrue: 									[| target methodSpec |									arguments size &gt; argCount ifTrue: [arguments removeLast].									methodSpec := MethodSpec numArgs: argCount runtimeContext: runtimeContext.									methodSpec										addSegment: name;										addAllSegments: arguments;										mergeFront.									target := PlugBoard lookupTarget findMethodOrGetter: methodSpec												evaluator: self.									target returnsVoid										ifTrue: 											[(VoidMethodException selector: methodSpec canonicalSelector												page: 'CalculateTraverse') raise].									methods := methods + 1.									targets at: methods put: target.									target repeatString: repeatString exceptionString: exceptionString]]]							on: Error							do: [:ex | ^eachCell error: ex resultsInto: aTestResults]]].	methods isZero		ifTrue: 			[aRow				error: (FitLibraryExceptionWithHelp messageText: 'No calculated column'						page: 'NoCalculateColumn')				resultsInto: aTestResults].	boundOK := true</body><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	| expectedCellCount |	boundOK ifFalse: [^aRow ignore: aTestResults].	expectedCellCount := argCount + methods + 1.	hasNotes		ifTrue: 			[aRow size &lt; expectedCellCount				ifTrue: 					[^aRow error: (FitLibraryExceptionWithHelp								messageText: ('Row should be at least &lt;1p&gt; cells wide'										expandMacrosWith: expectedCellCount)								page: 'CalculateRowTooShort')						resultsInto: aTestResults]]		ifFalse: 			[aRow size = expectedCellCount				ifFalse: 					[^aRow error: (FitLibraryExceptionWithHelp								messageText: ('Row should be &lt;1p&gt; cells wide'										expandMacrosWith: expectedCellCount)								page: 'CalculateRowWrongLength')						resultsInto: aTestResults]].	1 to: methods		do: 			[:i |			(targets at: i)				invokeAndCheckRow: aRow				expectedCell: (aRow at: (argCount + i) + 1)				handleSubtype: true				resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.Show</class-id> <category>accessing</category><body package="FitLibrary">htmlString	^htmlString</body></methods><methods><class-id>Fitlibrary.Show</class-id> <category>initialize-release</category><body package="FitLibrary">setHtmlString: aString	htmlString := aString</body></methods><methods><class-id>Fitlibrary.Show class</class-id> <category>instance creation</category><body package="FitLibrary">htmlString: aString	^self new setHtmlString: aString</body></methods><methods><class-id>FitlibraryGeneric.NestingSetTraverse</class-id> <category>private</category><body package="FitLibrary">matchActual: aCell parser: aParser actuals: aCollection tableSize: anInteger resultsInto: aTestResults	(anInteger = 1 and: [aCollection size = 1])		ifTrue: 			[^aParser				expectedCell: aCell				matches: aCollection removeFirst				resultsInto: aTestResults].	aCollection keysAndValuesDo: 			[:index :each |			(aParser				expectedCell: aCell deepCopy				matches: each				resultsInto: aTestResults)					ifTrue: 						[^aParser							expectedCell: aCell							matches: (aCollection removeAtIndex: index)							resultsInto: aTestResults]].	aCell expectedElementMissing: aTestResults</body></methods><methods><class-id>FitlibraryGeneric.NestingSetTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setSet: aSet type: aTypeAdapter	set := aSet.	typeAdapter := aTypeAdapter</body></methods><methods><class-id>FitlibraryGeneric.NestingSetTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| parser actuals |	parser := typeAdapter parameterParser: self.	actuals := OrderedCollection withAll: set.	aTable keysAndValuesDo: 			[:index :eachRow |						[eachRow size = 1				ifFalse: [^(RowWrongWidthException expectedWidth: 1) raise].			self				matchActual: eachRow first				parser: parser				actuals: actuals				tableSize: aTable size				resultsInto: aTestResults]					on: Error					do: [:ex | eachRow error: ex resultsInto: aTestResults]].	actuals do: 			[:each |			| row cell |			row := aTable newRow.			cell := row addCell.			[cell actualElementMissing: (parser show: each) resultsInto: aTestResults]				on: Error				do: [:ex | cell error: ex resultsInto: aTestResults]].	^set</body></methods><methods><class-id>FitlibraryGeneric.NestingSetTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">set: aSet type: aTypeAdapter	^self new setSet: aSet type: aTypeAdapter</body></methods><methods><class-id>Fitlibrary.DomainCheckTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	aTable error: (Error new errorString: 'Don''t expect to have this called')		resultsInto: aTestResults.	^nil</body><body package="FitLibrary">runTable: aTable resultsInto: aTestResults		[aTable do: 			[:each |			(each resolvedTextAt: 1 resolver: self) = 'comment' ifTrue: [^self].			self processRow: each resultsInto: aTestResults]]			on: Error			do: [:ex | aTable error: ex resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.DomainCheckTraverse</class-id> <category>private</category><body package="FitLibrary">checkCell: aCell class: classCell resultsInto: aTestResults	| typeName sutClass |	typeName := classCell resolvedText: self.		[sutClass := PlugBoard lookupTarget				findClassFromFactoryMethod: typeName				baseType: self typedSystemUnderTest classType				evaluator: self.	classCell passOrFail: self systemUnderTest class == sutClass		resultsInto: aTestResults]			on: Error			do: [:ex | aCell error: ex resultsInto: aTestResults]</body><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	aRow withResults: aTestResults		pairsDo: 			[:cell :nextCell |			(DomainObjectSetUpTraverse givesClass: cell variableResolver: self)				ifTrue: 					[self systemUnderTest ifNil: [^NoSystemUnderTestException raise].					self checkCell: cell class: nextCell resultsInto: aTestResults]				ifFalse: 					[					[| target |					target := PlugBoard lookupTarget findGetter: (cell resolvedText: self)								onSutOf: self.					target						invokeAndCheckRow: Row new						expectedCell: nextCell						handleSubtype: false						resultsInto: aTestResults]							on: MissingMethodException							do: [:ex | cell error: ex resultsInto: aTestResults]]]</body></methods><methods><class-id>Fitlibrary.CollectionSetUpTraverse</class-id> <category>running</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	aDoFlowOnTable		runEvaluator: self		typedResult: anInnerTableContext typedSubject		onTable: anInnerTableContext table		fromRow: anInnerTableContext rowIndex		resultsInto: aTestResults.	^true</body><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	self		bindFirstRowToTarget: (aTable at: 2)		evaluator: self		resultsInto: aTestResults.	(aTable from: 3)		do: [:each | self processRow: each resultsInto: aTestResults].	^collection</body><body package="FitLibrary">interpretInFlow: aTable resultsInto: aTestResults	[self interpretAfterFirstRow: aTable resultsInto: aTestResults] on: Error		do: 			[:ex |			| rowNumber |			rowNumber := embedded ifTrue: [2] ifFalse: [1].			(aTable at: rowNumber) error: ex resultsInto: aTestResults].	^collection</body></methods><methods><class-id>Fitlibrary.CollectionSetUpTraverse</class-id> <category>private</category><body package="FitLibrary">bindFirstRowToTarget: aRow evaluator: anEvaluator resultsInto: aTestResults		[argCount := aRow size.	target := self				findMethodTargetFrom: aRow				embedded: embedded				evaluator: anEvaluator.	boundOK := true]			on: Error			do: [:ex | aRow error: ex resultsInto: aTestResults]</body><body package="FitLibrary">findMethodTargetFrom: aRow embedded: aBoolean evaluator: anEvaluator	^self class		findMethodTargetFrom: aRow		embedded: aBoolean		evaluator: anEvaluator</body><body package="FitLibrary">invokeMethodOn: aRow resultsInto: aTestResults	| result |	result := target invokeOnRow: aRow resultsInto: aTestResults.	collection add: result.	^result</body><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	boundOK ifFalse: [^aRow ignore: aTestResults].	aRow size = argCount		ifFalse: 			[^aRow error: (RowWrongWidthException expectedWidth: argCount)				resultsInto: aTestResults].	[self invokeMethodOn: aRow resultsInto: aTestResults] on: Error		do: [:ex | aRow error: ex resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.CollectionSetUpTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	argCount := -1.	boundOK := false.	collection := OrderedCollection new.	embedded := false</body><body package="FitLibrary">setCollection: aCollection embedded: aBoolean	collection := aCollection.	embedded := aBoolean</body></methods><methods><class-id>Fitlibrary.CollectionSetUpTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">collection: aCollection	^self new setCollection: aCollection embedded: false</body><body package="FitLibrary">systemUnderTest: anObject collection: aCollection embedded: aBoolean	^(self systemUnderTest: anObject) setCollection: aCollection		embedded: aBoolean</body></methods><methods><class-id>Fitlibrary.CollectionSetUpTraverse class</class-id> <category>private</category><body package="FitLibrary">buildMethodSpecFrom: aRow evaluator: anEvaluator	| methodSpec |	methodSpec := MethodSpec numArgs: aRow size				runtimeContext: anEvaluator runtimeContext.	aRow do: [:each | methodSpec addSegment: (each resolvedText: anEvaluator)].	^methodSpec</body><body package="FitLibrary">findMethodTargetFrom: aRow embedded: aBoolean evaluator: anEvaluator	| methodSpec method |	methodSpec := self buildMethodSpecFrom: aRow evaluator: anEvaluator.	method := PlugBoard lookupTarget findMethod: methodSpec				evaluator: anEvaluator.	(aBoolean and: [method returnsVoid])		ifTrue: 			[^VoidMethodException selector: method selector asString				page: 'SetUpTraverse'].	^method</body></methods><methods><class-id>Fitlibrary.CollectionSetUpTraverse class</class-id> <category>testing</category><body package="FitLibrary">hasObjectFactoryMethodFor: aTable evaluator: anEvaluator		[self		findMethodTargetFrom: aTable first		embedded: false		evaluator: anEvaluator.	^true]			on: Error			do: [:ex | ^false]</body></methods><methods><class-id>Fitlibrary.ExplicitSelf</class-id> <category>accessing</category><body package="FitLibrary">actualSelf	^actualSelf</body></methods><methods><class-id>Fitlibrary.ExplicitSelf</class-id> <category>initialize-release</category><body package="FitLibrary">setActualSelf: anObject	actualSelf := anObject</body></methods><methods><class-id>Fitlibrary.ExplicitSelf class</class-id> <category>instance creation</category><body package="FitLibrary">for: anObject	^self new setActualSelf: anObject</body></methods><methods><class-id>Fitlibrary.SetVariableTraverse</class-id> <category>private</category><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	aRow size = 2		ifFalse: 			[^aRow first error: (RowWrongWidthException expectedWidth: 2)				resultsInto: aTestResults].	self dynamicVariableAt: (aRow resolvedTextAt: 1 resolver: self)		put: (aRow resolvedTextAt: 2 resolver: self)</body></methods><methods><class-id>Fitlibrary.SetVariableTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults		[(aTable from: 2)		do: [:each | self processRow: each resultsInto: aTestResults]]			on: Error			do: [:ex | aTable error: ex resultsInto: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.MapTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setKeyType: keyTypeAdapter valueType: valueTypeAdapter runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext.	keyParser := keyTypeAdapter parameterParser: self.	valueParser := valueTypeAdapter parameterParser: self</body><body package="FitLibrary">setMap: aDictionary	map := aDictionary</body></methods><methods><class-id>Fitlibrary.MapTraverse</class-id> <category>private</category><body package="FitLibrary">addSurplusRows: aDictionary to: aTable resultsInto: aTestResults	aDictionary keysAndValuesDo: 			[:key :value |			| row |			row := aTable newRow.						[row				addCellWithString: (keyParser show: key);				addCellWithString: (valueParser show: value).			row first actualElementMissing: aTestResults]					on: Error					do: 						[:ex |						row isEmpty							ifTrue: [aTable error: ex resultsInto: aTestResults]							ifFalse: [row error: ex resultsInto: aTestResults]]]</body><body package="FitLibrary">determineTypes	| someKey |	keyParser ifNotNil: [^self].	someKey := map keys any.	keyParser := self parserFor: someKey.	valueParser := self parserFor: (map at: someKey)</body><body package="FitLibrary">interpretRow: aRow map: aDictionary keyParser: aParser resultsInto: aTestResults		[| key |	aRow size &gt; 2		ifTrue: [^(ExtraCellsException details: 'MapTraverse') raise].	key := aParser parse: aRow first resultsInto: aTestResults.	(aDictionary at: key ifAbsent: [nil])		ifNil: [aRow first expectedElementMissing: aTestResults]		ifNotNil: 			[:value |			| parser |			parser := self parserFor: value.			(parser				expectedCell: (aRow at: 2)				matches: value				resultsInto: aTestResults)					ifTrue: [aRow pass: aTestResults]					ifFalse: 						[(aRow at: 2)							fail: aTestResults							withMessage: (parser show: value)							variableResolver: self].			aDictionary removeKey: key]]			on: Error			do: [:ex | aRow error: ex resultsInto: aTestResults]</body><body package="FitLibrary">parserFor: anObject	^(TypeAdapter adapterFor: anObject class) parameterParser: self</body></methods><methods><class-id>Fitlibrary.MapTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	map isEmpty		ifTrue: 			[aTable size = 1				ifTrue: [aTable pass: aTestResults]				ifFalse: [(aTable from: 2) do: [:each | each missing: aTestResults]]]		ifFalse: 			[| copiedMap |			self determineTypes.			copiedMap := map copy.			(aTable from: 2) do: 					[:each |					self						interpretRow: each						map: copiedMap						keyParser: keyParser						resultsInto: aTestResults].			self addSurplusRows: copiedMap to: aTable resultsInto: aTestResults].	^map</body></methods><methods><class-id>Fitlibrary.MapTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">map: aDictionary	^self new setMap: aDictionary</body><body package="FitLibrary">map: aDictionary keyType: keyTypeAdapter valueType: valueTypeAdapter runtimeContext: aRuntimeContext	^(self map: aDictionary)		setKeyType: keyTypeAdapter		valueType: valueTypeAdapter		runtimeContext: aRuntimeContext</body></methods><methods><class-id>Fitlibrary.SubsetMapTraverse</class-id> <category>private</category><body package="FitLibrary">addSurplusRows: aDictionary to: aTable resultsInto: aTestResults	"Do nothing with surplus rows"</body></methods><methods><class-id>Fitlibrary.CompareFilesFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	traverse := CompareFilesTraverse systemUnderTest: self</body></methods><methods><class-id>Fitlibrary.CompareFilesFixture class</class-id> <category>instance creation</category><body package="FitLibrary">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.DoFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (DoTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.DoFixture</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	self class == DoFixture		ifTrue: 			[aDoFlowOnTable				handleActualDoFixture: self				row: anInnerTableContext row				resultsInto: aTestResults]		ifFalse: 			[aDoFlowOnTable				pushOnScope: anInnerTableContext typedSubject				row: anInnerTableContext row				resultsInto: aTestResults].	^false</body></methods><methods><class-id>Fitlibrary.DoFixture</class-id> <category>special actions</category><body package="FitLibrary">abandon	traverse abandonStorytest</body><body package="FitLibrary">getSymbolNamed: aString	^self class symbolAt: aString</body><body package="FitLibrary">logText: aString	traverse logText: aString</body><body package="FitLibrary">setExpandDefinedActions: aBoolean	traverse setExpandDefinedActions: aBoolean</body><body package="FitLibrary">setStopOnError: aBoolean	traverse setStopOnError: aBoolean</body><body package="FitLibrary">show: aString	traverse show: aString</body><body package="FitLibrary">showAfterTable: aString	traverse showAfterTable: aString</body><body package="FitLibrary">showAsAfterTableTitle: titleString contents: contentsString	traverse showAsAfterTableTitle: titleString contents: contentsString</body></methods><methods><class-id>Fitlibrary.DoFixture</class-id> <category>private</category><body package="FitLibrary">interpretTables: aparse	^self error: 'Please use FitLibraryServer instead of FitServer.'</body></methods><methods><class-id>Fitlibrary.DoFixture</class-id> <category>running</category><body package="FitLibrary">interpretInFlow: aTable resultsInto: aTestResults	^traverse interpretInFlow: aTable resultsInto: aTestResults</body></methods><methods><class-id>Fitlibrary.DoFixture class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject	^(self basicNew)		initialize;		systemUnderTest: anObject;		yourself</body></methods><methods><class-id>Fitlibrary.DoFixture class</class-id> <category>accessing</category><body package="FitLibrary">methodsThatAreVisible	^DoTraverse methodsThatAreVisible</body></methods><methods><class-id>Fitlibrary.SetUpFixture</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	aDoFlowOnTable		runEvaluator: self		typedResult: anInnerTableContext typedSubject		onTable: anInnerTableContext table		fromRow: anInnerTableContext rowIndex		resultsInto: aTestResults.	^true</body></methods><methods><class-id>Fitlibrary.SetUpFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (CollectionSetUpTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.CommentFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: CommentTraverse new</body><body package="FitLibrary">setMarkAsIgnored: aBoolean	traverse markAsIgnored: aBoolean</body></methods><methods><class-id>Fitlibrary.CommentFixture class</class-id> <category>instance creation</category><body package="FitLibrary">markAsIgnored: aBoolean	^self new setMarkAsIgnored: aBoolean</body></methods><methods><class-id>Fitlibrary.ListOfMapsTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setMaps: anOrderedCollection	maps := anOrderedCollection</body></methods><methods><class-id>Fitlibrary.ListOfMapsTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| labelRow |	labelRow := aTable second.	(aTable from: 3) keysAndValuesDo: 			[:index :each |						[each size = labelRow size				ifFalse: 					[each error: (RowWrongWidthException expectedWidth: labelRow size)						resultsInto: aTestResults.					^nil].			index &gt; maps size ifTrue: [^FitLibraryException raiseErrorString: 'Extra'].			self				processRow: each				labelRow: labelRow				map: (maps at: index)				resultsInto: aTestResults]					on: Error					do: [:ex | each error: ex resultsInto: aTestResults]].	^nil</body><body package="FitLibrary">processRow: aRow labelRow: labelRow map: aDictionary resultsInto: aTestResults	labelRow with: aRow		do: 			[:labelCell :eachCell |						[| key value |			key := labelCell resolvedText: self.			value := aDictionary at: key ifAbsent: [nil].			value				ifNil: [eachCell passOrFailIfBlank: aTestResults variableResolver: self]				ifNotNil: 					[| parser actual |					parser := (TypeAdapter adapterFor: value class) parameterParser: self.					actual := parser parse: eachCell resultsInto: aTestResults.					(parser expectedCell: eachCell matches: value resultsInto: aTestResults)						ifTrue: [eachCell pass: aTestResults]						ifFalse: 							[eachCell								fail: aTestResults								withMessage: (parser show: actual)								variableResolver: self]]]					on: Error					do: [:ex | eachCell error: ex resultsInto: aTestResults]]</body></methods><methods><class-id>Fitlibrary.ListOfMapsTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">maps: anOrderedCollection	^self new setMaps: anOrderedCollection</body></methods><methods><class-id>Fitlibrary.DefaultPackages</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	(aTable from: 2) do: 			[:each |			CreateFromClassNameCaller				addDefaultPackage: (each resolvedTextAt: 1 resolver: self)]</body></methods><methods><class-id>Fitlibrary.CollectionFixture</class-id> <category>initialize-release</category><body package="FitLibrary">actualCollection: aCollection	^traverse setActuals: aCollection</body><body package="FitLibrary">actuals: aCollection	traverse setActuals: aCollection</body><body package="FitLibrary">setTraverse: aListTraverse	super setTraverse: aListTraverse.	aListTraverse systemUnderTest: self</body></methods><methods><class-id>Fitlibrary.CollectionFixture class</class-id> <category>instance creation</category><body package="FitLibrary">traverse: aListTraverse	^(self basicNew)		initialize;		setTraverse: aListTraverse;		yourself</body></methods><methods><class-id>Fitlibrary.ArrayFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: ListTraverse new</body></methods><methods><class-id>Fitlibrary.ArrayFixture class</class-id> <category>instance creation</category><body package="FitLibrary">actuals: aCollection	^self traverse: (ListTraverse systemUnderTest: nil actuals: aCollection)</body></methods><methods><class-id>Fitlibrary.DomainObjectSetUpFixture</class-id> <category>initialize-release</category><body package="FitLibrary">setSystemUnderTest: anObject	self systemUnderTest: anObject.	self setTraverse: (DomainObjectSetUpTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.DomainObjectSetUpFixture class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject	^self new setSystemUnderTest: anObject</body></methods><methods><class-id>Fitlibrary.OnError</class-id> <category>accessing</category><body package="FitLibrary">runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext</body><body package="FitLibrary">stopOnFailures: failureInteger errors: errorInteger	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.MultiDefinedActionRunnerTraverse</class-id> <category>private</category><body package="FitLibrary">colourRowInReport: aRow subResults: subTestResults resultsInto: aTestResults	(runtimeContext isAbandoned: aTestResults)		ifTrue: [^aRow ignore: aTestResults].	(runtimeContext shouldExpandDefinedActions		or: [subTestResults hasProblems])			ifTrue: 				[subTestResults hasPassed					ifTrue: [aRow passKeywords: aTestResults]					ifFalse: 						[subTestResults hasErrors							ifTrue: 								[aRow do: 										[:each |										each error: (FitLibraryException messageText: ' ')											resultsInto: aTestResults]]							ifFalse: 								[subTestResults hasFailed									ifTrue: [aRow do: [:each | each fail: aTestResults]]									ifFalse: [aRow do: [:each | each pass: aTestResults]]]]]			ifFalse: [aRow pass: aTestResults]</body><body package="FitLibrary">runBody: aTables resultsInto: aTestResults	runtimeContext tableEvaluator runInnerTables: aTables		resultsInto: aTestResults</body><body package="FitLibrary">runRow: callRow parameters: parameterRow resultsInto: aTestResults	| body subTestResults callManager |	body := binder copyOfBody.	subTestResults := TestResults new.	callManager := runtimeContext definedActionCallManager.		[callManager startCall: binder.	binder		bindMultiParameters: parameterRow		call: callRow		into: self dynamicVariables.	self runBody: body resultsInto: subTestResults.	self		colourRowInReport: callRow		subResults: subTestResults		resultsInto: aTestResults]			ensure: [callManager endCall: binder].	(runtimeContext shouldExpandDefinedActions or: 			[subTestResults hasProblems or: [runtimeContext isAbandoned: aTestResults]])		ifTrue: 			[| cell |			cell := Cell withTables: body.			cell first				leader: (Markup label: (DefinedActionCaller link: binder pageName)).			cell calls.			callRow add: cell]		ifFalse: 			[callManager readyToShow				ifTrue: 					[callRow add: (Cell withTables: (Tables withTable: callManager showsTable))]]</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.MultiDefinedActionRunnerTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setBinder: aParameterBinder	binder := aParameterBinder</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.MultiDefinedActionRunnerTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| parameterRow |		[aTable size &lt; 3		ifTrue: [^FitLibraryException raiseErrorString: 'Missing data rows in table'].	self runtimeContext pushLocalDynamicVariables.	parameterRow := aTable at: 2.	binder verifyHeader: parameterRow againstFormalParamtersUsingResolver: self.	parameterRow pass: aTestResults.	(aTable from: 3) do: 			[:each |			(runtimeContext isAbandoned: aTestResults)				ifTrue: [each ignore: aTestResults]				ifFalse: 					[[self runRow: each parameters: parameterRow resultsInto: aTestResults]						on: Error						do: [:ex | each error: ex resultsInto: aTestResults]]].	self runtimeContext popLocalDynamicVariables]			on: Error			do: [:ex | aTable error: ex resultsInto: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.MultiDefinedActionRunnerTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">binder: aParameterBinder runtimeContext: aRuntimeContext	^(self new setBinder: aParameterBinder)		runtimeContext: aRuntimeContext;		yourself</body></methods><methods><class-id>Fitlibrary.CalculateFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (CalculateTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.PropertyEditor</class-id> <category>accessing</category><body package="FitLibrary">getAsText	^self subclassResponsibility</body><body package="FitLibrary">setAsText: aString	^self subclassResponsibility</body><body package="FitLibrary">value	^value</body><body package="FitLibrary">value: anObject	value := anObject</body></methods><methods><class-id>Fitlibrary.PropertyEditor class</class-id> <category>instance creation</category><body package="FitLibrary">forClass: aClass	| class |	class := self allSubclasses detect: [:each | each isForClass: aClass]				ifNone: [^nil].	^class new</body></methods><methods><class-id>Fitlibrary.PropertyEditor class</class-id> <category>testing</category><body package="FitLibrary">isForClass: aClass	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.ArrayTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setArray: anArray componentType: aTypeAdapter	array := anArray.	componentType := aTypeAdapter</body><body package="FitLibrary">setArray: anArray parser: aParser	array := anArray.	parser := aParser</body></methods><methods><class-id>Fitlibrary.ArrayTraverse</class-id> <category>private</category><body package="FitLibrary">checkRow: aRow expected: anObject resultsInto: aTestResults	| matches |	matches := 			[aRow size = 1 ifFalse: [(RowWrongWidthException expectedWidth: 1) raise].			parser				expectedCell: aRow first				matches: anObject				resultsInto: aTestResults]					on: Error					do: 						[:ex |						aRow error: ex resultsInto: aTestResults.						^false].	matches		ifTrue: [aRow pass: aTestResults]		ifFalse: [aRow first expectedElementMissing: aTestResults].	^matches</body><body package="FitLibrary">missingActualElement: element inCell: cell resultsInto: aTestResults	^[cell actualElementMissing: (parser show: element) resultsInto: aTestResults]		on: Error		do: [:ex | cell error: ex resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.ArrayTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| rowIndex arrayIndex |	componentType ifNotNil: [parser := componentType parameterParser: self].	rowIndex := 2.	(array isEmpty and: [aTable size = (rowIndex - 1)])		ifTrue: [aTable first first pass: aTestResults].	arrayIndex := 1.	[rowIndex &lt;= aTable size and: [arrayIndex &lt;= array size]] whileTrue: 			[(self				checkRow: (aTable at: rowIndex)				expected: (array at: arrayIndex)				resultsInto: aTestResults) ifTrue: [arrayIndex := arrayIndex + 1].			rowIndex := rowIndex + 1].	rowIndex to: aTable size		do: [:index | (aTable at: index) missing: aTestResults].	arrayIndex to: array size		do: 			[:index |			self				missingActualElement: (array at: index)				inCell: aTable newRow addCell				resultsInto: aTestResults].	^array</body></methods><methods><class-id>Fitlibrary.ArrayTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">array: anArray componentType: aClass	^self new setArray: anArray componentType: (TypeAdapter adapterFor: aClass)</body><body package="FitLibrary">array: anArray parser: aParser	^self new setArray: anArray parser: aParser</body><body package="FitLibrary">typedArray: aTypedObject	^self array: aTypedObject subject		componentType: aTypedObject typeAdapter componentAdapter</body></methods><methods><class-id>Fitlibrary.DomainFixture</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	aDoFlowOnTable		handleDomainFixture: anInnerTableContext typedSubject		row: anInnerTableContext row		resultsInto: aTestResults.	^false</body></methods><methods><class-id>Fitlibrary.DomainFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (DomainTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.CombinationTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	self bindFirstRowToTarget: (aTable at: 2) resultsInto: aTestResults.	(aTable from: 3)		do: [:each | self processRow: each resultsInto: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.CombinationTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	topValues := OrderedCollection new.	methodOK := false</body></methods><methods><class-id>Fitlibrary.CombinationTraverse</class-id> <category>private</category><body package="FitLibrary">bindFirstRowToTarget: aRow resultsInto: aTestResults	| parameterParsers secondParser |		[| methodSpec |	methodSpec := MethodSpec numArgs: 2 runtimeContext: runtimeContext.	methodSpec		addSegment: 'combine';		addSegment: 'and'.	methodTarget := PlugBoard lookupTarget findMethodMappedTo: methodSpec				evaluator: self.	parameterParsers := methodTarget parameterParsers.	firstParser := parameterParsers first.	secondParser := parameterParsers at: 2]			on: Error			do: [:ex | ^aRow error: ex resultsInto: aTestResults].	(aRow from: 2) do: 			[:each |			[topValues add: (secondParser parse: each resultsInto: aTestResults)]				on: Error				do: [:ex | ^each error: ex resultsInto: aTestResults]].	methodOK := true</body><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	methodOK ifFalse: [^aRow ignore: aTestResults].		[| arg1 |	arg1 := firstParser parse: aRow first resultsInto: aTestResults.	aRow size - 1 &lt; topValues size		ifTrue: [^(MissingCellsException details: 'CombinationTraverse') raise].	aRow size - 1 &gt; topValues size		ifTrue: [^(ExtraCellsException details: 'CombinationTraverse') raise].	(aRow from: 2) keysAndValuesDo: 			[:index :each |			| result |			result := methodTarget						invokeOnArguments: (Array with: arg1 with: (topValues at: index)).			methodTarget				checkResult: result				expected: each				showWrongs: true				handleSubtype: false				resultsInto: aTestResults]]			on: Error			do: [:ex | ^aRow error: ex resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.BatchFitLibrary</class-id> <category>processing</category><body package="FitLibrary">doStorytest: aTables	ParseDelegation clearDelegatesForNextStorytest.	self doTables: aTables</body><body package="FitLibrary">doTables: aTables	tableListener clearTestResults.	doFlow runStorytest: aTables withListener: tableListener.	^tableListener testResults</body><body package="FitLibrary">doTables: aTables withListener: aTableListener	tableListener := aTableListener.	self doStorytest: aTables</body><body package="FitLibrary">exit	doFlow exit</body></methods><methods><class-id>Fitlibrary.BatchFitLibrary</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	doFlow := self wiredUpDoFlow.	tableListener := TableListener results: TestResults new</body><body package="FitLibrary">wiredUpDoFlow	| flowEvaluator runtime global scopeStack doFlow2 |	flowEvaluator := DoTraverse new.	global := GlobalActionScope new.	scopeStack := ScopeStack flowEvaluator: flowEvaluator				global: (TypedObject subject: global).	runtime := RuntimeContext scope: scopeStack globalActionScope: global.	global runtimeContext: runtime.	flowEvaluator runtimeContext: runtime.	doFlow2 := DoFlowWithExtraTableAddedWhenNeeded				flowEvaluator: flowEvaluator				scopeStack: scopeStack				runtime: runtime				setUpTearDown: SetUpTearDown new.	runtime tableEvaluator: doFlow2.	^doFlow2</body></methods><methods><class-id>Fitlibrary.BatchFitLibrary</class-id> <category>accessing</category><body package="FitLibrary">useOldFoldingTextMarkup: aBoolean	doFlow useOldFoldingTextMarkup: aBoolean</body></methods><methods><class-id>Fitlibrary.BatchFitLibrary class</class-id> <category>instance creation</category><body package="FitLibrary">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.MapSetUpTraverse</class-id> <category>accessing</category><body package="FitLibrary">results	^theMap</body></methods><methods><class-id>Fitlibrary.MapSetUpTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults		[(aTable from: 2)		do: [:each | self processRow: each resultsInto: aTestResults]]			on: Error			do: [:ex | aTable error: ex resultsInto: aTestResults].	^theMap</body></methods><methods><class-id>Fitlibrary.MapSetUpTraverse</class-id> <category>private</category><body package="FitLibrary">processRow: aRow resultsInto: aTestResults		[| key value |	aRow size = 2 ifFalse: [^(RowWrongWidthException expectedWidth: 2) raise].	key := keyParser parse: aRow first resultsInto: aTestResults.	value := valueParser parse: (aRow at: 2) resultsInto: aTestResults.	theMap at: key put: value]			on: Error			do: [:ex | aRow error: ex resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.MapSetUpTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setKeyType: keyTypeAdapter valueType: valueTypeAdapter runtimeContext: aRuntimeContext	self runtimeContext: aRuntimeContext.	theMap := Dictionary new.	keyParser := keyTypeAdapter parameterParser: self.	valueParser := valueTypeAdapter parameterParser: self</body><body package="FitLibrary">setRuntimeContext: aRuntimeContext	self runtimeContext: aRuntimeContext.	theMap := Dictionary new.	keyParser := (TypeAdapter adapterFor: String) parameterParser: self.	valueParser := (TypeAdapter adapterFor: String) parameterParser: self</body></methods><methods><class-id>Fitlibrary.MapSetUpTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">keyType: keyTypeAdapter valueType: valueTypeAdapter runtimeContext: aRuntimeContext	^self new		setKeyType: keyTypeAdapter		valueType: valueTypeAdapter		runtimeContext: aRuntimeContext</body><body package="FitLibrary">runtimeContext: aRuntimeContext	^self new setRuntimeContext: aRuntimeContext</body></methods><methods><class-id>Fitlibrary.DomainFixtured</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryAutoWrappedFor: aTypedObject evaluator: anEvaluator	^self</body><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	aDoFlowOnTable		handleDomainFixture: anInnerTableContext typedSubject		row: anInnerTableContext row		resultsInto: aTestResults.	^false</body></methods><methods><class-id>Fitlibrary.CombinationFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (CombinationTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.CombinationFixture class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: aSystemUnderTest	^(self basicNew)		initialize;		systemUnderTest: aSystemUnderTest</body></methods><methods><class-id>FitlibraryGeneric.NestingListTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setList: anOrderedCollection type: aTypeAdapter	list := anOrderedCollection.	typeAdapter := aTypeAdapter</body></methods><methods><class-id>FitlibraryGeneric.NestingListTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| parser |	parser := typeAdapter parameterParser: self.	aTable keysAndValuesDo: 			[:index :eachRow |						[| cell |			eachRow size = 1				ifFalse: [^(RowWrongWidthException expectedWidth: 1) raise].			cell := eachRow first.			index &gt; list size				ifTrue: [cell actualElementMissing: aTestResults]				ifFalse: 					[parser						expectedCell: cell						matches: (list at: index)						resultsInto: aTestResults]]					on: Error					do: [:ex | eachRow error: ex resultsInto: aTestResults]].	aTable size + 1 to: list size		do: 			[:index |			| row cell |			row := aTable newRow.			cell := row addCell.						[cell actualElementMissing: (parser show: (list at: index))				resultsInto: aTestResults]					on: Error					do: [:ex | cell error: ex resultsInto: aTestResults]].	^list</body></methods><methods><class-id>FitlibraryGeneric.NestingListTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">list: anOrderedCollection type: aTypeAdapter	^self new setList: anOrderedCollection type: aTypeAdapter</body></methods><methods><class-id>Fitlibrary.Rule</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryAutoWrappedFor: aTypedObject evaluator: anEvaluator	^RuleTable systemUnderTest: self</body></methods><methods><class-id>Fitlibrary.ParamRowFixture</class-id> <category>abstracts</category><body package="FitLibrary">query	^objects</body></methods><methods><class-id>Fitlibrary.ParamRowFixture</class-id> <category>initialize-release</category><body package="FitLibrary">setObjects: aCollection targetClass: aClass	objects := aCollection.	targetClass := aClass</body></methods><methods><class-id>Fitlibrary.ParamRowFixture</class-id> <category>accessing</category><body package="FitLibrary">targetClass	^targetClass</body></methods><methods><class-id>Fitlibrary.ParamRowFixture class</class-id> <category>instance creation</category><body package="FitLibrary">objects: aCollection	"There needs to be at least one element in aCollection for this to be used."	^self objects: aCollection targetClass: aCollection first class</body><body package="FitLibrary">objects: aCollection targetClass: aClass	^self new setObjects: aCollection targetClass: aClass</body></methods><methods><class-id>Fitlibrary.FitLibraryShowException</class-id> <category>accessing</category><body package="FitLibrary">result	^show</body></methods><methods><class-id>Fitlibrary.FitLibraryShowException</class-id> <category>initialize-release</category><body package="FitLibrary">setShow: aShow	show := aShow</body></methods><methods><class-id>Fitlibrary.FitLibraryShowException class</class-id> <category>instance creation</category><body package="FitLibrary">show: aShow	^(self messageText: 'show')		setShow: aShow;		yourself</body></methods><methods><class-id>Fitlibrary.SequenceTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject	^self systemUnderTest: anObject sequencing: true</body></methods><methods><class-id>Fitlibrary.Spec.SpecifyFixture</class-id> <category>private</category><body package="FitLibrary">cellCount: aTables	| count |	count := 0.	aTables do: 			[:eachTable |			eachTable do: 					[:eachRow |					eachRow do: [:eachCell | count := count + 1 + (self cellCount: eachCell)]]].	^count</body><body package="FitLibrary">expectedFrom: aTable	(aTable size = 2 and: [(aTable at: 2) size = 2])		ifTrue: [^aTable second second].	(aTable size = 3		and: [(aTable at: 2) size = 1 and: [(aTable at: 3) size = 1]])			ifTrue: [^(aTable at: 3) first].	^FitLibraryException		raiseErrorString: 'Table must have one row wtih two cells or two rows with one cell'</body></methods><methods><class-id>Fitlibrary.Spec.SpecifyFixture</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| actualCell expectedCell expectedTables actualTables |		[actualCell := aTable second first.	actualCell isEmpty		ifTrue: 			[^FitLibraryException raiseErrorString: 'Missing nested tables to be run'].	expectedCell := self expectedFrom: aTable.	expectedTables := expectedCell actualEmbeddedTables.	actualTables := actualCell actualEmbeddedTables.	runner doStorytest: actualTables.	(tablesCompare tables: actualTables equalTo: expectedTables)		ifTrue: 			[expectedCell pass: aTestResults.			aTestResults addRights: (self cellCount: actualTables) - 1]		ifFalse: 			[expectedCell fail: aTestResults.			errorReport actualResult: actualTables]]			on: Error			do: [:ex | aTable error: ex resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.Spec.SpecifyFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	runner := BatchFitLibrary new.	runner useOldFoldingTextMarkup: true.	errorReport := SpecifyErrorReport showAfter: self.	tablesCompare := TablesCompare errorReport: errorReport				variableResolver: self</body></methods><methods><class-id>Fitlibrary.Spec.SpecifyFixture class</class-id> <category>instance creation</category><body package="FitLibrary">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Spec.SpecifySuiteFixture</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	(aTable from: 2) do: 			[:each |			| testCell reportCell actualTables expectedTables |			each size &lt; 2				ifTrue: 					[each error: (RowWrongWidthException expectedWidth: 2)						resultsInto: aTestResults].			testCell := each first.			reportCell := each at: 2.			(testCell hasEmbeddedTables: self)				ifFalse: 					[each error: NestedTableExpectedException new resultsInto: aTestResults.					^nil].			actualTables := testCell embeddedTables.			expectedTables := reportCell embeddedTables.			runner doStorytest: actualTables.			(tablesCompare tables: actualTables equalTo: expectedTables path: '')				ifTrue: 					[reportCell pass: aTestResults.					aTestResults addRights: (self cellCount: actualTables) - 1]				ifFalse: 					[reportCell fail: aTestResults.					errorReport actualResult: actualTables]].	^nil</body></methods><methods><class-id>Fitlibrary.TaggedString</class-id> <category>fit-utilities</category><body package="FitLibrary">fitToString	^string</body></methods><methods><class-id>Fitlibrary.TaggedString</class-id> <category>initialize-release</category><body package="FitLibrary">setString: aString	string := aString</body></methods><methods><class-id>Fitlibrary.TaggedString</class-id> <category>comparing</category><body package="FitLibrary">= aTaggedString	^string = aTaggedString string</body><body package="FitLibrary">hash	^string hash</body></methods><methods><class-id>Fitlibrary.TaggedString</class-id> <category>accessing</category><body package="FitLibrary">string	^string</body></methods><methods><class-id>Fitlibrary.TaggedString class</class-id> <category>instance creation</category><body package="FitLibrary">string: aString	^self new setString: aString</body></methods><methods><class-id>Fitlibrary.TaggedString class</class-id> <category>fit-utilities</category><body package="FitLibrary">fitTypeAdapter	^TypeAdapterParserBridge type: self		parserBlock: [TaggedStringParser forClass: self]</body></methods><methods><class-id>Fitlibrary.SelectFixture</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	anInnerTableContext runtimeContext showAsAfterTableTitle: 'warning'		contents: 'This is no longer needed'.	aDoFlowOnTable		handleActualDoFixture: self		row: anInnerTableContext row		resultsInto: aTestResults.	^false</body></methods><methods><class-id>Fitlibrary.NullOnErrorHandler</class-id> <category>accessing</category><body package="FitLibrary">stopOnFailures: failureInteger errors: errorInteger	^false</body></methods><methods><class-id>Fitlibrary.RuleTable</class-id> <category>private</category><body package="FitLibrary">basicCheck: aTable resultsInto: aTestResults	| width |	width := (aTable at: 2) size.	(aTable from: 3) do: 			[:each |			each size = width				ifFalse: 					[each first						errorMessage: 'Irregular shaped: This row differs in width from the header'						resultsInto: aTestResults.					IgnoredException raise]]</body><body package="FitLibrary">body: aTable resultsInto: aTestResults	(aTable from: 3) do: 			[:each |						[resetMethod ifNotNil: #invoke.			self row: each resultsInto: aTestResults]					on: Error					do: [:ex | each error: ex resultsInto: aTestResults]]</body><body package="FitLibrary">header: aTable resultsInto: aTestResults	(aTable at: 2) do: 			[:each |						[| name input |			name := each resolvedText: self.			input := true.			name last = $?				ifTrue: 					[input := false.					name := name copyFrom: 1 to: name size - 1].			input				ifTrue: 					[columnTargets add: (InputColumnTarget								target: (PlugBoard lookupTarget findSetter: name onSutOf: self))]				ifFalse: 					[| target |					target := PlugBoard lookupTarget findGetter: name onSutOf: self.					target returnsVoid						ifTrue: [(VoidMethodException selector: name page: 'RuleTable') raise].					columnTargets add: (OutputColumnTarget target: target)]]					on: Error					do: 						[:ex |						each error: ex resultsInto: aTestResults.						hasErrors := true]]</body><body package="FitLibrary">lookupOptionalFunction: aString	^PlugBoard lookupTarget findMethodMappedTo: (MethodSpec				baseName: aString				numArgs: 0				runtimeContext: runtimeContext)		evaluator: self</body><body package="FitLibrary">optionalFunctions	[resetMethod := self lookupOptionalFunction: 'reset'] on: Error		do: 			[:ex |			"Do nothing, it's optional"			].	[executeMethod := self lookupOptionalFunction: 'execute'] on: Error		do: 			[:ex |			"Do nothing, it's optional"			]</body><body package="FitLibrary">row: aRow resultsInto: aTestResults	| haveCalledExecuteForThisRow |	haveCalledExecuteForThisRow := executeMethod isNil.	aRow keysAndValuesDo: 			[:index :each |						[| columnTarget |			columnTarget := columnTargets at: index.			(haveCalledExecuteForThisRow not and: [columnTarget isOutput])				ifTrue: 					[executeMethod invoke.					haveCalledExecuteForThisRow := true].			columnTarget actOn: each resultsInto: aTestResults]					on: Error					do: [:ex | ^each error: ex resultsInto: aTestResults]]</body></methods><methods><class-id>Fitlibrary.RuleTable</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults		[	[self		basicCheck: aTable resultsInto: aTestResults;		header: aTable resultsInto: aTestResults;		optionalFunctions.	hasErrors ifFalse: [self body: aTable resultsInto: aTestResults]]			on: IgnoredException			do: [:ex | ]]			on: Error			do: [:ex | (aTable at: 2) error: ex resultsInto: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.RuleTable</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	columnTargets := OrderedCollection new.	hasErrors := false</body></methods><methods><class-id>FitlibraryGeneric.NestingListSetUpTraverse</class-id> <category>accessing</category><body package="FitLibrary">results	^list</body></methods><methods><class-id>FitlibraryGeneric.NestingListSetUpTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| parser |	parser := componentAdapter parameterParser: self.	aTable do: 			[:each |						[each size = 1 ifFalse: [^(RowWrongWidthException expectedWidth: 1) raise].			list add: (parser parse: each first resultsInto: aTestResults)]					on: Error					do: [:ex | each error: ex resultsInto: aTestResults]].	^list</body></methods><methods><class-id>FitlibraryGeneric.NestingListSetUpTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setComponentAdapter: aTypeAdapter	componentAdapter := aTypeAdapter.	list := OrderedCollection new</body></methods><methods><class-id>FitlibraryGeneric.NestingListSetUpTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">componentAdapter: aTypeAdapter	^self new setComponentAdapter: aTypeAdapter</body></methods><methods><class-id>Fitlibrary.SetFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: SetTraverse new</body></methods><methods><class-id>Fitlibrary.SetFixture class</class-id> <category>instance creation</category><body package="FitLibrary">actuals: aCollection	^self traverse: (SetTraverse systemUnderTest: nil actuals: aCollection)</body></methods><methods><class-id>Fitlibrary.ConstraintTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	self bindFirstRowToTarget: (aTable at: 2) resultsInto: aTestResults.	(aTable from: 3)		do: [:each | self processRow: each resultsInto: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.ConstraintTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	expected := true.	methodOK := false.	argCount := -1</body><body package="FitLibrary">setExpected: aBoolean	expected := aBoolean</body></methods><methods><class-id>Fitlibrary.ConstraintTraverse</class-id> <category>private</category><body package="FitLibrary">bindFirstRowToTarget: aRow resultsInto: aTestResults	| methodSpec |	argCount := aRow size.	methodSpec := MethodSpec numArgs: argCount runtimeContext: runtimeContext.	aRow do: [:each | methodSpec addSegment: (each resolvedText: self)].		[	[target := PlugBoard lookupTarget findMethodMappedTo: methodSpec				evaluator: self.	target returnsBoolean		ifFalse: 			[^(BooleanMethodException methodName: methodSpec canonicalSelector) raise].	target repeatString: repeatString exceptionString: exceptionString.	methodOK := true]			on: IgnoredException			do: 				[:ex |				"do nothing"				]]			on: Error			do: 				[:ex |				expected					ifTrue: [aRow error: ex resultsInto: aTestResults]					ifFalse: [aRow pass: aTestResults]]</body><body package="FitLibrary">processRow: aRow resultsInto: aTestResults	methodOK ifFalse: [^aRow ignore: aTestResults].	aRow size = argCount		ifFalse: 			[^aRow error: (RowWrongWidthException expectedWidth: argCount)				resultsInto: aTestResults].		[	[| result |	result := target invokeOnRow: aRow resultsInto: aTestResults.	aRow passOrFail: result == expected resultsInto: aTestResults]			on: IgnoredException			do: 				[:ex |				"do nothing"				]]			on: Error			do: 				[:ex |				expected					ifTrue: [aRow error: ex resultsInto: aTestResults]					ifFalse: [aRow pass: aTestResults]]</body></methods><methods><class-id>Fitlibrary.ConstraintTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject expected: aBoolean	^(self systemUnderTest: anObject) setExpected: aBoolean</body></methods><methods><class-id>Fitlibrary.RandomSelectTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setVariable: aString	variable := aString</body></methods><methods><class-id>Fitlibrary.RandomSelectTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	| select |	aTable size &lt;= 1		ifTrue: 			[^FitLibraryException				raiseErrorString: 'Possible values are needed in subsequent rows of the table'].	select := 1 + ((self class random next * (aTable size - 1)) truncated + 1).	self dynamicVariableAt: variable		put: ((aTable at: select) resolvedTextAt: 1 resolver: self).	^nil</body></methods><methods><class-id>Fitlibrary.RandomSelectTraverse class</class-id> <category>random</category><body package="FitLibrary">initializeRandom	RandomGenerator := Random new.	Session		when: SessionEnding		do: [RandomGenerator := nil]		for: self</body><body package="FitLibrary">random	RandomGenerator ifNil: [self initializeRandom].	^RandomGenerator</body></methods><methods><class-id>Fitlibrary.RandomSelectTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">variable: aString	^self new setVariable: aString</body></methods><methods><class-id>Fitlibrary.SubsetFixture class</class-id> <category>instance creation</category><body package="FitLibrary">actuals: aCollection	^self traverse: (SetTraverse actuals: aCollection showSurplus: false)</body><body package="FitLibrary">new	^self traverse: (SetTraverse new showSurplus: false)</body></methods><methods><class-id>Fitlibrary.SetTraverse</class-id> <category>running</category><body package="FitLibrary">interpretRow: aRow getters: aCollection resultsInto: aTestResults	| rowLength columnBindings matchingActuals |	aCollection isEmpty ifTrue: [^aRow missing: aTestResults].	rowLength := aRow size.	columnBindings := aCollection first.	rowLength &lt; columnBindings size		ifTrue: [(MissingCellsException details: 'SetTraverse') raise].	rowLength &gt; columnBindings size		ifTrue: [(ExtraCellsException details: 'SetTraverse') raise].	matchingActuals := aCollection.	columnBindings keysAndValuesDo: 			[:index :each |			matchingActuals := self						match: aRow						actuals: matchingActuals						onColumn: index						resultsInto: aTestResults.			matchingActuals isEmpty ifTrue: [^aRow missing: aTestResults].			matchingActuals size = 1				ifTrue: 					[| theOne |					theOne := matchingActuals first.					self matchRow: aRow bindings: theOne resultsInto: aTestResults.					^aCollection remove: theOne]].	matchingActuals isEmpty		ifFalse: 			[| theOne |			theOne := matchingActuals first.			self matchRow: aRow bindings: theOne resultsInto: aTestResults.			aCollection remove: theOne]</body></methods><methods><class-id>Fitlibrary.SetTraverse</class-id> <category>private</category><body package="FitLibrary">match: aRow actuals: aCollection onColumn: anInteger resultsInto: aTestResults	| cell |	cell := aRow at: anInteger.	^aCollection inject: OrderedCollection new		into: 			[:result :each |			(each at: anInteger)				ifNil: [(cell isBlank: self) ifTrue: [result add: each]]				ifNotNil: 					[:getter |										[(getter matches: cell resultsInto: aTestResults)						ifTrue: [result add: each]]							on: Error							do: 								[:ex |								"just eat it"								]].			result]</body></methods><methods><class-id>Fitlibrary.SetTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">actuals: aCollection showSurplus: aBoolean	^(self systemUnderTest: nil actuals: aCollection)		showSurplus: aBoolean;		yourself</body></methods><methods><class-id>Fitlibrary.DomainObjectCheckFixture</class-id> <category>initialize-release</category><body package="FitLibrary">setSystemUnderTest: anObject	self		systemUnderTest: anObject;		setTraverse: (DomainObjectCheckTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.DomainObjectCheckFixture class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject	^self new setSystemUnderTest: anObject</body></methods><methods><class-id>Fitlibrary.DomainObjectCheckTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	(aTable from: 2)		do: [:each | self interpretRow: each resultsInto: aTestResults].	^self systemUnderTest</body></methods><methods><class-id>Fitlibrary.DomainObjectCheckTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setType: aClass	type := aClass</body></methods><methods><class-id>Fitlibrary.DomainObjectCheckTraverse</class-id> <category>private</category><body package="FitLibrary">checkClass: aCell classCell: classCell resultsInto: aTestResults		[| sutClass typeName |	typeName := classCell resolvedText: self.	sutClass := PlugBoard lookupTarget				findClassFromFactoryMethod: typeName				baseType: type				evaluator: self.	classCell passOrFail: self systemUnderTest class == sutClass		resultsInto: aTestResults]			on: Error			do: [:ex | aCell error: ex resultsInto: aTestResults]</body><body package="FitLibrary">interpretRow: aRow resultsInto: aTestResults	aRow withResults: aTestResults		pairsDo: 			[:cell :nextCell |			(DomainObjectSetUpTraverse givesClass: cell variableResolver: self)				ifTrue: 					[self systemUnderTest ifNil: [^NoSystemUnderTestException raise].					self checkClass: cell classCell: nextCell resultsInto: aTestResults]				ifFalse: 					[					[| target |					target := PlugBoard lookupTarget findGetter: (cell resolvedText: self)								onSutOf: self.					target						invokeAndCheckRow: Row new						expectedCell: nextCell						handleSubtype: false						resultsInto: aTestResults]							on: Error							do: [:ex | cell error: ex resultsInto: aTestResults]]]</body></methods><methods><class-id>Fitlibrary.DomainObjectCheckTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">systemUnderTest: anObject	^(super systemUnderTest: anObject) setType: anObject class</body><body package="FitLibrary">systemUnderTest: anObject type: aTypeAdapter	^(self		systemUnderTest: (TypedObject subject: anObject typeAdapter: aTypeAdapter))			setType: aTypeAdapter type</body><body package="FitLibrary">typedSystemUnderTest: aTypedObject	^(self systemUnderTest: aTypedObject) setType: aTypedObject classType</body></methods><methods><class-id>Fitlibrary.SequenceFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	self setTraverse: (SequenceTraverse systemUnderTest: self)</body></methods><methods><class-id>Fitlibrary.ClassPropertyEditor</class-id> <category>accessing</category><body package="FitLibrary">getAsText	" *** This method was defined by Fitlibrary.PropertyEditor as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="FitLibrary">setAsText: aString	| class |	class := (ClassNameConversion javaName: aString) classOrNil				ifNil: [^(CouldNotParseException class: Class text: aString) raise].	self value: class</body></methods><methods><class-id>Fitlibrary.ClassPropertyEditor class</class-id> <category>testing</category><body package="FitLibrary">isForClass: aClass	^aClass == Class</body></methods><methods><class-id>Fitlibrary.ListTraverse</class-id> <category>running</category><body package="FitLibrary">interpretRow: aRow getters: aCollection resultsInto: aTestResults	| rowLength columnBindings |	aCollection isEmpty ifTrue: [^aRow missing: aTestResults].	rowLength := aRow size.	columnBindings := aCollection first.	rowLength &lt; columnBindings size		ifTrue: [(MissingCellsException details: 'ArrayTraverse') raise].	rowLength &gt; columnBindings size		ifTrue: [(ExtraCellsException details: 'ArrayTraverse') raise].	(aCollection notEmpty		and: [self matchRow: aRow bindings: columnBindings resultsInto: aTestResults])			ifTrue: [aCollection removeFirst]			ifFalse: [aRow missing: aTestResults]</body></methods><methods><class-id>Fitlibrary.Traverse.CommentTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	markAsIgnored := false</body><body package="FitLibrary">markAsIgnored: aBoolean	markAsIgnored := aBoolean</body></methods><methods><class-id>Fitlibrary.Traverse.CommentTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	markAsIgnored ifTrue: [aTable ignore: aTestResults].	^nil</body></methods><methods><class-id>Fitlibrary.Traverse.CommentTraverse class</class-id> <category>instance creation</category><body package="FitLibrary">markAsIgnored: aBoolean	^self new markAsIgnored: aBoolean</body><body package="FitLibrary">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Suite.SuiteFixture</class-id> <category>initialize-release</category><body package="FitLibrary">initialize	super initialize.	keys := Set new</body></methods><methods><class-id>Fitlibrary.Suite.SuiteFixture</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	aDoFlowOnTable		handleSuiteFixture: self		typed: anInnerTableContext typedSubject		row: anInnerTableContext row		resultsInto: aTestResults.	^false</body></methods><methods><class-id>Fitlibrary.Suite.SuiteFixture</class-id> <category>accessing</category><body package="FitLibrary">copyOfRuntimeContext	^self runtimeContext copyFromSuite</body></methods><methods><class-id>Fitlibrary.Traverse.GridTraverse</class-id> <category>private</category><body package="FitLibrary">addActualRowsFrom: anArray to: aTable	| columns |	columns := 0.	aTable do: [:each | columns := columns max: each size].	anArray do: [:each | columns := columns max: each size].	aTable newRow addCellWithString: '&lt;i&gt;Actuals:&lt;/i&gt;' spanning: columns.	anArray do: [:each | self makeRow: aTable newRow withActuals: each]</body><body package="FitLibrary">cell: aCell matches: anObject resultsInto: aTestResults	| matches |	matches := false.		[matches := parser				expectedCell: aCell				matches: anObject				resultsInto: aTestResults]			on: Error			do: 				[:ex |				"doesn't match"				].	aCell passOrFail: matches resultsInto: aTestResults.	^matches</body><body package="FitLibrary">cellWithValue: anObject	| cell |	cell := FitlibraryInternals.Cell withString: ''.	[cell unvisitedText: (parser show: anObject)] on: Error		do: [:ex | cell unvisitedText: ex errorString].	^cell</body><body package="FitLibrary">cellsIn: aRow match: anArray resultsInto: aTestResults	| matched |	matched := true.	anArray keysAndValuesDo: 			[:index :each |			(aRow existsAt: index) ifFalse: [^false].			(self				cell: (aRow at: index)				matches: each				resultsInto: aTestResults) ifFalse: [matched := false]].	(aRow from: anArray size + 1) do: 			[:each |			matched := false.			each fail: aTestResults].	^matched</body><body package="FitLibrary">makeRow: aRow withActuals: anArray	anArray isEmpty ifTrue: [^self error: 'Actuals row empty'].	anArray do: [:each | aRow add: (self cellWithValue: each)]</body><body package="FitLibrary">rowsIn: aTable match: anArray resultsInto: aTestResults	| matched |	matched := true.	anArray keysAndValuesDo: 			[:index :each |			(aTable existsAt: index + 1) ifFalse: [^false].			(self				cellsIn: (aTable at: index + 1)				match: each				resultsInto: aTestResults) ifFalse: [matched := false]].	(aTable from: anArray size + 2) do: 			[:each |			matched := false.			each fail: aTestResults].	^matched</body></methods><methods><class-id>Fitlibrary.Traverse.GridTraverse</class-id> <category>initialize-release</category><body package="FitLibrary">setGrid: anArray elementType: aClass	grid := anArray.	elementType := aClass</body></methods><methods><class-id>Fitlibrary.Traverse.GridTraverse</class-id> <category>running</category><body package="FitLibrary">interpretAfterFirstRow: aTable resultsInto: aTestResults	parser := (Fit.TypeAdapter adapterFor: elementType) parameterParser: self.	(grid isEmpty and: [aTable size = 1])		ifTrue: 			[aTable pass: aTestResults.			^grid].	(self rowsIn: aTable match: grid resultsInto: aTestResults)		ifFalse: [self addActualRowsFrom: grid to: aTable].	^grid</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>accessing</category><body package="FitLibrary">becomesTimeout: anInteger	&lt;fitTakes: #Integer&gt;	self global becomesTimeout: anInteger</body></methods><methods><class-id>Fitlibrary.Traverse.Workflow.DoTraverse</class-id> <category>special actions</category><body package="FitLibrary">addGlobal: aRow resultsInto: aTestResults	&lt;fitTakes: #(#{Fitlibrary.Row} #{Fitlibrary.TestResults})&gt;	| typedObject |	aRow size &lt; 2		ifTrue: [^(MissingCellsException details: 'addGlobal') raise].	typedObject := self interpretRow: (aRow from: 2) resultsInto: aTestResults.	(typedObject isNil or: [typedObject isNull]) ifTrue: [^self].	typedObject classType == DoTraverse		ifTrue: [typedObject := typedObject typedSystemUnderTest].	typedObject injectRuntime: self runtimeContext.	self runtimeContext scope addGlobal: typedObject.	aRow first pass: aTestResults</body><body package="FitLibrary">addNamed: aRow resultsInto: aTestResults	&lt;fitTakes: #(#{Fitlibrary.Row} #{Fitlibrary.TestResults})&gt;	| typedObject |	aRow size &lt; 3		ifTrue: [^self error: 'Need to implement MissingCellsException here'].	typedObject := self interpretRow: (aRow from: 3) resultsInto: aTestResults.	self runtimeContext tableEvaluator		addObject: typedObject		named: (aRow resolvedTextAt: 2 resolver: self)		from: aRow		resultsInto: aTestResults</body><body package="FitLibrary">calculate	&lt;fitReturns: #{Fitlibrary.Fixture}&gt;	^Fitlibrary.CalculateTraverse systemUnderTest: (self class == DoTraverse				ifTrue: [self typedSystemUnderTest]				ifFalse: [self])</body><body package="FitLibrary">check: aRow	&lt;fitTakes: #{Fitlibrary.Row}&gt;	&lt;fitReturns: #{Fitlibrary.TwoStageSpecial}&gt;	^prefixSpecialAction check: aRow</body><body package="FitLibrary">constraint	&lt;fitReturns: #{Fitlibrary.ConstraintTraverse}&gt;	^Fitlibrary.ConstraintTraverse systemUnderTest: self</body><body package="FitLibrary">expectedTestResults: aRow resultsInto: aTestResults	&lt;fitTakes: #(#{Fitlibrary.Row} #{Fitlibrary.TestResults})&gt;	(aTestResults		matchesRight: (aRow resolvedTextAt: 2 resolver: self)		wrong: (aRow resolvedTextAt: 4 resolver: self)		ignores: (aRow resolvedTextAt: 6 resolver: self)		errors: (aRow resolvedTextAt: 8 resolver: self))			ifTrue: 				[aTestResults clear.				aRow first pass: aTestResults]			ifFalse: 				[| results |				results := aTestResults printString.				aTestResults clear.				aRow first fail: aTestResults withMessage: results variableResolver: self]</body><body package="FitLibrary">failingConstraint	&lt;fitReturns: #{Fitlibrary.ConstraintTraverse}&gt;	^Fitlibrary.ConstraintTraverse systemUnderTest: self expected: false</body><body package="FitLibrary">note: aRow resultsInto: aTestResults	"Nothing to do"	&lt;fitTakes: #(#{Fitlibrary.Row} #{Fitlibrary.TestResults})&gt;</body><body package="FitLibrary">oo: aRow resultsInto: aTestResults	&lt;fitTakes: #(#{Fitlibrary.Row} #{Fitlibrary.TestResults})&gt;	| object className macroRow |	aRow size &lt; 3		ifTrue: [^(MissingCellsException details: 'DoTraverseOO') raise].	object := aRow resolvedTextAt: 2 resolver: self.	className := self dynamicVariableAt: object , '.class'.	(className isNil or: [className isEmpty]) ifTrue: [className := object].	macroRow := aRow from: 3.	^((DefinedActionCaller		object: object		className: className		row: macroRow		runtimeContext: self runtimeContext) run: aRow resultsInto: aTestResults)		subject</body><body package="FitLibrary">optionally: aRow resultsInto: aTestResults	&lt;fitTakes: #(#{Fitlibrary.Row} #{Fitlibrary.TestResults})&gt;		[	[| result |	result := self				callMethodInRow: aRow				catchParseError: true				operatorCell: aRow first				resultsInto: aTestResults.	"result may or may not be a Boolean"	result == false		ifTrue: 			[(aRow addCellWithString: 'false') shown.			self runtimeContext definedActionCallManager addShow: aRow]]			on: FitLibraryException			do: [:ex | aRow first error: ex resultsInto: aTestResults]]			on: Error			do: 				[:ex |				(aRow addCellWithString: (FitlibraryInternals.PlugBoard exceptionHandling							exceptionMessageFor: ex))					shown.				self runtimeContext definedActionCallManager addShow: aRow].	aRow first pass: aTestResults</body><body package="FitLibrary">set: aRow	&lt;fitTakes: #{Fitlibrary.Row}&gt;	&lt;fitReturns: #{Fitlibrary.TwoStageSpecial}&gt;	^prefixSpecialAction set: aRow</body><body package="FitLibrary">setSymbolNamed: aRow	&lt;fitTakes: #{Fitlibrary.Row}&gt;	&lt;fitReturns: #{Fitlibrary.TwoStageSpecial}&gt;	^prefixSpecialAction setSymbolNamed: aRow</body><body package="FitLibrary">start: aString	&lt;fitTakes: #String&gt;	| conversion |	conversion := Fit.ClassNameConversion javaName: aString.	conversion classOrNil		ifNil: [(FitLibraryException messageText: 'Unknown class ' , aString) raise]		ifNotNil: [:class | self systemUnderTest: class new]</body><body package="FitLibrary">withResults: aTestResults becomes: aRow	&lt;fitTakes: #(#{Fitlibrary.TestResults} #{Fitlibrary.Row})&gt;	| target expectedCell actionPartOfRow start becomesTimeout matched requiredCells |	requiredCells := 3.	aRow size &lt; requiredCells		ifTrue: [^(MissingCellsException details: 'DoTraverseBecomes') raise].	target := self findMethodFromRow222: aRow from: 1 using: requiredCells.	expectedCell := aRow last.	actionPartOfRow := aRow from: 2 to: aRow size - 1.	start := Time millisecondClockValue.	becomesTimeout := self becomesTimeout.	matched := false.	[matched or: [Time millisecondClockValue - start &gt;= becomesTimeout]]		whileFalse: 			[| result |			result := target						invokeForSpecial: actionPartOfRow						catchParseError: false						operatorCell: (self operatorCellIn: aRow)						resultsInto: aTestResults.			(target resultParser				expectedCell: expectedCell				matches: result				resultsInto: aTestResults)					ifTrue: [matched := true]					ifFalse: [(100 min: becomesTimeout / 10) milliseconds wait]].	target		invokeAndCheckForSpecial: actionPartOfRow		expectedCell: expectedCell		fullRow: aRow		specialCell: (self operatorCellIn: aRow)		resultsInto: aTestResults</body><body package="FitLibrary">withResults: aTestResults equals: aRow	&lt;fitTakes: #(#{Fitlibrary.TestResults} #{Fitlibrary.Row})&gt;	^self withResults: aTestResults is: aRow</body><body package="FitLibrary">withResults: aTestResults is: aRow	&lt;fitTakes: #(#{Fitlibrary.TestResults} #{Fitlibrary.Row})&gt;	| target expectedCell requiredCells |	requiredCells := 3.	aRow size &lt; requiredCells		ifTrue: [^(MissingCellsException details: 'DoTraverseIs') raise].	target := self findMethodFromRow222: aRow from: 1 using: requiredCells.	expectedCell := aRow last.	target		invokeAndCheckForSpecial: (aRow from: 2 to: aRow size - 1)		expectedCell: expectedCell		fullRow: aRow		specialCell: (self operatorCellIn: aRow)		resultsInto: aTestResults</body><body package="FitLibrary">withResults: aTestResults isNot: aRow	&lt;fitTakes: #(#{Fitlibrary.TestResults} #{Fitlibrary.Row})&gt;	| target expectedCell requiredCells specialCell result |	requiredCells := 3.	aRow size &lt; requiredCells		ifTrue: [^(MissingCellsException details: 'DoTraverseIsNot') raise].	specialCell := self operatorCellIn: aRow.	expectedCell := aRow last.		[	[	[target := self findMethodFromRow222: aRow from: 1 using: requiredCells.	result := target invokeOnRow: (aRow from: 2 to: aRow size - 1)				resultsInto: aTestResults.	target notResult: result expectedIn: expectedCell resultsInto: aTestResults]			on: IgnoredException			do: [:ex | ]]			on: FitLibraryShowException			do: 				[:ex |				specialCell error: aTestResults.				aRow error: ex resultsInto: aTestResults]]			on: Error			do: [:ex | expectedCell error: ex expected: false resultsInto: aTestResults]</body></methods><methods><class-id>Fitlibrary.CompareFilesFixture</class-id> <category>comparing</category><body package="FitLibrary">directory: aString sameAs: bString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #ListTree&gt;	^self folder: aString sameAs: bString</body><body package="FitLibrary">file: aString sameAs: bString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #ListTree&gt;	^traverse file: aString sameAs: bString</body><body package="FitLibrary">folder: aString sameAs: bString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #ListTree&gt;	^traverse folder: aString sameAs: bString</body></methods><methods><class-id>Fitlibrary.Suite.SuiteFixture</class-id> <category>accessing</category><body package="FitLibrary">keywords: anArray	&lt;fitTakes: #(#( #String ))&gt;	keys isEmpty ifTrue: [^self].	(anArray anySatisfy: [:each | keys includes: each])		ifFalse: [self abandon]</body><body package="FitLibrary">selectOr: anArray	&lt;fitTakes: #(#( #String ))&gt;	&lt;fitReturns: #Boolean&gt;	keys addAll: anArray.	^true</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>initialize</category><body package="FitLibrary">fitLibrary	"This is a total hack to support the Java SimpleDateFormat used by FitLibrary's specification tests.  	It is in no way a general implementation of Java's SimpleDateFormat"	timeSelector := #readFitLibraryTimeFrom:.	dateSelector := #readFitLibraryDateFrom:.	timestampSelector := #readFitLibraryTimestampFrom:</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>reading FitLibrary</category><body package="FitLibrary">readFitLibraryDateFrom: aStream 	| day month year |	year := self getLatinToken: aStream.	month := self getLatinToken: aStream.	day := self getLatinToken: aStream.	^Date 		newDay: day		monthNumber: month		year: year</body><body package="FitLibrary">readFitLibraryTimeFrom: aStream 	| hour minute |	hour := Integer readFrom: aStream.	minute := (aStream peekFor: $:) 				ifFalse: [0]				ifTrue: [Integer readFrom: aStream].	(hour &gt;= 0 and: [hour &lt;= 23]) 		ifFalse: 			[self error: (#errNotValidHour &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid hour' 						expandMacrosWith: hour)].	(minute &gt;= 0 and: [minute &lt;= 59]) 		ifFalse: 			[self 				error: (#errNotValidMinute &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; is not a valid minute' 						expandMacrosWith: minute)].	^Time fromSeconds: 60 * (60 * hour + minute)</body><body package="FitLibrary">readFitLibraryTimestampFrom: stream	"This is a clone of #readLatinTimestampFrom:, but using the FitLibrary Date and Time reading methods."	| date time milliseconds timestamp |	stream atEnd ifTrue: [^nil].	date := self readFitLibraryDateFrom: stream.	date isNil ifTrue: [^nil].	stream skipSeparators.	milliseconds := 0.	stream atEnd		ifTrue: [time := Time fromSeconds: 0]		ifFalse: 			[time := self readFitLibraryTimeFrom: stream.			stream peek == $.				ifTrue: 					[stream next.					milliseconds := Integer readFrom: stream]].	timestamp := Timestamp new fromDate: date andTime: time.	timestamp millisecond: milliseconds rounded.	^timestamp</body></methods><methods><class-id>Core.Object</class-id> <category>fit-utilities</category><body package="FitLibrary">fitLibraryAutoWrappedFor: aTypedObject evaluator: anEvaluator	self class fitLibraryIsPrimitive ifTrue: [^self].	(ParseDelegation hasParseMethod: self class) ifTrue: [^aTypedObject].	^DoTraverse systemUnderTest: aTypedObject</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Fixture</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>counts summary arguments listener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>FitLibraryException</name><environment>FitlibraryInternals</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><class><name>TimestampReader</name><environment>Core</environment><super>Core.LocaleSensitiveDataReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeSelector dateSelector timestampSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>RowFixture</name><environment>Fit</environment><super>Fit.ColumnFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results missing surplus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>FitServerBridge</name><environment>FitlibraryInternals</environment><super>Fit.AbstractFitServer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suiteTestResults reportListener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class></st-source>