<?xml version="1.0"?><st-source><!-- Name: FitNotice:                     GNU GENERAL PUBLIC LICENSE                       Version 2, June 1991 Copyright (C) 1989, 1991 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.                            Preamble  The licenses for most software are designed to take away yourfreedom to share and change it.  By contrast, the GNU General PublicLicense is intended to guarantee your freedom to share and change freesoftware- to make sure the software is free for all its users.  ThisGeneral Public License applies to most of the Free SoftwareFoundation's software and to any other program whose authors commit tousing it.  (Some other Free Software Foundation software is covered bythe GNU Lesser General Public License instead.)  You can apply it toyour programs, too.  When we speak of free software, we are referring to freedom, notprice.  Our General Public Licenses are designed to make sure that youhave the freedom to distribute copies of free software (and charge forthis service if you wish), that you receive source code or can get itif you want it, that you can change the software or use pieces of itin new free programs; and that you know you can do these things.  To protect your rights, we need to make restrictions that forbidanyone to deny you these rights or to ask you to surrender the rights.These restrictions translate to certain responsibilities for you if youdistribute copies of the software, or if you modify it.  For example, if you distribute copies of such a program, whethergratis or for a fee, you must give the recipients all the rights thatyou have.  You must make sure that they, too, receive or can get thesource code.  And you must show them these terms so they know theirrights.  We protect your rights with two steps: (1) copyright the software, and(2) offer you this license which gives you legal permission to copy,distribute and/or modify the software.  Also, for each author's protection and ours, we want to make certainthat everyone understands that there is no warranty for this freesoftware.  If the software is modified by someone else and passed on, wewant its recipients to know that what they have is not the original, sothat any problems introduced by others will not reflect on the originalauthors' reputations.  Finally, any free program is threatened constantly by softwarepatents.  We wish to avoid the danger that redistributors of a freeprogram will individually obtain patent licenses, in effect making theprogram proprietary.  To prevent this, we have made it clear that anypatent must be licensed for everyone's free use or not licensed at all.  The precise terms and conditions for copying, distribution andmodification follow.                    GNU GENERAL PUBLIC LICENSE   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION  0. This License applies to any program or other work which containsa notice placed by the copyright holder saying it may be distributedunder the terms of this General Public License.  The "Program", below,refers to any such program or work, and a "work based on the Program"means either the Program or any derivative work under copyright law:that is to say, a work containing the Program or a portion of it,either verbatim or with modifications and/or translated into anotherlanguage.  (Hereinafter, translation is included without limitation inthe term "modification".)  Each licensee is addressed as "you".Activities other than copying, distribution and modification are notcovered by this License; they are outside its scope.  The act ofrunning the Program is not restricted, and the output from the Programis covered only if its contents constitute a work based on theProgram (independent of having been made by running the Program).Whether that is true depends on what the Program does.  1. You may copy and distribute verbatim copies of the Program'ssource code as you receive it, in any medium, provided that youconspicuously and appropriately publish on each copy an appropriatecopyright notice and disclaimer of warranty; keep intact all thenotices that refer to this License and to the absence of any warranty;and give any other recipients of the Program a copy of this Licensealong with the Program.You may charge a fee for the physical act of transferring a copy, andyou may at your option offer warranty protection in exchange for a fee.  2. You may modify your copy or copies of the Program or any portionof it, thus forming a work based on the Program, and copy anddistribute such modifications or work under the terms of Section 1above, provided that you also meet all of these conditions:    a) You must cause the modified files to carry prominent notices    stating that you changed the files and the date of any change.    b) You must cause any work that you distribute or publish, that in    whole or in part contains or is derived from the Program or any    part thereof, to be licensed as a whole at no charge to all third    parties under the terms of this License.    c) If the modified program normally reads commands interactively    when run, you must cause it, when started running for such    interactive use in the most ordinary way, to print or display an    announcement including an appropriate copyright notice and a    notice that there is no warranty (or else, saying that you provide    a warranty) and that users may redistribute the program under    these conditions, and telling the user how to view a copy of this    License.  (Exception: if the Program itself is interactive but    does not normally print such an announcement, your work based on    the Program is not required to print an announcement.)These requirements apply to the modified work as a whole.  Ifidentifiable sections of that work are not derived from the Program,and can be reasonably considered independent and separate works inthemselves, then this License, and its terms, do not apply to thosesections when you distribute them as separate works.  But when youdistribute the same sections as part of a whole which is a work basedon the Program, the distribution of the whole must be on the terms ofthis License, whose permissions for other licensees extend to theentire whole, and thus to each and every part regardless of who wrote it.Thus, it is not the intent of this section to claim rights or contestyour rights to work written entirely by you; rather, the intent is toexercise the right to control the distribution of derivative orcollective works based on the Program.In addition, mere aggregation of another work not based on the Programwith the Program (or with a work based on the Program) on a volume ofa storage or distribution medium does not bring the other work underthe scope of this License.  3. You may copy and distribute the Program (or a work based on it,under Section 2) in object code or executable form under the terms ofSections 1 and 2 above provided that you also do one of the following:    a) Accompany it with the complete corresponding machine-readable    source code, which must be distributed under the terms of Sections    1 and 2 above on a medium customarily used for software interchange; or,    b) Accompany it with a written offer, valid for at least three    years, to give any third party, for a charge no more than your    cost of physically performing source distribution, a complete    machine-readable copy of the corresponding source code, to be    distributed under the terms of Sections 1 and 2 above on a medium    customarily used for software interchange; or,    c) Accompany it with the information you received as to the offer    to distribute corresponding source code.  (This alternative is    allowed only for noncommercial distribution and only if you    received the program in object code or executable form with such    an offer, in accord with Subsection b above.)The source code for a work means the preferred form of the work formaking modifications to it.  For an executable work, complete sourcecode means all the source code for all modules it contains, plus anyassociated interface definition files, plus the scripts used tocontrol compilation and installation of the executable.  However, as aspecial exception, the source code distributed need not includeanything that is normally distributed (in either source or binaryform) with the major components (compiler, kernel, and so on) of theoperating system on which the executable runs, unless that componentitself accompanies the executable.If distribution of executable or object code is made by offeringaccess to copy from a designated place, then offering equivalentaccess to copy the source code from the same place counts asdistribution of the source code, even though third parties are notcompelled to copy the source along with the object code.  4. You may not copy, modify, sublicense, or distribute the Programexcept as expressly provided under this License.  Any attemptotherwise to copy, modify, sublicense or distribute the Program isvoid, and will automatically terminate your rights under this License.However, parties who have received copies, or rights, from you underthis License will not have their licenses terminated so long as suchparties remain in full compliance.  5. You are not required to accept this License, since you have notsigned it.  However, nothing else grants you permission to modify ordistribute the Program or its derivative works.  These actions areprohibited by law if you do not accept this License.  Therefore, bymodifying or distributing the Program (or any work based on theProgram), you indicate your acceptance of this License to do so, andall its terms and conditions for copying, distributing or modifyingthe Program or works based on it.  6. Each time you redistribute the Program (or any work based on theProgram), the recipient automatically receives a license from theoriginal licensor to copy, distribute or modify the Program subject tothese terms and conditions.  You may not impose any furtherrestrictions on the recipients' exercise of the rights granted herein.You are not responsible for enforcing compliance by third parties tothis License.  7. If, as a consequence of a court judgment or allegation of patentinfringement or for any other reason (not limited to patent issues),conditions are imposed on you (whether by court order, agreement orotherwise) that contradict the conditions of this License, they do notexcuse you from the conditions of this License.  If you cannotdistribute so as to satisfy simultaneously your obligations under thisLicense and any other pertinent obligations, then as a consequence youmay not distribute the Program at all.  For example, if a patentlicense would not permit royalty-free redistribution of the Program byall those who receive copies directly or indirectly through you, thenthe only way you could satisfy both it and this License would be torefrain entirely from distribution of the Program.If any portion of this section is held invalid or unenforceable underany particular circumstance, the balance of the section is intended toapply and the section as a whole is intended to apply in othercircumstances.It is not the purpose of this section to induce you to infringe anypatents or other property right claims or to contest validity of anysuch claims; this section has the sole purpose of protecting theintegrity of the free software distribution system, which isimplemented by public license practices.  Many people have madegenerous contributions to the wide range of software distributedthrough that system in reliance on consistent application of thatsystem; it is up to the author/donor to decide if he or she is willingto distribute software through any other system and a licensee cannotimpose that choice.This section is intended to make thoroughly clear what is believed tobe a consequence of the rest of this License.  8. If the distribution and/or use of the Program is restricted incertain countries either by patents or by copyrighted interfaces, theoriginal copyright holder who places the Program under this Licensemay add an explicit geographical distribution limitation excludingthose countries, so that distribution is permitted only in or amongcountries not thus excluded.  In such case, this License incorporatesthe limitation as if written in the body of this License.  9. The Free Software Foundation may publish revised and/or new versionsof the General Public License from time to time.  Such new versions willbe similar in spirit to the present version, but may differ in detail toaddress new problems or concerns.Each version is given a distinguishing version number.  If the Programspecifies a version number of this License which applies to it and "anylater version", you have the option of following the terms and conditionseither of that version or of any later version published by the FreeSoftware Foundation.  If the Program does not specify a version number ofthis License, you may choose any version ever published by the Free SoftwareFoundation.  10. If you wish to incorporate parts of the Program into other freeprograms whose distribution conditions are different, write to the authorto ask for permission.  For software which is copyrighted by the FreeSoftware Foundation, write to the Free Software Foundation; we sometimesmake exceptions for this.  Our decision will be guided by the two goalsof preserving the free status of all derivatives of our free software andof promoting the sharing and reuse of software generally.                            NO WARRANTY  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTYFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHENOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIESPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSEDOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK ASTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THEPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,REPAIR OR CORRECTION.  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITINGWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/ORREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISINGOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITEDTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BYYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHERPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THEPOSSIBILITY OF SUCH DAMAGES.                     END OF TERMS AND CONDITIONS            How to Apply These Terms to Your New Programs  If you develop a new program, and you want it to be of the greatestpossible use to the public, the best way to achieve this is to make itfree software which everyone can redistribute and change under these terms.  To do so, attach the following notices to the program.  It is safestto attach them to the start of each source file to most effectivelyconvey the exclusion of warranty; and each file should have at leastthe "copyright" line and a pointer to where the full notice is found.    <one line to give the program's name and a brief idea of what it does.>    Copyright (C) <year>  <name of author>    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.Also add information on how to contact you by electronic and paper mail.If the program is interactive, make it output a short notice like thiswhen it starts in an interactive mode:    Gnomovision version 69, Copyright (C) year name of author    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.    This is free software, and you are welcome to redistribute it    under certain conditions; type `show c' for details.The hypothetical commands `show w' and `show c' should show the appropriateparts of the General Public License.  Of course, the commands you use maybe called something other than `show w' and `show c'; they could even bemouse-clicks or menu items- whatever suits your program.You should also get your employer (if you work as a programmer) or yourschool, if any, to sign a "copyright disclaimer" for the program, ifnecessary.  Here is a sample; alter the names:  Yoyodyne, Inc., hereby disclaims all copyright interest in the program  `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989  Ty Coon, President of ViceThis General Public License does not permit incorporating your program intoproprietary programs.  If your program is a subroutine library, you mayconsider it more useful to permit linking proprietary applications with thelibrary.  If this is what you want to do, use the GNU Lesser GeneralPublic License instead of this License.Comment: This package provides Smalltalk implementations of  Ward Cunningham's [Framework for Integrated Tests](http://fit.c2.com) and [Fitnesse](http://www.fitnesse.org).# Smalltalk FitSmalltalk Fit is a Smalltalk implementation of Ward Cunningham's [Framework for Integrated Tests](http://fit.c2.com), [Fitnesse](http://www.fitnesse.org), and Rick Mugridge's [FitLibrary](http://fitlibrary.sourceforge.net).This version contains the equivalent features of:* fit-java-1.1* fitnesse-20121220* FitLibrary-2.0# License   Copyright (C) 2004-2013 Randy Coulman    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.See the copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.I am using the GPL because this software is considered a derivative work of the original Fit and FitLibrary implementations in Java, and they are both licensed under the GPL, so I must use it.  The use of the GPL in Smalltalk is complicated, and I am not a lawyer.  My intention is that you may write Fit/FitLibrary tests for your software without causing your software to come under the terms of the GPL.  The test fixture code you write necessarily comes under the GPL, because it likely inherits from base classes provided in the library.  However, I consider there to be a "firewall" between the fixture code and the domain code as long as you keep them in separate packages.  I believe that this is consistent with the original Java implementation, where your domain code would be in a separate .jar file from your test fixture code.  If you have any questions about this, please contact me (see below for contact information).# IntroductionSmalltalk Fit's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).  Check there for the latest version.  It is also on [GitHub](https://github.com/randycoulman/SmalltalkFit).SmalltalkFit was developed in VW 7.9.1, but is compatible with VW 7.7 and later.  If you find any incompatibilities with VW 7.7 or later, let me know (see below for contact information) or file an issue on GitHub.# FitThe Java Fitnesse implementation has forked the Fit source code to add some enhancements.  Some of the changes are incompatible with the current Fit specification.  In particular, Fitnesse uses CSS to "annotate" table cells with colors and labels that indicate test status, whereas Fit uses embedded markup in the HTML.  Also, FItnesse allows much more flexibility in mapping fixture names in tables to fixture classes than the Fit spec allows.  In order to accommodate these differences, SmalltalkFit uses the Fit implementation when running the Fit batch test runner (see the `FileRunner` class), and uses the Fitnesse implementation when running the Fitnesse test server (see the `FitServer` class).# Usage## Running FitThe Fit batch test runner can be run from within a development image, or from a command line using a deployed image.To run from a development image, run the following in a workspace: 	Fit.FileRunner runInput: '<path to input filename>' output: '<path to output filename>'.To run from a deployed image, use a command line of the following form:	<visual> <image name> -fit <path to input filename> <path to output filename>where:* `<visual>` is the path to the VisualWorks VM executable you wish to use;* `<image name>` is the path to an image containing Fit and your Fixture classes;* `<path to input filename>` is the path to the html file containing the tests you want to run; and* `<path to output filename>` is the path to the html file that will contain the results of running the tests.Note that the image will immediately exit after running the tests.## Running FitnesseThe main Fitnesse application is written in Java.  It is necessary to get that running first.  Fitnesse uses language-specific implementations of FitServer to actually run the tests.  It is possible to run Smalltalk-based Fitnesse tests in either a development image or deployed image.### Running From a Development ImageFitnesse expects to launch an application that will connect back to it to retrieve the tests to run.  A development image is normally already running, so we have to fake out Fitnesse.  To do this:* Create an executable shell script or batch file called `fakeFitServer[.bat]`.  See `DevelopmentFitServer class>>exampleFitServerBat` or `exampleFitServerShellScript`.  This script must be somewhere in your path, or you must use a full pathname in your test pages.* Create a Fitnesse page as described in `DevelopmentFitServer class>>exampleFitnessePage`.* In a workspace, run:	FitDevelopmentSystem current filename: '/path/to/file/used/in/fakeFitServer/script' asFilename.	FitDevelopmentSystem activate.Once you have done this, the development Fit server will start when you load your image, stop when you exit, and also stop and re-start when you save your image.  If you want to keep this from happening, execute the following:	FitDevelopmentSystem canActivate: false.You can now run your tests from Fitnesse and they will run against the fixtures in your development image.### Running From a Deployed ImageTo run from a deployed image, define a `COMMAND_PATTERN` in your Fitnesse pages like this:	!define COMMAND_PATTERN {<visual> <image name> -fitnesse %m}where:* `<visual>` is the path to the VisualWorks VM executable you wish to use;* `<image name>` is the path to an image containing Fit and your Fixture classes;Fitnesse will append the necessary parameters at the end of the pattern.  If you use a batch file or shell script, make sure that those arguments are passed on to the application at the end of the command line.Note that the image will immediately exit after running the tests.# AcknowledgementsI inherited Smalltalk Fit from Dave Astels.  He had a mostly working port of Fit done.  I enhanced it and added Fitnesse and FitLibrary support.Alan Wostenberg devised the simple file-based scheme that is used for running tests against a development image.# ContributingI'm happy to receive bug fixes and improvements to this package.  Ifyou'd like to contribute, please publish your changes as a "branch"(non-integer) version in the Public Store Repository and contact me asoutlined below to let me know.  I will merge your changes back intothe "trunk" as soon as I can review them.# Contact InformationIf you have any questions about SmalltalkFit and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: nilDbTrace: nilDbUsername: DbVersion: DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Regex11' '') #(#any 'System-Announcements' ''))Namespace: Smalltalk.FitPackageName: FitParcel: #('Fit')ParcelName: FitPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Regex11') #(#name 'System-Announcements' #explicit true))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Regex11' '') #('System-Announcements' ''))PrintStringCache: nilVersion: Date: 3:37:38 PM January 23, 2016 --><time-stamp>From VisualWorks® Personal Use Edition, 8.0 of September 26, 2014 on January 23, 2016 at 3:37:38 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Fit</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Fit.Exceptions.*			</imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></name-space><name-space><name>Decorator</name><environment>Fit</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fit.Decorator.Util.*			private Fit.Decorator.Exceptions.*			</imports><category></category><attributes><package>Fit</package></attributes></name-space><name-space><name>Util</name><environment>Fit.Decorator</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fit.Decorator.Exceptions.*			</imports><category></category><attributes><package>Fit</package></attributes></name-space><name-space><name>Fitnesse</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			</imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></name-space><name-space><name>Fixtures</name><environment>Fitnesse</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fit.Exceptions.*			</imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></name-space><name-space><name>Exceptions</name><environment>Fit.Decorator</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Fit</package></attributes></name-space><name-space><name>Performance</name><environment>Fit.Decorator</environment><private>false</private><imports>			private Smalltalk.*			private Fit.Decorator.Util.*			private Fit.Decorator.Exceptions.*			private Fit.*			private Fit.Decorator.*			</imports><category></category><attributes><package>Fit</package></attributes></name-space><name-space><name>Exceptions</name><environment>Fit</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></name-space><class><name>TypeAdapter</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target field method type isRegex allowNil </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>RawStringTypeAdapter</name><environment>Fit</environment><super>Fit.TypeAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>GracefulNameState</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>Table</name><environment>Fit.Decorator.Util</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>Fixture</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>counts summary arguments listener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>TableFixture</name><environment>Fitnesse.Fixtures</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>Delta</name><environment>Fit.Decorator.Util</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataType value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>FitFailureException</name><environment>Fit.Exceptions</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>FixtureException</name><environment>Fit.Exceptions</environment><super>Fit.Exceptions.FitFailureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>NoSuchFixtureException</name><environment>Fit</environment><super>Fit.Exceptions.FixtureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit</package></attributes></class><class><name>NoSuchFitFixture</name><environment>Fit</environment><super>Fit.NoSuchFixtureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>StringTypeAdapter</name><environment>Fit</environment><super>Fit.TypeAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>FitSystem</name><environment>Fit</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>Markup</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>FitMarkup</name><environment>Fit</environment><super>Fit.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>ParseError</name><environment>Fit</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>DivideByZero</name><environment>Fit</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Tests</category><attributes><package>Fit</package></attributes></class><class><name>ColumnFixture</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columnBindings hasExecuted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>RowFixture</name><environment>Fit</environment><super>Fit.ColumnFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results missing surplus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>ArrayTypeAdapter</name><environment>Fit</environment><super>Fit.TypeAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>Parse</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leader tag body end trailer parts more </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>FitProtocol</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>FixtureDecorator</name><environment>Fit.Decorator</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>CopyAndAppendLastRow</name><environment>Fit.Decorator</environment><super>Fit.Decorator.FixtureDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numberOfTimes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>InvalidSignature</name><environment>Fit.Exceptions</environment><super>Fit.Exceptions.FitFailureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><comment><class-id>Fit.Exceptions.InvalidSignature</class-id><body>The following comment was copied from the original comments of Fit.Exceptions.NoSignature==========================================================The following comment was copied from the original comments of Fit.Exceptions.NoSuchFieldException==========================================================</body></comment><class><name>RunTime</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start elapsed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>InWordState</name><environment>Fit</environment><super>Fit.GracefulNameState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>DevelopmentFitServer</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>NoSuchFitnesseFixture</name><environment>Fit</environment><super>Fit.NoSuchFixtureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>TimeBasedFixtureDecorator</name><environment>Fit.Decorator.Performance</environment><super>Fit.Decorator.FixtureDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elapsedTime stopWatch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>MaxTime</name><environment>Fit.Decorator.Performance</environment><super>Fit.Decorator.Performance.TimeBasedFixtureDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maxTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>MethodSignature</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterAdapters resultAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>Fit</package></attributes></class><class><name>FitMatcherException</name><environment>Fit.Exceptions</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>ClassIsNotFixtureException</name><environment>Fit</environment><super>Fit.Exceptions.FixtureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>Binding</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>NullBinding</name><environment>Fit</environment><super>Fit.Binding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>ScientificDouble</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value precision </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>DelegateAdapter</name><environment>Fit</environment><super>Fit.TypeAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>Fit</package></attributes></class><class><name>NullFixtureListener</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit</package></attributes></class><class><name>Session</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>AbstractFitServer</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments outputStream socket socketOutput socketReader </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>TimeRange</name><environment>Fit.Decorator.Performance</environment><super>Fit.Decorator.Performance.TimeBasedFixtureDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>minTime maxTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>FitMatcher</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression parameter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>NoSuchMethodException</name><environment>Fit.Exceptions</environment><super>Fit.Exceptions.FitFailureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>SaveBinding</name><environment>Fit</environment><super>Fit.Binding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>Counts</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>right wrong ignores exceptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>InNumberState</name><environment>Fit</environment><super>Fit.GracefulNameState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>CouldNotParseException</name><environment>Fit.Exceptions</environment><super>Fit.Exceptions.FitFailureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>FitServerUsage</name><environment>Fit</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><comment><class-id>Fit.FitServerUsage</class-id><body>An error that is raised when a FitServer is called with invalid arguments.</body></comment><class><name>Summary</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>Void</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><comment><class-id>Fit.Void</class-id><body>Represents the concept of a Java void return type.</body></comment><class><name>FitServerArguments</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>verbose host port socketToken </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><comment><class-id>Fit.FitServerArguments</class-id><body>Parses and stores the command-line arguments passed to a FitServer.Instance Variables	host	&lt;String&gt;	The hostname of the computer where Fitnesse is running.	port	&lt;Integer&gt;	The port where Fitnesse is listening.	socketToken	&lt;String&gt;	The string token provided by Fitnesse for use when calling back.  This allows multiple FitServers to interact with Fitnesse without confusion.	verbose	&lt;Boolean&gt;	True if verbose output is desired; false otherwise.</body></comment><class><name>SetBinding</name><environment>Fit</environment><super>Fit.Binding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>OutOfWordState</name><environment>Fit</environment><super>Fit.GracefulNameState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>SessionEnding</name><environment>Fit</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit</package></attributes></class><class><name>ActionFixture</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parsedCells </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>FixtureLoader</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>DefaultTimer</name><environment>Fit.Decorator.Util</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>TimedActionFixture</name><environment>Fit</environment><super>Fit.ActionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>FitnesseFixtureLoader</name><environment>Fit</environment><super>Fit.FixtureLoader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fixturePathElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>QueryBinding</name><environment>Fit</environment><super>Fit.Binding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>NameConversion</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>PackageNameConversion</name><environment>Fit</environment><super>Fit.NameConversion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>FitDevelopmentSystem</name><environment>Fit</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename process </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>PrimitiveFixture</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>FitServer</name><environment>Fit</environment><super>Fit.AbstractFitServer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fixture counts fixtureListener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>GracefulNamer</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentState finalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>NoSuchFieldException</name><environment>Fit.Exceptions</environment><super>Fit.Exceptions.FitFailureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>FixtureName</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameAsString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>DataType</name><environment>Fit.Decorator.Util</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realType incrementerType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>RecallBinding</name><environment>Fit</environment><super>Fit.Binding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>ImportFixture</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>InvalidConnection</name><environment>Fit</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><comment><class-id>Fit.InvalidConnection</class-id><body>An Error that is raised when the connection back to Fitnesse cannot be validated.</body></comment><class><name>ShouldNotImplement</name><environment>Fit.Exceptions</environment><super>Fit.Exceptions.FixtureException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>FitFixtureLoader</name><environment>Fit</environment><super>Fit.FixtureLoader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>CellComparator</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result expected typeAdapter cell fixture </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>RegexQueryBinding</name><environment>Fit</environment><super>Fit.Binding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>Unparseable</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>Comment</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fitnesse</category><attributes><package>Fit</package></attributes></class><class><name>InvalidInputException</name><environment>Fit.Decorator.Exceptions</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>ClassNameConversion</name><environment>Fit</environment><super>Fit.NameConversion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>FileRunner</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input tables fixture output encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>IncrementColumnsValue</name><environment>Fit.Decorator</environment><super>Fit.Decorator.FixtureDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columnName delta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>FitnesseMarkup</name><environment>Fit</environment><super>Fit.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>Field</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>getSelector setSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit</category><attributes><package>Fit</package></attributes></class><class><name>Loop</name><environment>Fit.Decorator</environment><super>Fit.Decorator.FixtureDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><shared-variable><name>Symbols</name><environment>Fit.Fixture</environment><private>false</private><constant>false</constant><category>symbols</category><initializer>nil</initializer><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>Current</name><environment>Fit.Markup</environment><private>false</private><constant>false</constant><category>singleton</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>ParseDelegates</name><environment>Fit.TypeAdapter</environment><private>false</private><constant>false</constant><category>parse delegates</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>Actor</name><environment>Fit.ActionFixture</environment><private>false</private><constant>false</constant><category>private</category><initializer>nil</initializer><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>FootnoteCount</name><environment>Fit.Parse</environment><private>false</private><constant>false</constant><category>footnotes</category><initializer>nil</initializer><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>EscapeReplacements</name><environment>Fit.Parse</environment><private>false</private><constant>false</constant><category>uncategorized</category><initializer>nil</initializer><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>Cache</name><environment>Fit.MethodSignature</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>Current</name><environment>Fit.FixtureLoader</environment><private>false</private><constant>false</constant><category>singleton</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>ReferenceCount</name><environment>Fit.Session</environment><private>false</private><constant>false</constant><category>reference counting</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>MySubscriptions</name><environment>Fit.Session</environment><private>false</private><constant>false</constant><category>announcements</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>PredefinedTypes</name><environment>Fit.Decorator.Util.DataType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>StringType</name><environment>Fit.Decorator.Util.DataType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>DateType</name><environment>Fit.Decorator.Util.DataType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>IntegerType</name><environment>Fit.Decorator.Util.DataType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>DoubleType</name><environment>Fit.Decorator.Util.DataType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Fit</package></attributes></shared-variable><shared-variable><name>UserDefinedTypes</name><environment>Fit.Decorator.Util.DataType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Fit</package></attributes></shared-variable><methods><class-id>Fit.TypeAdapter</class-id> <category>accessing</category><body package="Fit">field	^field</body><body package="Fit">method	^method</body><body package="Fit">target: anObject 	target := anObject</body><body package="Fit">type	^type</body><body package="Fit">type: aClass	type := aClass</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>adapting</category><body package="Fit">fetch	"^target instVarAt: self fieldIndex"	^field getFrom: target</body><body package="Fit">get	field isNil ifFalse: [^self fetch].	method isNil ifFalse: [^self invoke]</body><body package="Fit">getAsString	^self toString: self get</body><body package="Fit">invoke	^target perform: method</body><body package="Fit">set: anObject 	"target instVarAt: self fieldIndex put: anObject"	field set: anObject in: target</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>converting</category><body package="Fit">asFitMethodSignature	^MethodSignature returning: self</body><body package="Fit">fitTypeAdapter	^self</body><body package="Fit">toString: anObject 	^anObject fitToString</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>initialize-release</category><body package="Fit">allowNil: aBoolean	allowNil := aBoolean</body><body package="Fit">initialize	super initialize.	isRegex := false.	allowNil := false</body><body package="Fit">isRegex: aBoolean	isRegex := aBoolean</body><body package="Fit">on: anObject field: aField 	target := anObject.	field := aField</body><body package="Fit">on: anObject method: aSymbol 	target := anObject.	method := aSymbol</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>comparing</category><body package="Fit">equals: a and: b	isRegex ifTrue: [^a fitToString asRegex matches: b fitToString].	a ifNil: [^b isNil].	^a = b</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>testing</category><body package="Fit">allowNil	^allowNil</body><body package="Fit">isForClass: aClass	^self type == aClass</body><body package="Fit">isRegex	^isRegex</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>parsing</category><body package="Fit">parse: aString	isRegex ifTrue: [^aString].	(self type respondsTo: #fitParse:) ifTrue: [^self type fitParse: aString].	^(CouldNotParseException input: aString expectedType: self type) raise</body></methods><methods><class-id>Fit.TypeAdapter class</class-id> <category>instance creation</category><body package="Fit">adapterFor: aClass	self parseDelegates at: aClass ifPresent: [:delegate | ^delegate copy].	^aClass fitTypeAdapter</body><body package="Fit">forClass: aClass	^(self adapterFor: aClass)		type: aClass;		yourself</body><body package="Fit">new	^super new initialize</body><body package="Fit">on: target field: aField	| signature |	signature := MethodSignature forField: aField in: target.	^(signature soleAdapter)		on: target field: aField;		yourself</body><body package="Fit">on: target method: aSymbol	^self on: target method: aSymbol isRegex: false</body><body package="Fit">on: target method: aSymbol isRegex: aBoolean	| signature adapter |	signature := MethodSignature forSelector: aSymbol in: target.	adapter := aSymbol numArgs isZero				ifTrue: [signature resultAdapter]				ifFalse: [signature parameterAdapterAt: 1].	(adapter isForClass: Void) ifTrue: [^self error: 'can''t yet adapt Void'].	^adapter		on: target method: aSymbol;		isRegex: aBoolean;		yourself</body></methods><methods><class-id>Fit.TypeAdapter class</class-id> <category>parseDelegates</category><body package="Fit">clearParseDelegates	ParseDelegates := nil</body><body package="Fit">initializeParseDelegates	ParseDelegates := Dictionary new.	Session when: SessionEnding send: #clearParseDelegates to: self</body><body package="Fit">parseDelegates	ParseDelegates ifNil: [self initializeParseDelegates].	^ParseDelegates</body><body package="Fit">registerParseDelegateClass: delegateClass forClass: aClass		[self parseDelegates at: aClass		put: (DelegateAdapter delegate: delegateClass)]			on: Error			do: 				[:ex |				^self error: 'Parse delegate class ' , delegateClass name							, ' does not have a suitable class-side #fitParse: method.']</body><body package="Fit">registerParseDelegateObject: anObject forClass: aClass	[self parseDelegates at: aClass put: (DelegateAdapter delegate: anObject)]		on: Error		do: 			[:ex |			^self error: 'Parse delegate object of class ' , anObject class name						, ' does not have a suitable #fitParse: method.']</body></methods><methods><class-id>Fit.RawStringTypeAdapter</class-id> <category>accessing</category><body package="Fit">type	^String</body></methods><methods><class-id>Fit.GracefulNameState</class-id> <category>rules</category><body package="Fit">digit: aCharacter</body><body package="Fit">letter: aCharacter</body><body package="Fit">other: aCharacter</body></methods><methods><class-id>Fit.GracefulNameState</class-id> <category>accessing</category><body package="Fit">context: anObject	context := anObject</body></methods><methods><class-id>Fit.GracefulNameState class</class-id> <category>instance creation</category><body package="Fit">context: anObject 	^self new context: anObject</body></methods><methods><class-id>Fit.Decorator.Util.Table</class-id> <category>private</category><body package="Fit">columnNotFound: aString		^InvalidInputException		raiseErrorString:			'"' , aString , '" was not found in the table ' , self asString</body><body package="Fit">copy: aParse andAppendTimes: anInteger		| columns nextColumn newNextColumn newColumn newRow |	anInteger		timesRepeat:			[columns := aParse parts.			nextColumn := columns more.			newNextColumn := self				newParseFrom: nextColumn				nextColumn: nextColumn more.			newColumn := self newParseFrom: columns nextColumn: newNextColumn.			newRow := Parse				tag: (self stripAngleBrackets: aParse tag)				body: aParse body				parts: newColumn				more: nil.			aParse last more: newRow]</body><body package="Fit">incrementValuesInColumn: aString by: aDelta headerRow: anInteger		| columnNumber columnToBeUpdated value |	columnNumber := self indexOfColumnContaining: aString inRow: anInteger.	anInteger + 2		to: self numberOfRows		do:			[:i | 			columnToBeUpdated := table at: 1 at: i at: columnNumber.			value := columnToBeUpdated text.			value := aDelta				addTo: value				repeat: i - anInteger - 1.			columnToBeUpdated body: value]</body><body package="Fit">indexOfColumnContaining: aString inRow: anInteger		| columns |	columns := table at: 1 at: anInteger at: 1.	1		to: columns size		do: [:i | (table at: 1 at: anInteger at: i) text = aString ifTrue: [^i]].	^self columnNotFound: aString</body><body package="Fit">indexOfRowContaining: aString		| rows |	rows := table at: 1 at: 1.	1		to: rows size		do:			[:i | 			| columns |			columns := table at: 1 at: i at: 1.			1				to: columns size				do: [:j | (table at: 1 at: i at: j) text = aString ifTrue: [^i]]].	^self columnNotFound: aString</body><body package="Fit">lastRow		^table parts last</body><body package="Fit">newParseFrom: aParse nextColumn: anotherParse		^Parse		tag: (self stripAngleBrackets: aParse tag)		body: aParse body		parts: aParse parts		more: anotherParse</body><body package="Fit">numberOfRows		^table parts size</body><body package="Fit">secondLastRow: lastRowParse		| nextRow currentRow |	nextRow := table parts.	currentRow := nil.	[nextRow = lastRowParse]		whileFalse:			[currentRow := nextRow.			nextRow := nextRow more].	currentRow more: nil.	^currentRow</body><body package="Fit">stripAngleBrackets: aString		^aString		copyFrom: 2		to: aString size - 1</body><body package="Fit">tableHasMoreThanTwoRows		^table parts size &gt; 2</body><body package="Fit">write: aParse on: ws		aParse parts		ifNil: [self writeLeaf: aParse on: ws]		ifNotNil: [self writeParts: aParse on: ws].	self writeMore: aParse on: ws</body><body package="Fit">writeLeaf: aParse on: ws		ws		nextPutAll: aParse tag;		nextPutAll: aParse text;		nextPutAll: aParse end</body><body package="Fit">writeMore: aParse on: ws		aParse more ifNil: [^self].	self		write: aParse more		on: ws</body><body package="Fit">writeParts: aParse on: ws		ws nextPutAll: aParse tag.	self		write: aParse parts		on: ws.	ws nextPutAll: aParse end</body></methods><methods><class-id>Fit.Decorator.Util.Table</class-id> <category>operations</category><body package="Fit">copyAndAppendLastRow: anInteger		| lastRow secondLastRow |	anInteger &gt; 0 ifFalse: [^self].	self tableHasMoreThanTwoRows ifFalse: [^self].	lastRow := self lastRow.	secondLastRow := self secondLastRow: lastRow.	self copy: lastRow andAppendTimes: anInteger.	secondLastRow more: lastRow</body><body package="Fit">incrementValuesInColumn: aString by: aDelta		| headerRowIndex |	headerRowIndex := self indexOfRowContaining: aString.	self incrementValuesInColumn: aString by: aDelta headerRow: headerRowIndex.	^table</body><body package="Fit">insertAsFirstRow: aParse		aParse more: table parts.	table parts: aParse</body><body package="Fit">stripFirstRow		| firstRow |	firstRow := table parts.	table parts: table parts more.	^firstRow</body></methods><methods><class-id>Fit.Decorator.Util.Table</class-id> <category>converting</category><body package="Fit">asString		| ws |	ws := (String new: 100) writeStream.	self write: table on: ws.	^ws contents</body></methods><methods><class-id>Fit.Decorator.Util.Table</class-id> <category>accessing</category><body package="Fit">table: aParse		table := aParse</body></methods><methods><class-id>Fit.Decorator.Util.Table class</class-id> <category>instance creation</category><body package="Fit">fromParse: aParse		^self new table: aParse</body><body package="Fit">fromString: aString		^self fromParse: (Parse input: aString)</body></methods><methods><class-id>Fit.Fixture</class-id> <category>enumerating</category><body package="Fit">doCell: cell at: columnIndex 	self ignore: cell</body><body package="Fit">doCells: cells 	| index |	index := 1.	cells do: 			[:each | 			[self doCell: each at: index] on: Error				do: [:ex | self mark: each exception: ex].			index := index + 1]</body><body package="Fit">doRow: row 	self doCells: row parts</body><body package="Fit">doRows: rows 	rows ifNotNil: [rows do: [:each | self doRow: each]]</body><body package="Fit">doTable: table	self doRows: table parts more</body><body package="Fit">doTables: tables 	summary at: 'run date' put: Timestamp now.	summary at: 'run elapsed time' put: RunTime new.	tables ifNotNil: 			[| fixtureName |			fixtureName := self fixtureNameCell: tables.			fixtureName ifNotNil: 					[					[| fixture |					fixture := self linkedFixtureWithArgs: tables.					fixture listener: listener.					fixture interpretTables: tables] 							on: Error							do: 								[:ex | 								self mark: fixtureName exception: ex.								self interpretFollowingTables: tables]]].	listener tablesFinished: counts.	self class clearSymbols</body></methods><methods><class-id>Fit.Fixture</class-id> <category>accessing</category><body package="Fit">arguments	^arguments copy</body><body package="Fit">counts	^counts</body><body package="Fit">counts: anObject	counts := anObject</body><body package="Fit">fixtureNameCell: aParse 	^aParse 		at: 1		at: 1		at: 1</body><body package="Fit">listener: anObject 	listener := anObject ifNil: [NullFixtureListener new]</body><body package="Fit">summary	^summary</body><body package="Fit">summary: anObject	summary := anObject</body><body package="Fit">targetClass	^self class</body></methods><methods><class-id>Fit.Fixture</class-id> <category>annotation</category><body package="Fit">basicError: aParse text: aString 	Markup markError: aParse.	aParse addToBody: aString.	counts incrementExceptions</body><body package="Fit">error: aParse text: aString 	self basicError: aParse text: (self formatError: (self escape: aString))</body><body package="Fit">escape: aString 	^self class escape: aString</body><body package="Fit">formatError: aString 	^Markup formatError: aString</body><body package="Fit">formatFriendlyError: aString 	^Markup formatFriendlyError: aString</body><body package="Fit">friendlyError: aParse text: aString 	self basicError: aParse		text: (self formatFriendlyError: (self escape: aString))</body><body package="Fit">ignore: cell 	Markup ignore: cell.	counts incrementIgnores</body><body package="Fit">info: aString 	^Markup info: aString</body><body package="Fit">info: aParse text: aString 	aParse addToBody: (self info: aString)</body><body package="Fit">label: aString 	^Markup label: aString</body><body package="Fit">mark: aParse exception: anError	(self isFriendlyException: anError)		ifTrue: [self friendlyError: aParse text: anError errorString]		ifFalse: 			[| stackTrace aString |			stackTrace := anError initialContext						ifNil: ['no stack available']						ifNotNil: #fitStackTrace.			aString := '&lt;1s&gt;&lt;n&gt;&lt;2s&gt;' expandMacrosWith: anError errorString						with: stackTrace.			self error: aParse text: aString]</body><body package="Fit">mark: aParse right: aBoolean 	aBoolean ifTrue: [self right: aParse] ifFalse: [self wrong: aParse]</body><body package="Fit">mark: aParse right: aBoolean actual: anObject 	aBoolean 		ifTrue: [self right: aParse]		ifFalse: [self wrong: aParse actual: anObject]</body><body package="Fit">right: cell 	Markup right: cell.	counts incrementRight</body><body package="Fit">wrong: cell 	Markup wrong: cell.	counts incrementWrong</body><body package="Fit">wrong: cell actual: aString 	self wrong: cell.	cell 		addToBody: (self label: 'expected') , '&lt;hr&gt;' , (self escape: aString) 				, (self label: 'actual')</body></methods><methods><class-id>Fit.Fixture</class-id> <category>comparing</category><body package="Fit">check: cell adapter: columnAdapter 	| text |	text := cell text.	text isEmpty 		ifTrue: [self handleBlankCell: cell adapter: columnAdapter]		ifFalse: 			[columnAdapter isNil 				ifTrue: [self ignore: cell]				ifFalse: 					[text = 'error' 						ifTrue: [self handleErrorInCell: cell adapter: columnAdapter]						ifFalse: [self compareCellToResult: cell adapter: columnAdapter]]]</body><body package="Fit">compareCellToResult: cell adapter: columnAdapter 	CellComparator new 		compareCellToResult: cell		adapter: columnAdapter		for: self</body><body package="Fit">handleBlankCell: cell adapter: columnAdapter 	self info: cell		text: ([columnAdapter toString: columnAdapter get] on: Error				do: [:ex | 'error'])</body><body package="Fit">handleErrorInCell: cell adapter: columnAdapter 	| result |		[result := columnAdapter invoke.	self wrong: cell actual: (columnAdapter toString: result)] 			on: Error			do: [:ex | self right: cell]</body></methods><methods><class-id>Fit.Fixture</class-id> <category>private</category><body package="Fit">camelCase: aString 	^self class camelCase: aString</body><body package="Fit">interpretFollowingTables: aParse 	| tables |	listener tableFinished: aParse.	tables := aParse more.	tables ifNil: [^self].	tables do: 			[:each | 			| fixtureName |			fixtureName := self fixtureNameCell: each.			fixtureName ifNotNil: 					[					[| fixture |					fixture := self linkedFixtureWithArgs: each.					fixture doTable: each] 							on: Error							do: [:ex | self mark: fixtureName exception: ex]].			listener tableFinished: each]</body><body package="Fit">interpretTables: tables 		[self extractArgumentsForTable: tables.	self doTable: tables] on: Error			do: 				[:ex | 				self mark: (self fixtureNameCell: tables) exception: ex.				listener tableFinished: tables.				^self].	self interpretFollowingTables: tables</body><body package="Fit">isFriendlyException: anException 	^anException isKindOf: FitFailureException</body><body package="Fit">linkedFixtureWithArgs: tables 	| header fixture |	header := self fixtureNameCell: tables.	fixture := self loadFixture: header text.	fixture counts: counts.	fixture summary: summary.	fixture extractArgumentsForTable: tables.	^fixture</body><body package="Fit">loadFixture: aString 	^FixtureLoader load: aString</body></methods><methods><class-id>Fit.Fixture</class-id> <category>parsing</category><body package="Fit">extractArgumentsForTable: aParse 	| parameters |	parameters := aParse parts parts more.	arguments := OrderedCollection new.	parameters ifNotNil: [parameters do: [:each | arguments add: each text]]</body></methods><methods><class-id>Fit.Fixture</class-id> <category>initialize-release</category><body package="Fit">initialize	counts := Counts new.	summary := Dictionary new.	self listener: nil</body></methods><methods><class-id>Fit.Fixture</class-id> <category>type access</category><body package="Fit">signatureFor: aSymbol	^nil</body></methods><methods><class-id>Fit.Fixture class</class-id> <category>instance creation</category><body package="Fit">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Fit.Fixture class</class-id> <category>colors</category><body package="Fit">gray	^'#efefef'</body><body package="Fit">green	^'#cfffcf'</body><body package="Fit">red	^'#ffcfcf'</body><body package="Fit">yellow	^'#ffffcf'</body></methods><methods><class-id>Fit.Fixture class</class-id> <category>utilities</category><body package="Fit">camelCase: aString	aString isEmpty ifTrue: [^aString].	^(self mergeWordsIn: aString) fitLowercaseFirst</body><body package="Fit">escape: aString 	| result |	result := aString.	self replacements 		do: [:each | result := result copyReplaceAll: each key with: each value].	^result</body><body package="Fit">instantiate: aClass 	| instance fixtureClassName |	fixtureClassName := aClass fullName.	"This is an ugly hack to make the FitLibrary specs pass.  I don''t expect it to have much practical value, and I hope it won't bite anyone"	(aClass class whichCategoryIncludesSelector: #new) == #private 		ifTrue: [^self error: '#new is private'].	instance := aClass new.	(instance isKindOf: Fixture) 		ifFalse: [^(ClassIsNotFixtureException className: fixtureClassName) raise].	^instance</body><body package="Fit">mergeWordsIn: aString 	| ws |	ws := WriteStream on: (String new: aString size).	(aString runsFailing: [:each | each isSeparator]) 		do: [:eachWord | ws nextPutAll: eachWord fitUppercaseFirst].	^ws contents</body></methods><methods><class-id>Fit.Fixture class</class-id> <category>private</category><body package="Fit">replacements	| cr lf |	cr := String with: Character cr.	lf := String with: Character lf.	^(OrderedCollection new)		add: '&amp;' -&gt; '&amp;amp;';		add: '&lt;' -&gt; '&amp;lt;';		add: '  ' -&gt; ' &amp;nbsp;';		add: (cr , lf) -&gt; '&lt;br /&gt;';		add: cr -&gt; '&lt;br /&gt;';		add: lf -&gt; '&lt;br /&gt;';		yourself</body></methods><methods><class-id>Fit.Fixture class</class-id> <category>symbols</category><body package="Fit">clearSymbols	^Symbols := nil</body><body package="Fit">clearSymbolsAtEndOfSession	^Session 		when: SessionEnding		do: [self clearSymbols]		for: self</body><body package="Fit">hasSymbol: aString	^self symbols includesKey: aString</body><body package="Fit">initializeSymbols	Symbols := Dictionary new.	self clearSymbolsAtEndOfSession</body><body package="Fit">symbolAt: aString 	^self symbols at: aString ifAbsent: [nil]</body><body package="Fit">symbolAt: aString put: anObject	^self symbols at: aString put: (anObject ifNil: ['null'])</body><body package="Fit">symbols	Symbols ifNil: [self initializeSymbols].	^Symbols</body></methods><methods><class-id>Fitnesse.Fixtures.TableFixture</class-id> <category>accessing</category><body package="Fit">cellAt: aPoint 	^firstRow at: aPoint y at: aPoint x</body><body package="Fit">textAt: aPoint 	^(self cellAt: aPoint) text</body></methods><methods><class-id>Fitnesse.Fixtures.TableFixture</class-id> <category>markup</category><body package="Fit">rightAt: aPoint 	self right: (self cellAt: aPoint)</body><body package="Fit">wrongAt: aPoint actual: aString 	self wrong: (self cellAt: aPoint) actual: aString</body></methods><methods><class-id>Fitnesse.Fixtures.TableFixture</class-id> <category>enumerating</category><body package="Fit">doRows: aParse 	firstRow := aParse.	aParse ifNil: 			[^(FitFailureException messageText: 'There are no rows in this table') 				raise].	self doStaticTable: aParse size</body><body package="Fit">doStaticTable: anInteger 	^self subclassResponsibility</body></methods><methods><class-id>Fit.Decorator.Util.Delta</class-id> <category>comparing</category><body package="Fit">= aDelta		self == aDelta ifTrue: [^true].	aDelta ifNil: [^false].	self class == aDelta class ifFalse: [^false].	^dataType = aDelta dataType and: [value = aDelta value]</body></methods><methods><class-id>Fit.Decorator.Util.Delta</class-id> <category>printing</category><body package="Fit">printOn: aStream		dataType printOn: aStream.	aStream		nextPutAll: ' and value = ';		nextPutAll: value fitToString</body></methods><methods><class-id>Fit.Decorator.Util.Delta</class-id> <category>initialize-release</category><body package="Fit">setType: typeString value: valueString		dataType := DataType instance: typeString.	value := dataType fitParse: valueString</body></methods><methods><class-id>Fit.Decorator.Util.Delta</class-id> <category>operations</category><body package="Fit">addTo: aString repeat: anInteger		^dataType add: value to: aString repeat: anInteger</body></methods><methods><class-id>Fit.Decorator.Util.Delta</class-id> <category>accessing</category><body package="Fit">dataType		^dataType</body><body package="Fit">value		^value</body></methods><methods><class-id>Fit.Decorator.Util.Delta class</class-id> <category>instance creation</category><body package="Fit">type: typeString value: valueString		^self new setType: typeString value: valueString</body></methods><methods><class-id>Fit.Exceptions.FitFailureException class</class-id> <category>instance creation</category><body package="Fit">messageText: aString 	^self newException messageText: aString</body></methods><methods><class-id>Fit.Exceptions.FixtureException class</class-id> <category>instance creation</category><body package="Fit">format: aString with: fixtureName 	^self messageText: (aString expandMacrosWith: fixtureName)</body></methods><methods><class-id>Fit.NoSuchFitFixture class</class-id> <category>instance creation</category><body package="Fit">named: aString 	^self format: 'The fixture "&lt;1s&gt;" was not found.' with: aString</body></methods><methods><class-id>Fit.StringTypeAdapter</class-id> <category>accessing</category><body package="Fit">type	^String</body></methods><methods><class-id>Fit.StringTypeAdapter</class-id> <category>parsing</category><body package="Fit">parse: aString 	aString asLowercase = 'null' ifTrue: [^nil].	aString asLowercase = 'blank' ifTrue: [^String new].	^String fitParse: aString</body></methods><methods><class-id>Fit.StringTypeAdapter</class-id> <category>converting</category><body package="Fit">toString: aString 	aString ifNil: [^'null'].	aString isEmpty ifTrue: [^'blank'].	^super toString: aString</body></methods><methods><class-id>Fit.Markup</class-id> <category>annotation</category><body package="Fit">formatError: aString 	^self subclassResponsibility</body><body package="Fit">formatFriendlyError: aString 	^'&lt;hr/&gt;' , (self label: aString)</body><body package="Fit">ignore: aParse 	^self subclassResponsibility</body><body package="Fit">info: aParse 	^self subclassResponsibility</body><body package="Fit">label: aString 	^self subclassResponsibility</body><body package="Fit">markError: aParse 	^self subclassResponsibility</body><body package="Fit">right: aParse 	^self subclassResponsibility</body><body package="Fit">textFromParse: aParse	^self subclassResponsibility</body><body package="Fit">wrong: aParse 	^self subclassResponsibility</body></methods><methods><class-id>Fit.Markup class</class-id> <category>annotation</category><body package="Fit">formatError: aString 	^self current formatError: aString</body><body package="Fit">formatFriendlyError: aString 	^self current formatFriendlyError: aString</body><body package="Fit">ignore: aParse 	self current ignore: aParse</body><body package="Fit">info: aParse 	^self current info: aParse</body><body package="Fit">label: aString 	^self current label: aString</body><body package="Fit">markError: aParse 	^self current markError: aParse</body><body package="Fit">right: aParse 	self current right: aParse</body><body package="Fit">textFromParse: aParse	^self current textFromParse: aParse</body><body package="Fit">wrong: aParse 	self current wrong: aParse</body></methods><methods><class-id>Fit.Markup class</class-id> <category>singleton</category><body package="Fit">current	^Current</body><body package="Fit">current: aMarkup 	Current := aMarkup</body><body package="Fit">reset	Current := nil</body></methods><methods><class-id>Fit.Markup class</class-id> <category>variants</category><body package="Fit">useFit	self current: FitMarkup new</body><body package="Fit">useFitnesse	self current: FitnesseMarkup new</body></methods><methods><class-id>Fit.FitMarkup</class-id> <category>annotation</category><body package="Fit">formatError: aString 	^'&lt;hr&gt;&lt;pre&gt;' , aString , '&lt;/pre&gt;'</body><body package="Fit">ignore: aParse 	aParse addToTag: ' bgcolor="' , self class gray , '"'</body><body package="Fit">info: aString 	^' &lt;font color="#808080"&gt;' , (Fixture escape: aString) , '&lt;/font&gt;'</body><body package="Fit">label: aString 	^' &lt;font size=-1 color="#c08080"&gt;&lt;i&gt;' , aString , '&lt;/i&gt;&lt;/font&gt;'</body><body package="Fit">markError: aParse 	aParse body: (Fixture escape: aParse text).	aParse addToTag: ' bgcolor="' , self class yellow , '"'</body><body package="Fit">right: aParse	aParse addToTag: ' bgcolor="' , self class green , '"'.</body><body package="Fit">textFromParse: aParse	^aParse fitText</body><body package="Fit">wrong: aParse 	aParse addToTag: ' bgcolor="' , self class red , '"'.	aParse body ifNotNil: [aParse body: (Fixture escape: aParse text)]</body></methods><methods><class-id>Fit.FitMarkup class</class-id> <category>constants</category><body package="Fit">gray	^'#efefef'</body><body package="Fit">green	^'#cfffcf'</body><body package="Fit">red	^'#ffcfcf'</body><body package="Fit">yellow	^'#ffffcf'</body></methods><methods><class-id>Fit.ParseError</class-id> <category>accessing</category><body package="Fit">errorOffset	^self parameter</body></methods><methods><class-id>Fit.DivideByZero</class-id> <category>double dispatching</category><body package="Fit">equalFromInteger: anInteger 	^false</body></methods><methods><class-id>Fit.DivideByZero</class-id> <category>comparing</category><body package="Fit">= aNumber 	^false</body></methods><methods><class-id>Fit.DivideByZero</class-id> <category>printing</category><body package="Fit">printOn: aStream 	aStream nextPutAll: 'Infinity'</body></methods><methods><class-id>Fit.DivideByZero class</class-id> <category>instance creation</category><body package="Fit">new	^self basicNew</body></methods><methods><class-id>Fit.ColumnFixture</class-id> <category>initialize-release</category><body package="Fit">initialize	super initialize.	hasExecuted := false</body></methods><methods><class-id>Fit.ColumnFixture</class-id> <category>accessing</category><body package="Fit">columnBindings	^columnBindings</body><body package="Fit">columnBindings: anObject	columnBindings := anObject</body></methods><methods><class-id>Fit.ColumnFixture</class-id> <category>operations</category><body package="Fit">execute</body><body package="Fit">reset</body></methods><methods><class-id>Fit.ColumnFixture</class-id> <category>enumerating</category><body package="Fit">doCell: cell at: columnInteger 	[(columnBindings at: columnInteger) doCell: cell fixture: self] on: Error		do: [:ex | self mark: cell exception: ex]</body><body package="Fit">doRow: row 	hasExecuted := false.		[self reset.	super doRow: row.	self executeIfNeeded] on: Error			do: [:ex | self mark: row leaf exception: ex]</body><body package="Fit">doRows: rows 	self bind: rows parts.	super doRows: rows more</body></methods><methods><class-id>Fit.ColumnFixture</class-id> <category>private</category><body package="Fit">bind: heads	| headsIterator |	columnBindings := OrderedCollection new.	headsIterator := heads.		[[headsIterator isNil] whileFalse: 			[| name |			name := headsIterator text.			columnBindings add: (self bindColumn: name).			headsIterator := headsIterator more]]			on: Error			do: [:ex | self mark: headsIterator exception: ex]</body><body package="Fit">bindColumn: columnHeading 	^Binding createOn: self for: columnHeading</body><body package="Fit">executeIfNeeded	hasExecuted 		ifFalse: 			[hasExecuted := true.			self execute]</body></methods><methods><class-id>Fit.ColumnFixture</class-id> <category>comparing</category><body package="Fit">check: cell adapter: columnAdapter 	[self executeIfNeeded] on: Error		do: [:ex | self mark: cell exception: ex].	super check: cell adapter: columnAdapter</body></methods><methods><class-id>Fit.RowFixture</class-id> <category>abstracts</category><body package="Fit">query	self subclassResponsibility</body></methods><methods><class-id>Fit.RowFixture</class-id> <category>initialize-release</category><body package="Fit">initialize	super initialize.	results := OrderedCollection new.	missing := OrderedCollection new.	surplus := OrderedCollection new</body></methods><methods><class-id>Fit.RowFixture</class-id> <category>accessing</category><body package="Fit">missing	^missing</body><body package="Fit">surplus	^surplus</body><body package="Fit">targetClass	self subclassResponsibility</body></methods><methods><class-id>Fit.RowFixture</class-id> <category>private</category><body package="Fit">bin: map withKey: key inRow: row 	(map at: key ifAbsentPut: [OrderedCollection new]) add: row</body><body package="Fit">buildCells: row 	| nilParse root |	row ifNil: 			[nilParse := Parse td: 'nil'.			nilParse addToTag: ' colspan=' , self columnBindings size printString.			^nilParse].	root := Parse new.	self columnBindings inject: root		into: 			[:next :binding | 			| adapter |			next more: (Parse td: '&amp;nbsp;').			adapter := binding adapter.			adapter ifNil: [self ignore: next more]				ifNotNil: 					[					[adapter target: row.					"fit-java-1.1 uses self info: next more body: ... instead, but that breaks the FitLibrary specs"					next more body: (self info: (self escape: adapter getAsString)).					self] 							on: Error							do: [:ex | self mark: next more exception: ex]].			next more].	^root more</body><body package="Fit">buildRows: rows 	| root |	root := Parse new.	rows inject: root		into: 			[:next :row | 			next more: (Parse trWithCells: (self buildCells: row)).			next more].	^root more</body><body package="Fit">check: eList against: cList 	| row cell obj |	eList isEmpty ifTrue: [^surplus addAll: cList].	cList isEmpty ifTrue: [^missing addAll: eList].	row := eList removeFirst.	cell := row parts.	obj := cList removeFirst.	self columnBindings do: 			[:binding | 			cell ifNotNil: 					[| adapter |					adapter := binding adapter.					adapter ifNotNil: [adapter target: obj].					self check: cell adapter: adapter.					cell := cell more]].	self check: eList against: cList</body><body package="Fit">list: rows 	rows ifNil: [^OrderedCollection new].	^rows asOrderedCollection</body><body package="Fit">mark: rows as: message 	| annotation |	rows ifNil: [^self].	annotation := self label: message.	rows do: 			[:row | 			self wrong: row parts.			row parts addToBody: annotation]</body><body package="Fit">match: expected against: computed inColumn: columnNumber 	| expectedMap computedMap keys |	columnNumber &gt; self columnBindings size 		ifTrue: [self check: expected against: computed]		ifFalse: 			[(self columnBindings at: columnNumber) isNil 				ifTrue: 					[self 						match: expected						against: computed						inColumn: columnNumber + 1]				ifFalse: 					[expectedMap := self sortExpected: expected inColumn: columnNumber.					computedMap := self sortComputed: computed inColumn: columnNumber.					keys := expectedMap keys asSet.					keys addAll: computedMap keys.					keys do: 							[:theKey | 							| expectedList computedList |							expectedList := expectedMap at: theKey ifAbsent: [nil].							computedList := computedMap at: theKey ifAbsent: [nil].							expectedList isNil 								ifTrue: [surplus addAll: computedList]								ifFalse: 									[computedList isNil 										ifTrue: [missing addAll: expectedList]										ifFalse: 											[(expectedList size = 1 and: [computedList size = 1]) 												ifTrue: [self check: expectedList against: computedList]												ifFalse: 													[self 														match: expectedList														against: computedList														inColumn: columnNumber + 1]]]]]]</body><body package="Fit">sortComputed: computed inColumn: columnNumber 	| adapter |	adapter := (self columnBindings at: columnNumber) adapter.	^computed inject: Dictionary new		into: 			[:result :row | 						[| key |			adapter target: row.			key := adapter get.			self 				bin: result				withKey: key				inRow: row] 					on: Error					do: [:ex | surplus add: row].			result]</body><body package="Fit">sortExpected: expected inColumn: columnNumber 	| adapter |	adapter := (self columnBindings at: columnNumber) adapter.	^expected inject: Dictionary new		into: 			[:result :row | 			| cell |			cell := row parts at: columnNumber.						[| key |			key := adapter parse: cell text.			self 				bin: result				withKey: key				inRow: row] 					on: Error					do: 						[:ex | 						| rest |						self mark: cell exception: ex.						rest := cell more.						[rest isNil] whileFalse: 								[self ignore: rest.								rest := rest more]].			result]</body></methods><methods><class-id>Fit.RowFixture</class-id> <category>enumerating</category><body package="Fit">doRows: rows 	| last |		[self bind: rows parts.	results := self query.	self 		match: (self list: rows more)		against: (self list: results)		inColumn: 1.	last := rows last.	last more: (self buildRows: surplus).	self mark: last more as: 'surplus'.	self mark: missing as: 'missing'] 			on: Error			do: [:ex | self mark: rows leaf exception: ex]</body></methods><methods><class-id>Fit.RowFixture</class-id> <category>type access</category><body package="Fit">signatureFor: aSymbol	^MethodSignature forSelector: aSymbol in: self targetClass</body></methods><methods><class-id>Fit.ArrayTypeAdapter</class-id> <category>converting</category><body package="Fit">toString: aCollection 	| ws |	ws := WriteStream on: (String new: aCollection size * 5).	aCollection do: [:each | ws nextPutAll: (componentAdapter toString: each)]		separatedBy: [ws nextPutAll: ', '].	^ws contents</body></methods><methods><class-id>Fit.ArrayTypeAdapter</class-id> <category>accessing</category><body package="Fit">componentAdapter	^componentAdapter</body><body package="Fit">componentAdapters: aCollection	componentAdapter := aCollection any</body><body package="Fit">type	^Array</body></methods><methods><class-id>Fit.ArrayTypeAdapter</class-id> <category>parsing</category><body package="Fit">parse: aString	^Array withAll: ((aString runsFailing: [:each | each = $,])				collect: [:each | componentAdapter parse: each fitTrimSeparators])</body></methods><methods><class-id>Fit.Parse</class-id> <category>accessing</category><body package="Fit">at: index 	^(index = 1 or: [more isNil]) ifTrue: [self] ifFalse: [more at: index - 1]</body><body package="Fit">body	^body</body><body package="Fit">body: anObject	body := anObject</body><body package="Fit">end	^end</body><body package="Fit">end: anObject	end := anObject</body><body package="Fit">fitText	^self class htmlToText: body</body><body package="Fit">fitnesseText	^(self class unescape: (self class unformat: body)) fitTrimSeparators</body><body package="Fit">footnote	| thisFootnote html file output directory baseDir |	self class footnoteCount &gt;= 100 ifTrue: [^'[-]'].		[thisFootnote := self class nextFootnote.	html := ('footnotes' asFilename 				construct: thisFootnote printString , '.html') asString.	baseDir := 'examples' asFilename construct: 'output'.	directory := baseDir construct: 'footnotes'.	directory exists ifFalse: [directory makeDirectory].	file := baseDir construct: html.	file exists ifTrue: [file delete].	output := file writeStream.	self print: output.	output close.	^'&lt;a href=' , html , '&gt; [' , thisFootnote printString , ']&lt;/a&gt;'] 			on: Error			do: [:ex | ^'[!]']</body><body package="Fit">leader	^leader</body><body package="Fit">leader: anObject	leader := anObject</body><body package="Fit">more	^more</body><body package="Fit">more: anObject	more := anObject</body><body package="Fit">parts	^parts</body><body package="Fit">parts: anObject	parts := anObject</body><body package="Fit">size	^more isNil ifTrue: [1] ifFalse: [more size + 1]</body><body package="Fit">tag	^tag</body><body package="Fit">tag: anObject	tag := anObject</body><body package="Fit">text	^Markup textFromParse: self</body><body package="Fit">trailer	^trailer</body><body package="Fit">trailer: anObject	trailer := anObject</body></methods><methods><class-id>Fit.Parse</class-id> <category>annotation</category><body package="Fit">addToBody: aString 	body := body , aString</body><body package="Fit">addToTag: aString 	tag := (tag copyFrom: 1 to: tag size - 1) , aString , '&gt;'</body></methods><methods><class-id>Fit.Parse</class-id> <category>indexed accessing</category><body package="Fit">at: index1 at: index2 	^(self at: index1) parts at: index2</body><body package="Fit">at: index1 at: index2 at: index3 	^(self at: index1 at: index2) parts at: index3</body><body package="Fit">last	^more isNil ifTrue: [self] ifFalse: [more last]</body><body package="Fit">leaf	^parts isNil ifTrue: [self] ifFalse: [parts leaf]</body></methods><methods><class-id>Fit.Parse</class-id> <category>printing</category><body package="Fit">debugString	| ws |	ws := String new writeStream.	self print: ws.	^ws contents</body><body package="Fit">print: aStream 	aStream		nextPutAll: leader;		nextPutAll: tag.	parts notNil 		ifTrue: [parts print: aStream]		ifFalse: [aStream nextPutAll: body].	aStream nextPutAll: end.	more notNil 		ifTrue: [more print: aStream]		ifFalse: [aStream nextPutAll: trailer]</body></methods><methods><class-id>Fit.Parse</class-id> <category>initialize-release</category><body package="Fit">initialize	tag := ''</body><body package="Fit">input: text tags: tags level: level offset: offset 	| lc startTag endTag startEnd endEnd startMore |	lc := text asLowercase.	startTag := lc indexOfSubCollection: '&lt;' , (tags at: level) startingAt: 1.	endTag := startTag &gt; 0 				ifTrue: [(lc indexOfSubCollection: '&gt;' startingAt: startTag) + 1]				ifFalse: [0].	startEnd := endTag &gt; 0 				ifTrue: 					[self class 						findMatchingEndTagIn: lc						from: endTag						tag: (tags at: level)						startingAt: offset]				ifFalse: [0].	endEnd := startEnd &gt; 0 				ifTrue: [(lc indexOfSubCollection: '&gt;' startingAt: startEnd) + 1]				ifFalse: [0].	startMore := endEnd &gt; 0 				ifTrue: [lc indexOfSubCollection: '&lt;' , (tags at: level) startingAt: endEnd]				ifFalse: [0].	startTag &lt; 1 | (endTag &lt; 1) | (startEnd &lt; 1) | (endEnd &lt; 1) 		ifTrue: 			[self class parseSignal raiseWith: offset				errorString: 'Can''t find tag: ' , (tags at: level)].	leader := text copyFrom: 1 to: startTag - 1.	tag := text copyFrom: startTag to: endTag - 1.	body := text copyFrom: endTag to: startEnd - 1.	end := text copyFrom: startEnd to: endEnd - 1.	trailer := text copyFrom: endEnd to: text size.	level + 1 &lt;= tags size 		ifTrue: 			[parts := self class 						input: body						tags: tags						level: level + 1						offset: offset + endTag - 1.			body := nil]		ifFalse: 			["check for nested table"			| index |			index := body indexOfSubCollection: '&lt;' , tags first startingAt: 1.			index &gt; 0 				ifTrue: 					[parts := self class 								input: body								tags: tags								level: 1								offset: offset + endTag.					body := '']].	startMore &gt;= 1 ifFalse: [^self].	more := self class 				input: trailer				tags: tags				level: level				offset: offset + endTag - 1.	trailer := nil</body><body package="Fit">tag: aTag body: aBody parts: someParts more: someMore 	leader := '\' withCRs.	tag := '&lt;' , aTag , '&gt;'.	body := aBody.	end := '&lt;/' , aTag , '&gt;'.	trailer := ''.	parts := someParts.	more := someMore</body></methods><methods><class-id>Fit.Parse</class-id> <category>converting</category><body package="Fit">asOrderedCollection	| anOrderedCollection |	anOrderedCollection := OrderedCollection new.	self do: [:each | anOrderedCollection addLast: each].	^anOrderedCollection</body></methods><methods><class-id>Fit.Parse</class-id> <category>enumerating</category><body package="Fit">do: aBlock 	| next |	next := more.	"May be changed by aBlock"	aBlock value: self.	next notNil ifTrue: [next do: aBlock]</body></methods><methods><class-id>Fit.Parse</class-id> <category>comparing</category><body package="Fit">= anObject	self == anObject ifTrue: [^true].	(anObject isKindOf: self class) ifFalse: [^false].	tag = anObject tag ifFalse: [^false].	leader = anObject leader ifFalse: [^false].	body = anObject body ifFalse: [^false].	trailer = anObject trailer ifFalse: [^false].	more = anObject more ifFalse: [^false].	parts = anObject parts ifFalse: [^false].	^true</body></methods><methods><class-id>Fit.Parse class</class-id> <category>instance creation</category><body package="Fit">input: text 	^self input: text tags: #('table' 'tr' 'td')</body><body package="Fit">input: text tags: tags 	^self input: text tags: tags level: 1 offset: 1</body><body package="Fit">input: text tags: tags level: level offset: offset 	^self new input: text tags: tags level: level offset: offset</body><body package="Fit">new	^super new initialize</body><body package="Fit">tableWithRows: aParse 	^self 		tag: 'table'		body: nil		parts: aParse		more: nil</body><body package="Fit">tag: aTag body: aBody 	^self 		tag: aTag		body: aBody		parts: nil		more: nil</body><body package="Fit">tag: aTag body: aBody parts: someParts more: someMore 	^(self new)		tag: aTag			body: aBody			parts: someParts			more: someMore;		yourself</body><body package="Fit">td: aString 	^self td: aString more: nil</body><body package="Fit">td: aString more: aParse 	^self 		tag: 'td'		body: aString		parts: nil		more: aParse</body><body package="Fit">trWithCells: aParse 	^self trWithCells: aParse more: nil</body><body package="Fit">trWithCells: partsParse more: moreParse 	^self 		tag: 'tr'		body: nil		parts: partsParse		more: moreParse</body></methods><methods><class-id>Fit.Parse class</class-id> <category>Signal constants</category><body package="Fit">parseSignal	^ParseError</body></methods><methods><class-id>Fit.Parse class</class-id> <category>accessing</category><body package="Fit">escapeReplacements	^EscapeReplacements 		ifNil: [EscapeReplacements := self defaultEscapeReplacements]</body></methods><methods><class-id>Fit.Parse class</class-id> <category>class initialization</category><body package="Fit">initialize	"	Parse initialize		"	ParseError		notifierString: ('Can''t find tag: ');		nameClass: self message: #parseSignal.</body></methods><methods><class-id>Fit.Parse class</class-id> <category>utility</category><body package="Fit">condenseWhitespace: aString	| result nonBreakingSpace |	nonBreakingSpace := Character value: 160.	result := aString.	result := self replaceRegex: '\s+' with: ' ' in: result.	result := self				replaceCharacter: nonBreakingSpace				with: Character space				in: result.	result := self replaceString: '&amp;nbsp;' with: ' ' in: result.	^result fitTrimSeparators</body><body package="Fit">findMatchingEndTagIn: aString from: endTag tag: aTag startingAt: anInteger 	| fromHere count startEnd |	fromHere := endTag.	count := 1.	startEnd := 0.	[count &gt; 0] whileTrue: 			[| embeddedTag embeddedTagEnd |			embeddedTag := aString indexOfSubCollection: '&lt;' , aTag						startingAt: fromHere.			embeddedTagEnd := aString indexOfSubCollection: '&lt;/' , aTag						startingAt: fromHere.			(embeddedTag = 0 and: [embeddedTagEnd = 0]) 				ifTrue: 					[self parseSignal raiseWith: anInteger						errorString: 'Can''t find tag: ' , aTag].			embeddedTag = 0 ifTrue: [embeddedTag := 1000000000].			embeddedTagEnd = 0 ifTrue: [embeddedTag := 1000000000].			embeddedTag &lt; embeddedTagEnd 				ifTrue: 					[count := count + 1.					startEnd := embeddedTag.					fromHere := (aString indexOfSubCollection: '&gt;' startingAt: embeddedTag) 								+ 1]				ifFalse: 					[embeddedTagEnd &lt; embeddedTag 						ifTrue: 							[count := count - 1.							startEnd := embeddedTagEnd.							fromHere := (aString indexOfSubCollection: '&gt;' startingAt: embeddedTagEnd) 										+ 1]]].	^startEnd</body><body package="Fit">htmlToText: aString 	| result |	result := aString.	result := self normalizeLineBreaks: result.	result := self removeNonBreakTags: result.	result := self condenseWhitespace: result.	result := self unescape: result.	^result</body><body package="Fit">normalizeLineBreaks: aString 	| result |	result := aString.	result := self 				replaceRegex: '&lt;\s*br\s*/?\s*&gt;'				with: '&lt;br /&gt;'				in: result.	result := self 				replaceRegex: '&lt;\s*/\s*p\s*&gt;\s*&lt;\s*p( [^&gt;]*)?&gt;'				with: '&lt;br /&gt;'				in: result.	^result</body><body package="Fit">removeNonBreakTags: aString 	| i workingString j |	i := 1.	workingString := aString.		[(i := workingString 				nextIndexOf: $&lt;				from: i				to: workingString size) notNil] 			whileTrue: 				[(j := workingString 							nextIndexOf: $&gt;							from: i + 1							to: workingString size) notNil 					ifTrue: 						[(workingString copyFrom: i to: j) = '&lt;br /&gt;' 							ifFalse: 								[workingString := (workingString copyFrom: 1 to: i - 1) 											, (workingString copyFrom: j + 1 to: workingString size)]							ifTrue: [i := i + 1]]					ifFalse: [^workingString]].	^workingString</body><body package="Fit">unescape: aString 	| result |	result := aString.	result := self 				replaceString: '&lt;br /&gt;'				with: (String with: Character lf)				in: result.	result := self unescapeEntities: result.	result := self unescapeSmartQuotes: result.	^result</body><body package="Fit">unescapeEntities: aString 	| result |	result := aString.	self escapeReplacements do: 			[:each | 			result := self 						replaceString: each key						with: each value						in: result].	^result</body><body package="Fit">unescapeSmartQuotes: aString 	| result |	result := aString.	#(16r201C 16r201D 16r0093 16r0094) do: 			[:each | 			result := self 						replaceCharacter: (Character value: each)						with: $"						in: result].	#(16r2018 16r2019 16r0091 16r0092) do: 			[:each | 			result := self 						replaceCharacter: (Character value: each)						with: $'						in: result].	^result</body><body package="Fit">unformat: aString	^self replaceRegex: '&lt;[^&gt;]*&gt;' with: '' in: aString</body></methods><methods><class-id>Fit.Parse class</class-id> <category>private</category><body package="Fit">defaultEscapeReplacements	^(OrderedCollection new)		add: '&amp;lt;' -&gt; '&lt;';		add: '&amp;gt;' -&gt; '&gt;';		add: '&amp;nbsp;' -&gt; ' ';		add: '&amp;quot;' -&gt; '"';		add: '&amp;amp;' -&gt; '&amp;';		yourself</body><body package="Fit">replaceCharacter: aCharacter with: replacement in: aString 	^aString replaceAll: aCharacter with: replacement</body><body package="Fit">replaceRegex: regex with: replacement in: aString 	^aString copyWithRegex: regex matchesReplacedWith: replacement</body><body package="Fit">replaceString: pattern with: replacement in: aString 	^aString copyReplaceAll: pattern with: replacement</body></methods><methods><class-id>Fit.Parse class</class-id> <category>footnotes</category><body package="Fit">footnoteCount	FootnoteCount ifNil: [self initializeFootnoteCount].	^FootnoteCount</body><body package="Fit">footnoteCount: anInteger 	FootnoteCount := anInteger</body><body package="Fit">initializeFootnoteCount	FootnoteCount := 0.	self resetFootnotesAtSessionEnd</body><body package="Fit">nextFootnote	self footnoteCount: self footnoteCount + 1.	^self footnoteCount</body><body package="Fit">resetFootnotes	FootnoteCount := nil</body><body package="Fit">resetFootnotesAtSessionEnd	Session 		when: SessionEnding		do: [FootnoteCount := nil]		for: self</body></methods><methods><class-id>Fit.FitProtocol class</class-id> <category>reading</category><body package="Fit">readCountsFrom: anIOAccessor 	^(Counts new)		right: (self readSize: anIOAccessor);		wrong: (self readSize: anIOAccessor);		ignores: (self readSize: anIOAccessor);		exceptions: (self readSize: anIOAccessor);		yourself</body><body package="Fit">readDocumentFrom: anIOAccessor size: anInteger 	^self readFrom: anIOAccessor size: anInteger</body><body package="Fit">readFrom: anIOAccessor size: size 	| bytes |	bytes := ByteArray new: size.	anIOAccessor readInto: bytes untilFalse: [:count | true].	^bytes asStringEncoding: #'UTF-8'</body><body package="Fit">readSize: anIOAccessor 	^(self readFrom: anIOAccessor size: 10) asNumber</body></methods><methods><class-id>Fit.FitProtocol class</class-id> <category>utilities</category><body package="Fit">formatNumber: anInteger 	| ws |	ws := String new writeStream.	NumberPrintPolicy 		print: anInteger		on: ws		using: '0000000000'.	^ws contents</body></methods><methods><class-id>Fit.FitProtocol class</class-id> <category>writing</category><body package="Fit">write: aByteArray to: aWriteStream 	aWriteStream		nextPutAll: aByteArray;		commit</body><body package="Fit">writeBytes: aByteArray to: aWriteStream 	self writeSize: aByteArray size to: aWriteStream.	self write: aByteArray to: aWriteStream</body><body package="Fit">writeCounts: aCounts to: aWriteStream 	self writeSize: 0 to: aWriteStream.	self writeSize: aCounts right to: aWriteStream.	self writeSize: aCounts wrong to: aWriteStream.	self writeSize: aCounts ignores to: aWriteStream.	self writeSize: aCounts exceptions to: aWriteStream</body><body package="Fit">writeData: aString to: aWriteStream 	self writeBytes: (aString asByteArrayEncoding: #'UTF-8') to: aWriteStream</body><body package="Fit">writeSize: anInteger to: aWriteStream 	self write: (self formatNumber: anInteger) asByteArray to: aWriteStream</body></methods><methods><class-id>Fit.Decorator.FixtureDecorator</class-id> <category>private</category><body package="Fit">escapeExpectedAndActualString: aString		| index |	index := aString		findString: 'actual'		startingAt: 1		ifAbsent: [^aString].	^aString		copyFrom: 1		to: index - 1</body><body package="Fit">execute: aFixture table: aParse		| table firstRow |	table := Table fromParse: aParse.	firstRow := table stripFirstRow.	self run: aFixture table: aParse.	table insertAsFirstRow: firstRow.	self updateColumnsBasedOnResults: aParse</body><body package="Fit">loadFixture: aString fromParse: aParse		^[self loadFixture: aString]		on: Error		do:			[:ex | 			self mark: aParse exception: ex.			ex return: nil]</body><body package="Fit">run: aFixture table: aParse		aFixture doTable: aParse</body><body package="Fit">setAlternatingArgs: aParse		| columns |	columns := aParse parts parts.	arguments := (2		to: columns size		by: 2)		collect:			[:i | 			| columnValue |			columnValue := (columns at: i) text.			self escapeExpectedAndActualString: columnValue]</body><body package="Fit">setupDecorator: aCollection		^self subclassResponsibility</body><body package="Fit">updateColumnsBasedOnResults: aParse		^self subclassResponsibility</body><body package="Fit">validateDecoratorInput: aParse		self setAlternatingArgs: aParse.	[self setupDecorator: arguments]		on: InvalidInputException		do:			[:ex | 			self				mark: aParse parts parts				exception: ex]</body></methods><methods><class-id>Fit.Decorator.FixtureDecorator</class-id> <category>enumerating</category><body package="Fit">doTable: aParse		| actualHeader encapsulatedFixtureName fixture |	aParse parts more ifNil: [^self].	self validateDecoratorInput: aParse.	actualHeader := aParse parts more parts.	encapsulatedFixtureName := actualHeader text.	summary		at: self class encapsulatedFixtureNameKey		put: encapsulatedFixtureName.	fixture := (self loadFixture: encapsulatedFixtureName fromParse:			actualHeader) ifNil: [^self].	self execute: fixture table: aParse.	summary addAll: fixture summary associations.	counts tally: fixture counts</body></methods><methods><class-id>Fit.Decorator.FixtureDecorator class</class-id> <category>constants</category><body package="Fit">encapsulatedFixtureNameKey		^'EncapsulatedFixtureName'</body></methods><methods><class-id>Fit.Decorator.CopyAndAppendLastRow</class-id> <category>private</category><body package="Fit">run: aFixture table: aParse		| table |	table := Table fromParse: aParse.	table copyAndAppendLastRow: numberOfTimes.	super run: aFixture table: aParse</body><body package="Fit">setupDecorator: aCollection		aCollection size = 1		ifFalse:			[^InvalidInputException raiseErrorString:					'Count for number of times to add the last row must be specified'].	numberOfTimes := Number fitParse: aCollection first.	summary		at: self class numberOfTimesKey		put: numberOfTimes</body><body package="Fit">updateColumnsBasedOnResults: aParse	"Nothing to do"</body></methods><methods><class-id>Fit.Decorator.CopyAndAppendLastRow class</class-id> <category>constants</category><body package="Fit">numberOfTimesKey		^'numberOfTimes'</body></methods><methods><class-id>Fit.Exceptions.InvalidSignature class</class-id> <category>instance creation</category><body package="Fit">for: aSymbol	^self		messageText: 'An invalid method signature was provided for ' , aSymbol</body></methods><methods><class-id>Fit.RunTime</class-id> <category>initializing</category><body package="Fit">initialize	start := Time millisecondClockValue.	elapsed := 0</body></methods><methods><class-id>Fit.RunTime</class-id> <category>private</category><body package="Fit">d: scale 	| report |	report := elapsed // scale.	elapsed := elapsed - (report * scale).	^report printString</body></methods><methods><class-id>Fit.RunTime</class-id> <category>printing</category><body package="Fit">printOn: aStream 	| big |	elapsed := Time millisecondClockValue - start.	big := elapsed &gt; 600000.	big 		ifTrue: 			[aStream				nextPutAll: (self d: 3600000);				nextPut: $:;				nextPutAll: (self d: 600000)].	aStream		nextPutAll: (self d: 60000);		nextPut: $:;		nextPutAll: (self d: 10000);		nextPutAll: (self d: 1000).	big 		ifFalse: 			[aStream				nextPut: $.;				nextPutAll: (self d: 100);				nextPutAll: (self d: 10)]</body></methods><methods><class-id>Fit.RunTime class</class-id> <category>instance creation</category><body package="Fit">new	^self basicNew initialize</body></methods><methods><class-id>Fit.InWordState</class-id> <category>rules</category><body package="Fit">digit: aCharacter 	context		append: aCharacter;		nextState: InNumberState</body><body package="Fit">letter: aCharacter 	context append: aCharacter</body><body package="Fit">other: aCharacter 	context nextState: OutOfWordState</body></methods><methods><class-id>Fit.DevelopmentFitServer</class-id> <category>private</category><body package="Fit">loop	filename exists ifTrue: [filename delete].	[self loopBody] whileTrue.	Transcript		show: Time now printString , ' exit FitServer';		cr</body><body package="Fit">loopBody	| args serverClass |	self waitForFile: filename.		[args := self readArgumentsFromFile: filename.	args ifNil: [^false].	serverClass := (ClassNameConversion javaName: args removeFirst) classOrNil.	self runServer: serverClass withArguments: args]			ensure: [filename delete].	^true</body><body package="Fit">readArgumentsFromFile: aFilename 	| args |	args := self readArgumentsFromString: aFilename contentsOfEntireFile.	(args isEmpty or: [args first = 'exit']) ifTrue: [^nil].	^args</body><body package="Fit">readArgumentsFromString: aString 	| tokens |	tokens := aString runsFailing: [:each | each isSeparator].	^tokens select: [:each | each notEmpty]</body><body package="Fit">runServer: aClass withArguments: aCollection	| exitCodePromise |	exitCodePromise := [aClass new runWithArguments: aCollection]				promiseAt: Processor userBackgroundPriority.	^[exitCodePromise value] on: Promise terminateSignal		do: [:ex | ex return: 2]</body><body package="Fit">waitForFile: aFilename 	[aFilename exists] whileFalse: [(Delay forSeconds: 1) wait]</body></methods><methods><class-id>Fit.DevelopmentFitServer</class-id> <category>accessing</category><body package="Fit">filename: aFilename 	filename := aFilename</body></methods><methods><class-id>Fit.DevelopmentFitServer class</class-id> <category>examples</category><body package="Fit">exampleFitServerBat	"manually place this into \fitnesse\fakeFitServer.bat as described in package comment"	^'echo start smalltalk image	echo %1 %2 %3 %4 %5	echo &gt;Smalltalk.doit %1 %2 %3 %4 %5	echo off	:wait	echo wait	if exist Smalltalk.doit goto wait	exit'</body><body package="Fit">exampleFitServerShellScript	"manually place this into /usr/local/bin/fakeFitServer as described in package comment"	^'#!/bin/shFILE=/tmp/fakeFitServer.doitecho $* &gt; $FILEwhile [ -f $FILE ]do        sleep 1done'</body><body package="Fit">exampleFitnessePage	"manually place this in a page on your fitnesse wiki to set command path, as described in package comment"	^'#Use whichever of these two is appropriate for your platform:!define COMMAND_PATTERN {cmd /c start /min /low /wait fakeFitServer.bat %m}#!define COMMAND_PATTERN (fakeFitServer %m)# To use FitLibrary, uncomment the following line:# !define TEST_RUNNER {fitlibrary.suite.FitLibraryServer}!|Import||Fitnesse.Testutil|!|Comment||Testing a comment table|!|Pass|!|Fail||eg.Calculator||volts|watts?|points?||3.75| .500 | false ||3.60| 0.500 | false ||3.45| 0.500 | false |'</body></methods><methods><class-id>Fit.NoSuchFitnesseFixture class</class-id> <category>instance creation</category><body package="Fit">named: aString 	^self format: 'Could not find fixture: &lt;1s&gt;.' with: aString</body></methods><methods><class-id>Fit.Decorator.Performance.TimeBasedFixtureDecorator</class-id> <category>initialize-release</category><body package="Fit">initialize		super initialize.	self stopWatch: DefaultTimer new</body><body package="Fit">stopWatch: aTimer		stopWatch := aTimer</body></methods><methods><class-id>Fit.Decorator.Performance.TimeBasedFixtureDecorator</class-id> <category>private</category><body package="Fit">run: aFixture table: aParse		stopWatch start.	super run: aFixture table: aParse.	elapsedTime := stopWatch elapsed</body><body package="Fit">updateColumns: aParse actual: actualNumber expected: expectedNumber compareWith: aSymbol		(actualNumber perform: aSymbol with: expectedNumber)		ifTrue:			[self				wrong: aParse				actual: actualNumber printString]		ifFalse:			[self right: aParse.			aParse addToBody: '&lt;hr&gt;actual ' , actualNumber printString]</body></methods><methods><class-id>Fit.Decorator.Performance.TimeBasedFixtureDecorator class</class-id> <category>constants</category><body package="Fit">actualTimeTakenKey		^'actualTimeTaken'</body></methods><methods><class-id>Fit.Decorator.Performance.TimeBasedFixtureDecorator class</class-id> <category>instance creation</category><body package="Fit">stopWatch: aTimer		^self new stopWatch: aTimer</body></methods><methods><class-id>Fit.Decorator.Performance.MaxTime</class-id> <category>private</category><body package="Fit">run: aFixture table: aParse		super run: aFixture table: aParse.	summary		at: self class actualTimeTakenKey		put: elapsedTime</body><body package="Fit">setupDecorator: aCollection		aCollection size = 1		ifFalse:			[^InvalidInputException raiseErrorString: 'Max Time must be specified'].	maxTime := Number fitParse: aCollection first.	summary		at: self class maxTimeKey		put: maxTime</body><body package="Fit">updateColumnsBasedOnResults: aParse		self		updateColumns: aParse parts parts more		actual: elapsedTime		expected: maxTime		compareWith: #&gt;</body></methods><methods><class-id>Fit.Decorator.Performance.MaxTime</class-id> <category>initialize-release</category><body package="Fit">initialize		super initialize.	maxTime := 0</body></methods><methods><class-id>Fit.Decorator.Performance.MaxTime class</class-id> <category>constants</category><body package="Fit">maxTimeKey		^'maxTime'</body></methods><methods><class-id>Fit.MethodSignature</class-id> <category>accessing</category><body package="Fit">numArgs	^parameterAdapters size</body><body package="Fit">parameterAdapterAt: anInteger 	^parameterAdapters at: anInteger</body><body package="Fit">parameterAdapters	^parameterAdapters</body><body package="Fit">resultAdapter	^resultAdapter</body><body package="Fit">resultAdapter: aClassOrTypeAdapter	resultAdapter := aClassOrTypeAdapter				ifNotNil: [TypeAdapter adapterFor: aClassOrTypeAdapter]</body><body package="Fit">soleAdapter	^resultAdapter ifNil: [parameterAdapters first] ifNotNil: #yourself</body></methods><methods><class-id>Fit.MethodSignature</class-id> <category>converting</category><body package="Fit">asFitMethodSignature	^self</body></methods><methods><class-id>Fit.MethodSignature</class-id> <category>testing</category><body package="Fit">isEmpty	^parameterAdapters isEmpty and: [resultAdapter isNil]</body><body package="Fit">isValidForSelector: aSymbol	(aSymbol numArgs isZero and: [resultAdapter isNil]) ifTrue: [^false].	^self numArgs = aSymbol numArgs</body><body package="Fit">returns: aClass	resultAdapter ifNil: [^false].	^resultAdapter isForClass: aClass</body><body package="Fit">takes: aCollection	parameterAdapters size = aCollection size ifFalse: [^false].	parameterAdapters with: aCollection		do: [:adapter :class | (adapter isForClass: class) ifFalse: [^false]].	^true</body><body package="Fit">takesOne: aClass	^parameterAdapters anySatisfy: [:each | each isForClass: aClass]</body></methods><methods><class-id>Fit.MethodSignature</class-id> <category>initialize-release</category><body package="Fit">initialize	parameterAdapters := OrderedCollection new</body></methods><methods><class-id>Fit.MethodSignature</class-id> <category>adding</category><body package="Fit">addAll: aCollection	parameterAdapters		addAll: (aCollection collect: [:each | TypeAdapter adapterFor: each])</body></methods><methods><class-id>Fit.MethodSignature class</class-id> <category>instance creation</category><body package="Fit">fromPragmas: pragmas	| returnType parameterTypes inst |	parameterTypes := self parameterTypesFromPragmas: pragmas.	returnType := self returnTypeFromPragmas: pragmas.	inst := self withAll: parameterTypes returning: returnType.	^inst isEmpty ifTrue: [nil] ifFalse: [inst]</body><body package="Fit">new	^super new initialize</body><body package="Fit">returning: aClassOrTypeAdapter 	^self withAll: #() returning: aClassOrTypeAdapter</body><body package="Fit">with: aClassOrTypeAdapter 	^self with: aClassOrTypeAdapter returning: nil</body><body package="Fit">with: parameterClassOrTypeAdapter returning: resultClassOrTypeAdapter 	^self withAll: (Array with: parameterClassOrTypeAdapter) returning: resultClassOrTypeAdapter</body><body package="Fit">with: parameter1 with: parameter2 	^self 		with: parameter1		with: parameter2		returning: nil</body><body package="Fit">with: parameter1 with: parameter2 returning: resultClassOrTypeAdapter 	^self withAll: (Array with: parameter1 with: parameter2)		returning: resultClassOrTypeAdapter</body><body package="Fit">with: parameter1 with: parameter2 with: parameter3 	^self 		with: parameter1		with: parameter2		with: parameter3		returning: nil</body><body package="Fit">with: parameter1 with: parameter2 with: parameter3 returning: resultClassOrTypeAdapter 	^self withAll: (Array 				with: parameter1				with: parameter2				with: parameter3)		returning: resultClassOrTypeAdapter</body><body package="Fit">with: parameter1 with: parameter2 with: parameter3 with: parameter4 	^self 		with: parameter1		with: parameter2		with: parameter3		with: parameter4		returning: nil</body><body package="Fit">with: parameter1 with: parameter2 with: parameter3 with: parameter4 returning: resultClassOrTypeAdapter 	^self withAll: (Array 				with: parameter1				with: parameter2				with: parameter3				with: parameter4)		returning: resultClassOrTypeAdapter</body><body package="Fit">withAll: aCollection 	^self withAll: aCollection returning: nil</body><body package="Fit">withAll: aCollection returning: aClassOrTypeAdapter 	^(self new)		addAll: aCollection;		resultAdapter: aClassOrTypeAdapter;		yourself</body></methods><methods><class-id>Fit.MethodSignature class</class-id> <category>private</category><body package="Fit">findSelector: aSymbol viaPragmaIn: anObject	"Use the #instanceBehavior of the class instead of just the class.  This handles RowFixture's #targetClass correctly, where anObject is actually the class rather than an instance."	| classMethodPair |	classMethodPair := (anObject class instanceBehavior findSelector: aSymbol)				ifNil: [^nil].	^self signatureFromPragmasIn: classMethodPair last</body><body package="Fit">findSelector: aSymbol viaSignatureForMethodIn: anObject	(anObject respondsTo: #signatureFor:) ifFalse: [^nil].	^(anObject signatureFor: aSymbol) ifNotNil: #asFitMethodSignature</body><body package="Fit">findSignatureForMethod: aCompiledMethod in: anObject	^(self signatureFromPragmasIn: aCompiledMethod)		ifNil: 			[self findSelector: aCompiledMethod selector				viaSignatureForMethodIn: anObject]</body><body package="Fit">findSignatureForSelector: aSymbol in: anObject	^self		cacheAt: aSymbol		object: anObject		ifAbsentPut: [self lookUpSignatureForSelector: aSymbol in: anObject]</body><body package="Fit">invalidSignatureFor: aSymbol	^(InvalidSignature for: aSymbol) raise</body><body package="Fit">lookUpSignatureForSelector: aSymbol in: anObject	^(self findSelector: aSymbol viaPragmaIn: anObject)		ifNil: [self findSelector: aSymbol viaSignatureForMethodIn: anObject]</body><body package="Fit">parameterTypesFromPragmas: aCollection	| pragma spec |	pragma := aCollection detect: [:each | each keyword == #fitTakes:]				ifNone: [^#()].	spec := pragma argumentAt: 1.	(spec isSymbol or: [spec isSequenceable not])		ifTrue: [spec := Array with: spec].	^spec collect: 			[:each |			self typeFromPragmaSpec: each inEnvironment: pragma method environment]</body><body package="Fit">returnTypeFromPragmas: aCollection	| pragma |	pragma := aCollection detect: [:each | each keyword == #fitReturns:]				ifNone: [^nil].	^self typeFromPragmaSpec: (pragma argumentAt: 1)		inEnvironment: pragma method environment</body><body package="Fit">signatureFromPragmasIn: aCompiledMethod	^self fromPragmas: (Pragma allInMethod: aCompiledMethod)</body><body package="Fit">typeFromPragmaSpec: anObject inEnvironment: aNamespace	| resolved |	resolved := anObject isSymbol				ifTrue: [(BindingReference simpleName: anObject in: aNamespace) value]				ifFalse: 					[anObject isBindingReference						ifTrue: [anObject value]						ifFalse: 							[anObject								collect: [:each | self typeFromPragmaSpec: each inEnvironment: aNamespace]]].	^TypeAdapter adapterFor: resolved</body><body package="Fit">validateSignature: aMethodSignature forSelector: aSymbol	(aMethodSignature isValidForSelector: aSymbol)		ifFalse: [^self invalidSignatureFor: aSymbol].	^aMethodSignature</body></methods><methods><class-id>Fit.MethodSignature class</class-id> <category>lookup</category><body package="Fit">forField: aField in: anObject	(self findSignatureForSelector: aField getSelector in: anObject)		ifNotNil: [:signature | ^self validateSignature: signature forSelector: aField getSelector].	^self forSelector: aField setSelector in: anObject</body><body package="Fit">forMethod: aCompiledMethod in: anObject	^(self findSignatureForMethod: aCompiledMethod in: anObject)		ifNotNil: 			[:signature |			self validateSignature: signature forSelector: aCompiledMethod selector]</body><body package="Fit">forSelector: aSymbol in: anObject	^(self findSignatureForSelector: aSymbol in: anObject)		ifNotNil: [:signature | self validateSignature: signature forSelector: aSymbol]</body></methods><methods><class-id>Fit.MethodSignature class</class-id> <category>cache</category><body package="Fit">cache	Cache ifNil: [self initializeCache].	^Cache</body><body package="Fit">cacheAt: aSelector object: anObject ifAbsentPut: aBlock	^(self cache at: aSelector ifAbsentPut: [IdentityDictionary new])		at: anObject class		ifAbsentPut: aBlock</body><body package="Fit">clearCache	Cache := nil</body><body package="Fit">initializeCache	Cache := IdentityDictionary new.	Session when: SessionEnding send: #clearCache to: self</body></methods><methods><class-id>Fit.ClassIsNotFixtureException class</class-id> <category>instance creation</category><body package="Fit">className: aString 	^self format: 'Class &lt;1s&gt; is not a fixture.' with: aString</body></methods><methods><class-id>Fit.Binding</class-id> <category>operations</category><body package="Fit">doCell: aParse fixture: aFixture 	^self subclassResponsibility</body></methods><methods><class-id>Fit.Binding</class-id> <category>accessing</category><body package="Fit">adapter	^adapter</body><body package="Fit">adapter: aTypeAdapter	adapter := aTypeAdapter</body></methods><methods><class-id>Fit.Binding class</class-id> <category>private</category><body package="Fit">createFor: aString	aString first = $= ifTrue: [^SaveBinding new].	aString last = $= ifTrue: [^RecallBinding new].	(aString matchesRegex: self regexMethodPattern)		ifTrue: [^RegexQueryBinding new].	(aString matchesRegex: self methodPattern) ifTrue: [^QueryBinding new].	(aString matchesRegex: self fieldPattern) ifTrue: [^SetBinding new].	^nil</body><body package="Fit">fieldPattern	^'=?([^=]+)=?'</body><body package="Fit">findMethodNamed: aString in: aFixture usingMatcher: matcher	| methodName method |	methodName := (GracefulNamer isGracefulName: aString)				ifTrue: [GracefulNamer disgrace: aString]				ifFalse: [matcher subexpression: 2].	method := (Fixture camelCase: methodName) asSymbol.	(aFixture targetClass canUnderstand: method)		ifFalse: [^(NoSuchMethodException named: aString) raise].	^method</body><body package="Fit">makeAdapterForField: aString on: aFixture 	| field fieldName |	fieldName := (GracefulNamer isGracefulName: aString) 				ifTrue: [GracefulNamer disgrace: aString]				ifFalse: 					[| matcher |					matcher := RxMatcher forString: self fieldPattern.					matcher matches: aString.					matcher subexpression: 2].	field := Field named: (Fixture camelCase: fieldName).	(field existsIn: aFixture targetClass) 		ifFalse: [^(NoSuchFieldException named: aString) raise].	^TypeAdapter on: aFixture field: field</body><body package="Fit">makeAdapterForMethod: aString on: aFixture usingMatcher: matcher	| method |	method := self findMethodNamed: aString in: aFixture usingMatcher: matcher.	^TypeAdapter on: aFixture method: method isRegex: false</body><body package="Fit">makeAdapterForRegexMethod: aString on: aFixture usingMatcher: matcher	| method |	method := self findMethodNamed: aString in: aFixture usingMatcher: matcher.	^TypeAdapter on: aFixture method: method isRegex: true</body><body package="Fit">makeAdapterOn: aFixture for: aString	| matcher regexMatcher |	regexMatcher := RxMatcher forString: self regexMethodPattern.	(regexMatcher matches: aString)		ifTrue: 			[^self				makeAdapterForRegexMethod: aString				on: aFixture				usingMatcher: regexMatcher].	matcher := RxMatcher forString: self methodPattern.	^(matcher matches: aString)		ifTrue: 			[self makeAdapterForMethod: aString on: aFixture usingMatcher: matcher]		ifFalse: [self makeAdapterForField: aString on: aFixture]</body><body package="Fit">methodPattern	^'(.+)(\(\)|\?|!)'</body><body package="Fit">regexMethodPattern	^'(.+)(\?\?|!!)'</body></methods><methods><class-id>Fit.Binding class</class-id> <category>instance creation</category><body package="Fit">createOn: aFixture for: aString 	| binding |	binding := self createFor: aString.	binding ifNil: [binding := NullBinding new]		ifNotNil: [binding adapter: (self makeAdapterOn: aFixture for: aString)].	^binding</body></methods><methods><class-id>Fit.NullBinding</class-id> <category>operations</category><body package="Fit">doCell: aParse fixture: aFixture 	aFixture ignore: aParse</body></methods><methods><class-id>Fit.ScientificDouble</class-id> <category>comparing</category><body package="Fit">= anObject 	^(self compareTo: anObject) = 0</body><body package="Fit">compareTo: anObject 	| other diff |	other := anObject asNumber.	((self isInfinite: value) and: [self isInfinite: other]) ifTrue: [^0].	(self isInfinite: value) ifTrue: [^1].	(self isInfinite: other) ifTrue: [^-1].	diff := value - other.	diff &lt; precision negated ifTrue: [^-1].	diff &gt; precision ifTrue: [^1].	^0</body></methods><methods><class-id>Fit.ScientificDouble</class-id> <category>converting</category><body package="Fit">asNumber	^value</body></methods><methods><class-id>Fit.ScientificDouble</class-id> <category>accessing</category><body package="Fit">precision: aDouble	precision := aDouble</body><body package="Fit">value: aDouble	value := aDouble</body></methods><methods><class-id>Fit.ScientificDouble</class-id> <category>printing</category><body package="Fit">printOn: aStream 	value printOn: aStream</body></methods><methods><class-id>Fit.ScientificDouble</class-id> <category>private</category><body package="Fit">isInfinite: anObject 	^anObject isKindOf: DivideByZero</body></methods><methods><class-id>Fit.ScientificDouble class</class-id> <category>instance creation</category><body package="Fit">value: aDouble 	^(self new)		value: aDouble;		precision: 0;		yourself</body><body package="Fit">valueOf: aString 	^(self value: (self parseDouble: aString))		precision: (self precision: aString);		yourself</body></methods><methods><class-id>Fit.ScientificDouble class</class-id> <category>utility</category><body package="Fit">parseDouble: aString 	^Double readFromString: aString asLowercase</body><body package="Fit">precision: aString	| value bound |	value := self parseDouble: aString.	bound := self parseDouble: (self tweak: aString fitTrimSeparators).	^(bound - value) abs</body><body package="Fit">tweak: aString 	| pos |	(pos := aString asLowercase indexOf: $e) &gt;= 1 		ifTrue: 			[^(self tweak: (aString copyFrom: 1 to: pos - 1)) 				, (aString copyFrom: pos to: aString size)].	(aString indexOf: $.) &gt;= 1 ifTrue: [^aString , '5'].	^aString , '.5'</body></methods><methods><class-id>Fit.ScientificDouble class</class-id> <category>fit-utilities</category><body package="Fit">fitParse: aString 	^self valueOf: aString</body></methods><methods><class-id>Fit.DelegateAdapter</class-id> <category>parsing</category><body package="Fit">parse: aString 	^delegate fitParse: aString</body></methods><methods><class-id>Fit.DelegateAdapter</class-id> <category>accessing</category><body package="Fit">delegate: anObject 	delegate := anObject</body></methods><methods><class-id>Fit.DelegateAdapter class</class-id> <category>instance creation</category><body package="Fit">delegate: anObject		(anObject respondsTo: #fitParse:)		ifFalse: [^(NoSuchMethodException named: 'fitParse:') raise].	^self new delegate: anObject</body></methods><methods><class-id>Fit.NullFixtureListener</class-id> <category>events</category><body package="Fit">tableFinished: aParse 	"do nothing"</body><body package="Fit">tablesFinished: aCounts 	"do nothing"</body></methods><methods><class-id>Fit.Session class</class-id> <category>reference counting</category><body package="Fit">addReference	self referenceCount: self referenceCount + 1</body><body package="Fit">deleteReference	self referenceCount: (self referenceCount - 1 max: 0)</body><body package="Fit">referenceCount	^ReferenceCount ifNil: [ReferenceCount := 0]</body><body package="Fit">referenceCount: anInteger 	^ReferenceCount := anInteger</body></methods><methods><class-id>Fit.Session class</class-id> <category>sessions</category><body package="Fit">beFitWhile: aBlock 	self startFit.	[aBlock value] ensure: [self end]</body><body package="Fit">beFitnesseWhile: aBlock 	self startFitnesse.	[aBlock value] ensure: [self end]</body><body package="Fit">cleanUp	self announce: SessionEnding.	self removeAllSubscriptions.	Markup reset.	FixtureLoader reset</body><body package="Fit">end	self deleteReference.	self referenceCount isZero ifTrue: [self cleanUp]</body><body package="Fit">removeAllSubscriptions	self subscriptionRegistryOrNil 		ifNotNil: [:registry | registry removeSubscriptions: registry allSubscriptions]</body><body package="Fit">reset	[self referenceCount &gt; 0] whileTrue: [self end]</body><body package="Fit">startFit	self addReference.	Markup useFit.	FixtureLoader useFit</body><body package="Fit">startFitnesse	self addReference.	Markup useFitnesse.	FixtureLoader useFitnesse</body></methods><methods><class-id>Fit.Session class</class-id> <category>private</category><body package="Fit">subscriptionRegistry: aSubscriptionRegistryOrNil 	MySubscriptions := aSubscriptionRegistryOrNil</body></methods><methods><class-id>Fit.Session class</class-id> <category>announcements</category><body package="Fit">subscriptionRegistryOrNil	^MySubscriptions</body></methods><methods><class-id>Fit.AbstractFitServer</class-id> <category>initialize-release</category><body package="Fit">initialize	super initialize.	arguments := FitServerArguments new.	outputStream := Transcript</body><body package="Fit">outputStream: aStream	outputStream := aStream</body></methods><methods><class-id>Fit.AbstractFitServer</class-id> <category>private</category><body package="Fit">argumentsFrom: aCollection	arguments := FitServerArguments from: aCollection</body><body package="Fit">basicProcess	| size document |		[[(size := FitProtocol readSize: socketReader) isZero] whileFalse: 			[			[self printLine: 'processing document of size: ' , size printString.			document := FitProtocol readDocumentFrom: socketReader size: size.			self processDocument: document]					on: ParseError					do: [:ex | self exception: ex]].	self printLine: 'completion signal received']			on: Error			do: [:ex | self exception: ex]</body><body package="Fit">closeConnection	socket close</body><body package="Fit">establishConnection	self socket: (SocketAccessor newTCPclientToHost: arguments host				port: arguments port)</body><body package="Fit">exception: anException	^self subclassResponsibility</body><body package="Fit">exit	self printLine: 'exiting'</body><body package="Fit">makeHttpRequest	^'GET /?responder=socketCatcher&amp;ticket=&lt;1s&gt; HTTP/1.1&lt;n&gt;&lt;2s&gt;&lt;n&gt;&lt;2s&gt;'		expandMacrosWith: arguments socketToken		with: (String with: Character lf)</body><body package="Fit">print: aString	arguments verbose ifTrue: [Transcript show: aString]</body><body package="Fit">printLine: aString 	self print: aString , (String with: Character lf)</body><body package="Fit">process	Session beFitnesseWhile: [self basicProcess]</body><body package="Fit">processDocument: aString	^self subclassResponsibility</body><body package="Fit">readTable: aTable	^self subclassResponsibility</body><body package="Fit">sendTable: table	| bytes |	bytes := self readTable: table.	bytes isEmpty ifFalse: [FitProtocol writeBytes: bytes to: socketOutput]</body><body package="Fit">socket: aSocketAccessor 	socket := aSocketAccessor.	socketOutput := socket writeStream binary.	socketReader := socket</body><body package="Fit">usage: aString	outputStream		nextPutAll: aString;		cr.	^-1</body><body package="Fit">validateConnection	| statusSize httpRequest errorMessage |	httpRequest := self makeHttpRequest asByteArrayEncoding: #'UTF-8'.	FitProtocol write: httpRequest to: socketOutput.	self printLine: 'http request sent'.	self print: 'validating connection...'.	statusSize := FitProtocol readSize: socketReader.	statusSize isZero		ifTrue: 			[self printLine: '...ok'.			^self].	errorMessage := FitProtocol readDocumentFrom: socketReader size: statusSize.	self printLine: '...failed because: ' , errorMessage.	outputStream		nextPutAll: 'An error occurred while connecting to client.';		cr;		nextPutAll: errorMessage;		cr.	InvalidConnection raise</body></methods><methods><class-id>Fit.AbstractFitServer</class-id> <category>running</category><body package="Fit">run	[self validateConnection] on: InvalidConnection do: [:ex | ^-2].	^self		process;		closeConnection;		exit;		exitCode</body><body package="Fit">runWithArguments: aCollection	[self argumentsFrom: aCollection] on: FitServerUsage		do: [:ex | ^self usage: ex errorString].	self establishConnection.	^self run</body></methods><methods><class-id>Fit.AbstractFitServer</class-id> <category>events</category><body package="Fit">writeCounts: aCounts 	FitProtocol writeCounts: aCounts to: socketOutput</body></methods><methods><class-id>Fit.AbstractFitServer</class-id> <category>accessing</category><body package="Fit">exitCode	^self subclassResponsibility</body><body package="Fit">socketToken: aString	arguments socketToken: aString</body></methods><methods><class-id>Fit.AbstractFitServer class</class-id> <category>instance creation</category><body package="Fit">new	^super new initialize</body></methods><methods><class-id>Fit.Decorator.Performance.TimeRange</class-id> <category>private</category><body package="Fit">run: aFixture table: aParse		super run: aFixture table: aParse.	summary		at: self class actualTimeTakenKey		put: elapsedTime</body><body package="Fit">setupDecorator: aCollection		aCollection size = 2		ifFalse:			[^InvalidInputException raiseErrorString: 'Time range must be specified'].	minTime := Number fitParse: aCollection first.	maxTime := Number fitParse: aCollection last.	summary		at: self class minTimeKey			put: minTime;		at: self class maxTimeKey			put: maxTime</body><body package="Fit">updateColumnsBasedOnResults: aParse		self		updateColumns: aParse parts parts more			actual: elapsedTime			expected: minTime			compareWith: #&lt;;		updateColumns: aParse parts parts more more more			actual: elapsedTime			expected: maxTime			compareWith: #&gt;</body></methods><methods><class-id>Fit.Decorator.Performance.TimeRange class</class-id> <category>constants</category><body package="Fit">maxTimeKey		^'maxTime'</body><body package="Fit">minTimeKey		^'minTime'</body></methods><methods><class-id>Fit.FitMatcher</class-id> <category>testing</category><body package="Fit">compare: n to: operand using: op 	op = '&lt;' ifTrue: [^n &lt; operand].	op = '&gt;' ifTrue: [^n &gt; operand].	op = '&lt;=' ifTrue: [^n &lt;= operand].	op = '&gt;=' ifTrue: [^n &gt;= operand].	^false</body><body package="Fit">matches	| matcher |	matcher := RxMatcher forString: self simpleMatchPattern.	(matcher matches: expression) ifTrue: [^self processSimpleMatch: matcher].	matcher := RxMatcher forString: self rangeMatchPattern.	(matcher matches: expression) ifTrue: [^self processRangeMatch: matcher].	^FitMatcherException raiseErrorString: 'Invalid FitMatcher Expression'</body><body package="Fit">processRangeMatch: matcher 	| a aop bop b |	a := Number fitParse: (matcher subexpression: 2).	aop := matcher subexpression: 3.	bop := matcher subexpression: 4.	b := Number fitParse: (matcher subexpression: 5).	^(self 		compare: a		to: parameter		using: aop) and: 				[self 					compare: parameter					to: b					using: bop]</body><body package="Fit">processSimpleMatch: matcher 	| op operandString operand |	op := matcher subexpression: 2.	operandString := matcher subexpression: 3.	operand := Number fitParse: operandString.	^self 		compare: parameter		to: operand		using: op</body><body package="Fit">rangeMatchPattern	^'\s*([-+]?[\d]*\.?[\d]+)\s*(&lt;|&gt;|&lt;=|&gt;=)\s*_\s*(&lt;|&gt;|&lt;=|&gt;=)\s*([-+]?[\d]*\.?[\d]+)'</body><body package="Fit">simpleMatchPattern	^'\s*_?\s*(&lt;|&gt;|&lt;=|&gt;=)\s*([-+]?[\d]*\.?[\d]+)'</body></methods><methods><class-id>Fit.FitMatcher</class-id> <category>initialize-release</category><body package="Fit">expression: aString parameter: aNumber 	expression := aString.	parameter := aNumber</body></methods><methods><class-id>Fit.FitMatcher</class-id> <category>accessing</category><body package="Fit">message	| parmString index |	parmString := '&lt;b&gt;' , parameter printString , '&lt;/b&gt;'.	index := expression indexOf: $_.	^index = 0 		ifTrue: [parmString , expression]		ifFalse: 			[(expression copyFrom: 1 to: index - 1) , parmString 				, (expression copyFrom: index + 1 to: expression size)]</body></methods><methods><class-id>Fit.FitMatcher class</class-id> <category>instance creation</category><body package="Fit">expression: aString parameter: aNumber 	^self new expression: aString parameter: aNumber</body></methods><methods><class-id>Fit.Exceptions.NoSuchMethodException class</class-id> <category>instance creation</category><body package="Fit">named: aString 	^self messageText: 'Could not find method: ' , aString , '.'</body></methods><methods><class-id>Fit.SaveBinding</class-id> <category>operations</category><body package="Fit">doCell: aParse fixture: aFixture	| symbolValue symbolName |		[(aFixture isKindOf: ColumnFixture) ifTrue: [aFixture executeIfNeeded].	symbolValue := adapter get fitToString.	symbolName := aParse text.	Fixture symbolAt: symbolName put: symbolValue.	aFixture info: aParse text: '= ' , symbolValue]			on: Error			do: [:ex | aFixture mark: aParse exception: ex]</body></methods><methods><class-id>Fit.Counts</class-id> <category>counting</category><body package="Fit">incrementExceptions	exceptions := exceptions + 1</body><body package="Fit">incrementIgnores	ignores := ignores + 1</body><body package="Fit">incrementRight	right := right + 1</body><body package="Fit">incrementWrong	wrong := wrong + 1</body><body package="Fit">tally: aCounts 	right := right + aCounts right.	wrong := wrong + aCounts wrong.	ignores := ignores + aCounts ignores.	exceptions := exceptions + aCounts exceptions</body><body package="Fit">tallyPageCounts: aCounts 	aCounts wrong &gt; 0 ifTrue: [^self incrementWrong].	aCounts exceptions &gt; 0 ifTrue: [^self incrementExceptions].	(aCounts ignores &gt; 0 and: [aCounts right isZero]) 		ifTrue: [^self incrementIgnores].	self incrementRight</body></methods><methods><class-id>Fit.Counts</class-id> <category>accessing</category><body package="Fit">anyFailures	^wrong + exceptions &gt; 0</body><body package="Fit">clear	right := 0.	wrong := 0.	ignores := 0.	exceptions := 0</body><body package="Fit">exceptions	^exceptions</body><body package="Fit">exceptions: anObject	exceptions := anObject</body><body package="Fit">ignores	^ignores</body><body package="Fit">ignores: anObject	ignores := anObject</body><body package="Fit">right	^right</body><body package="Fit">right: anObject	right := anObject</body><body package="Fit">total	^right + wrong + ignores + exceptions</body><body package="Fit">wrong	^wrong</body><body package="Fit">wrong: anObject	wrong := anObject</body></methods><methods><class-id>Fit.Counts</class-id> <category>printing</category><body package="Fit">printOn: aStream 	aStream		print: right;		nextPutAll: ' right, ';		print: wrong;		nextPutAll: ' wrong, ';		print: ignores;		nextPutAll: ' ignored, ';		print: exceptions;		nextPutAll: ' exceptions'</body></methods><methods><class-id>Fit.Counts</class-id> <category>comparing</category><body package="Fit">= aCounts		^right = aCounts right &amp; (wrong = aCounts wrong)		&amp; (ignores = aCounts ignores) &amp; (exceptions = aCounts exceptions)</body><body package="Fit">hash		^((right hashMultiply bitXor: wrong hashMultiply)		bitXor: ignores hashMultiply) bitXor: exceptions hashMultiply</body></methods><methods><class-id>Fit.Counts</class-id> <category>initialize-release</category><body package="Fit">initialize	super initialize.	self clear</body></methods><methods><class-id>Fit.Counts class</class-id> <category>instance creation</category><body package="Fit">from: aCollection 	^(self new)		right: aCollection first;		wrong: (aCollection at: 2);		ignores: (aCollection at: 3);		exceptions: (aCollection at: 4);		yourself</body><body package="Fit">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Fit.InNumberState</class-id> <category>rules</category><body package="Fit">digit: aCharacter 	context append: aCharacter</body><body package="Fit">letter: aCharacter 	context		append: aCharacter asUppercase;		nextState: InWordState</body><body package="Fit">other: aCharacter 	context nextState: OutOfWordState</body></methods><methods><class-id>Fit.Exceptions.CouldNotParseException class</class-id> <category>instance creation</category><body package="Fit">input: aString expectedType: aClass	^self		messageText: 'Could not parse: ' , aString , ', expected type: '				, aClass name , '.'</body></methods><methods><class-id>Fit.FitServerUsage</class-id> <category>printing</category><body package="Fit">defaultMessageText	^'Usage: &lt;VisualWorks VM&gt; &lt;image name&gt; -fitnesse &lt;FitServer class&gt; [verbose] &lt;hostname&gt; &lt;port&gt; &lt;socketToken&gt;'</body></methods><methods><class-id>Fit.Summary</class-id> <category>constants</category><body package="Fit">countsKey	^'counts'</body></methods><methods><class-id>Fit.Summary</class-id> <category>enumerating</category><body package="Fit">doTable: table 	| keys |	summary at: self countsKey put: self counts.	keys := SortedCollection withAll: summary keys.	table parts more: (self rows: keys)</body></methods><methods><class-id>Fit.Summary</class-id> <category>building</category><body package="Fit">mark: aParse 	| officialCounts cell |	officialCounts := counts.	counts := Counts new.	cell := aParse parts more.	self mark: cell right: officialCounts anyFailures not.	counts := officialCounts</body><body package="Fit">rows: keys 	^keys isEmpty 		ifFalse: 			[| result rest key value |			key := keys first.			rest := keys copyWithout: key.			value := summary at: key.			value isString ifFalse: [value := value printString].			result := Parse trWithCells: (Parse td: (self info: key)								more: (Parse td: (self info: value)))						more: (self rows: rest).			key = self countsKey ifTrue: [self mark: result].			result]		ifTrue: [nil]</body></methods><methods><class-id>Fit.FitServerArguments</class-id> <category>accessing</category><body package="Fit">host	^host</body><body package="Fit">port	^port</body><body package="Fit">socketToken	^socketToken</body><body package="Fit">socketToken: aString	socketToken := aString</body><body package="Fit">verbose	^verbose</body></methods><methods><class-id>Fit.FitServerArguments</class-id> <category>initialize-release</category><body package="Fit">initialize	super initialize.	verbose := false</body><body package="Fit">initializeFrom: aCollection	| rs |	rs := aCollection readStream.	verbose := rs peekFor: 'verbose'.	host := rs next.	port := rs next asNumber.	socketToken := rs next.	self isValid ifFalse: [^FitServerUsage raise]</body></methods><methods><class-id>Fit.FitServerArguments</class-id> <category>private</category><body package="Fit">isValid	^(self isValidString: host)		and: [port isZero not and: [self isValidString: socketToken]]</body><body package="Fit">isValidString: aStringOrNil	^aStringOrNil notNil and: [aStringOrNil notEmpty]</body></methods><methods><class-id>Fit.FitServerArguments class</class-id> <category>instance creation</category><body package="Fit">from: aCollection	^self new initializeFrom: aCollection</body><body package="Fit">new	^super new initialize</body></methods><methods><class-id>Fit.SetBinding</class-id> <category>operations</category><body package="Fit">doCell: aParse fixture: aFixture 	| text |	text := aParse text.	text isEmpty 		ifTrue: [aFixture handleBlankCell: aParse adapter: adapter]		ifFalse: [adapter set: (adapter parse: text)]</body></methods><methods><class-id>Fit.OutOfWordState</class-id> <category>rules</category><body package="Fit">digit: aCharacter 	context		append: aCharacter;		nextState: InNumberState</body><body package="Fit">letter: aCharacter 	context		append: aCharacter asUppercase;		nextState: InWordState</body></methods><methods><class-id>Fit.ActionFixture</class-id> <category>actions</category><body package="Fit">check	| methodName adapter checkValueCell |	self checkForActor.	methodName := self extractMethodName.	adapter := TypeAdapter on: self class actor method: methodName.	checkValueCell := parsedCells more more ifNil: 					[FitFailureException raiseErrorString: 'You must specify a value to check.'].	self check: checkValueCell adapter: adapter</body><body package="Fit">enter	| adapter argument message methodName actor |	self checkForActor.	methodName := (self extractMethodName , ':') asSymbol.	actor := self class actor.	message := self messageFor: methodName.	adapter := TypeAdapter on: actor method: message.	argument := self extractParsedArgumentUsing: adapter.	actor perform: message with: argument</body><body package="Fit">press	| methodName message |	self checkForActor.	methodName := self extractMethodName.	message := self messageFor: methodName.	self class actor perform: message</body><body package="Fit">start	| fixture |	fixture := parsedCells more ifNil: 					[FitFailureException 						raiseErrorString: 'You must specify a fixture to start.'].	self class actor: (self loadFixture: fixture text)</body></methods><methods><class-id>Fit.ActionFixture</class-id> <category>private</category><body package="Fit">checkForActor	self class actor ifNil: [self raiseNoActorException]</body><body package="Fit">extractMethodName	| methodCell |	methodCell := parsedCells more 				ifNil: [^FitFailureException raiseErrorString: 'You must specify a method.'].	^(self camelCase: methodCell text) asSymbol</body><body package="Fit">extractParsedArgumentUsing: aTypeAdapter 	| argumentCell text |	argumentCell := parsedCells more more ifNil: 					[^FitFailureException raiseErrorString: 'You must specify an argument.'].	text := argumentCell text.	^[aTypeAdapter parse: text] on: ArithmeticError		do: 			[:ex | 			(CouldNotParseException input: text expectedType: aTypeAdapter type) raise]</body><body package="Fit">messageFor: aSymbol 	(self class actor respondsTo: aSymbol) 		ifFalse: [^(NoSuchMethodException named: aSymbol) raise].	^aSymbol</body><body package="Fit">raiseNoActorException	^FitFailureException 		raiseErrorString: 'You must start a fixture using the ''start'' keyword.'</body></methods><methods><class-id>Fit.ActionFixture</class-id> <category>enumerating</category><body package="Fit">doCells: aParse 	"  public void doCells(Parse cells) {        this.cells = cells;        try {            Method action = getClass().getMethod(cells.text(), empty);            action.invoke(this, empty);        } catch (Exception e) {            exception(cells, e);        }    } "	parsedCells := aParse.	[self perform: parsedCells text asSymbol] on: Error		do: [:ex | self mark: parsedCells exception: ex]</body></methods><methods><class-id>Fit.ActionFixture class</class-id> <category>accessing</category><body package="Fit">actor	^Actor</body><body package="Fit">actor: anObject 	anObject ifNotNil: [self clearActorAtEndOfSession].	Actor := anObject</body><body package="Fit">clearActorAtEndOfSession	^Session 		when: SessionEnding		do: [Actor := nil]		for: self</body></methods><methods><class-id>Fit.FixtureLoader</class-id> <category>operations</category><body package="Fit">load: aString 	^self subclassResponsibility</body></methods><methods><class-id>Fit.FixtureLoader</class-id> <category>private</category><body package="Fit">instantiateFixture: aString 	| classForFixture |	classForFixture := self loadFixtureClass: aString.	^Fixture instantiate: classForFixture</body><body package="Fit">loadFixtureClass: aString	^(ClassNameConversion smalltalkName: aString) classOrNil		ifNil: [self noSuchFixtureNamed: aString]</body><body package="Fit">noSuchFixtureNamed: aString 	^(self noSuchFixtureSignal named: aString) raise</body><body package="Fit">noSuchFixtureSignal	^self subclassResponsibility</body></methods><methods><class-id>Fit.FixtureLoader class</class-id> <category>variants</category><body package="Fit">useFit	self current: FitFixtureLoader new</body><body package="Fit">useFitnesse	self current: FitnesseFixtureLoader new</body></methods><methods><class-id>Fit.FixtureLoader class</class-id> <category>singleton</category><body package="Fit">current	^Current</body><body package="Fit">current: aFixtureLoader	Current := aFixtureLoader</body><body package="Fit">reset	Current := nil</body></methods><methods><class-id>Fit.FixtureLoader class</class-id> <category>operations</category><body package="Fit">load: aString 	^self current load: aString</body></methods><methods><class-id>Fit.Decorator.Util.DefaultTimer</class-id> <category>operations</category><body package="Fit">elapsed		^Time millisecondClockValue - startTime</body><body package="Fit">start		startTime := Time millisecondClockValue</body></methods><methods><class-id>Fit.TimedActionFixture</class-id> <category>accessing</category><body package="Fit">time	^Timestamp now</body></methods><methods><class-id>Fit.TimedActionFixture</class-id> <category>private</category><body package="Fit">formatTime: aTimestamp 	| ws |	ws := WriteStream on: String new.	TimestampPrintPolicy 		print: aTimestamp		on: ws		using: 'hh:mm:ss'.	^ws contents</body></methods><methods><class-id>Fit.TimedActionFixture</class-id> <category>enumerating</category><body package="Fit">doCells: aParse 	| start split |	start := self time.	super doCells: aParse.	split := self time asMilliseconds - start asMilliseconds.	aParse last more: (Parse td: (self info: (self formatTime: start))).	aParse last more: (Parse 				td: (self info: (split &lt; 1000 								ifTrue: ['&amp;nbsp;']								ifFalse: [(split / 1000.0) asFloat printString])))</body><body package="Fit">doTable: aParse 	super doTable: aParse.	aParse parts parts last more: (Parse td: (self info: 'time')).	aParse parts parts last more: (Parse td: (self info: 'split'))</body></methods><methods><class-id>Fit.FitnesseFixtureLoader</class-id> <category>operations</category><body package="Fit">addNamespaceToPath: aString 	fixturePathElements add: aString</body><body package="Fit">load: aString 	| fixtureName fixture |	aString isEmpty 		ifTrue: [^FitFailureException raiseErrorString: 'No fixture name provided'].	fixtureName := FixtureName fromString: aString usingGracefulNames: true.	fixture := self instantiateFirstValidFixtureClass: fixtureName.	self addNamespaceToFixturePath: fixture.	^fixture</body></methods><methods><class-id>Fit.FitnesseFixtureLoader</class-id> <category>initialize-release</category><body package="Fit">initialize	fixturePathElements := Set with: 'Fit'</body></methods><methods><class-id>Fit.FitnesseFixtureLoader</class-id> <category>private</category><body package="Fit">addNamespaceToFixturePath: aFixture 	| namespace |	namespace := aFixture class environment.	self addNamespaceToPath: namespace fullName</body><body package="Fit">instantiateFirstValidFixtureClass: aFixtureName 	(aFixtureName potentialFixtureClassNames: fixturePathElements) do: 			[:each | 			[^self instantiateFixture: each] on: NoSuchFixtureException				do: [:ignoreAndTryTheNextCandidate | ]].	^self noSuchFixtureNamed: aFixtureName toString</body><body package="Fit">noSuchFixtureSignal	^NoSuchFitnesseFixture</body></methods><methods><class-id>Fit.FitnesseFixtureLoader class</class-id> <category>instance creation</category><body package="Fit">new	^super new initialize</body></methods><methods><class-id>Fit.QueryBinding</class-id> <category>operations</category><body package="Fit">doCell: aParse fixture: aFixture 	aFixture check: aParse adapter: adapter</body></methods><methods><class-id>Fit.NameConversion</class-id> <category>initialize-release</category><body package="Fit">javaName: aString	self smalltalkName: (self convertFromJavaName: aString)</body><body package="Fit">smalltalkName: aString	smalltalkName := aString</body></methods><methods><class-id>Fit.NameConversion</class-id> <category>accessing</category><body package="Fit">smalltalkName	^smalltalkName</body></methods><methods><class-id>Fit.NameConversion</class-id> <category>private</category><body package="Fit">convertFromJavaName: aString	| tokens |	aString fitTrimSeparators isEmpty ifTrue: [^aString].	tokens := aString tokensBasedOn: $..	^self reassembleTokens: tokens</body><body package="Fit">reassembleTokens: aCollection	| ws |	ws := WriteStream on: String new.	aCollection do: [:each | ws nextPutAll: each fitUppercaseFirst]		separatedBy: [ws nextPut: $.].	^ws contents</body></methods><methods><class-id>Fit.NameConversion class</class-id> <category>instance creation</category><body package="Fit">javaName: aString	^self new javaName: aString</body><body package="Fit">smalltalkName: aString	^self new smalltalkName: aString</body></methods><methods><class-id>Fit.FitDevelopmentSystem</class-id> <category>default actions</category><body package="Fit">pauseAction	super pauseAction.	self stop</body><body package="Fit">resumeAction	super resumeAction.	self start</body><body package="Fit">setUp	super setUp.	self start</body><body package="Fit">tearDown	super tearDown.	self stop</body></methods><methods><class-id>Fit.FitDevelopmentSystem</class-id> <category>private</category><body package="Fit">start	filename ifNil: [^self warnNoFilename].	self stop.	process := 			[(DevelopmentFitServer new)				filename: filename;				loop.			process := nil] 					forkAt: Processor userBackgroundPriority.	process name: 'Fit Server'</body><body package="Fit">stop	process ifNil: [^self].	process terminate.	process := nil</body><body package="Fit">warnNoFilename	Transcript		nextPutAll: 'Unable to start ';		nextPutAll: self class name;		cr;		nextPutAll: 'Configure a filename with:';		crtab;		nextPutAll: self class name;		nextPutAll: ' current filename: ''&lt;insert filename here&gt;'' asFilename.';		cr;		flush</body></methods><methods><class-id>Fit.FitDevelopmentSystem</class-id> <category>prerequisites</category><body package="Fit">prerequisiteSystems	#{DevelopmentSystem} 		ifDefinedDo: [:developmentSystem | ^Array with: developmentSystem with: RuntimeSystem].	^Array with: RuntimeSystem</body></methods><methods><class-id>Fit.FitDevelopmentSystem</class-id> <category>accessing</category><body package="Fit">canActivate	super canActivate ifFalse: [^false].	filename ifNotNil: [^true].	"icky side effect in a query method, but I'll live with it to get the helpful output"	self warnNoFilename.	^false</body><body package="Fit">filename: aFilename 	filename := aFilename</body></methods><methods><class-id>Fit.PrimitiveFixture</class-id> <category>comparing</category><body package="Fit">check: aParse actual: anObject 	self 		mark: aParse		right: (anObject class fitParse: aParse text) = anObject		actual: anObject fitToString</body></methods><methods><class-id>Fit.PrimitiveFixture class</class-id> <category>parsing</category><body package="Fit">parseBoolean: aParse 	^Boolean fitParse: aParse text</body><body package="Fit">parseDouble: aParse 	^Double fitParse: aParse text</body><body package="Fit">parseLong: aParse 	^Integer fitParse: aParse text</body></methods><methods><class-id>Fit.FitServer</class-id> <category>private</category><body package="Fit">basicProcess	self observeFixture.	super basicProcess</body><body package="Fit">exception: anException		| tables |	self printLine: 'Exception occurred!'.	self printLine: '&lt;t&gt;' expandMacros , anException errorString.	tables := Parse tag: 'span' body: 'Exception occurred: '.	fixture mark: tables exception: anException.	counts incrementExceptions.	self tableFinished: tables.	self tablesFinished: counts</body><body package="Fit">exit	super exit.	self printLine: ('&lt;t&gt;end results: &lt;1p&gt;' expandMacrosWith: counts)</body><body package="Fit">newFixture	self releaseFixture.	fixture := Fixture new.	self observeFixture.	^fixture</body><body package="Fit">observeFixture	fixture listener: fixtureListener</body><body package="Fit">processDocument: aString	| tables |	tables := Parse input: aString.	self newFixture doTables: tables.	self printLine: '&lt;t&gt;results: ' expandMacros , fixture counts printString.	counts tally: fixture counts</body><body package="Fit">readTable: aParse	| ws more |	ws := WriteStream on: String new.	more := aParse more.	aParse more: nil.	aParse trailer isNil ifTrue: [aParse trailer: ''].	aParse print: ws.	aParse more: more.	^ws contents asByteArrayEncoding: #'UTF-8'</body><body package="Fit">releaseFixture	fixture listener: self</body><body package="Fit">tableFinished: table	self sendTable: table</body><body package="Fit">tablesFinished: aCounts 	self writeCounts: aCounts</body></methods><methods><class-id>Fit.FitServer</class-id> <category>initialize-release</category><body package="Fit">initialize	super initialize.	fixture := Fixture new.	counts := Counts new.	fixtureListener := self</body><body package="Fit">release	self releaseFixture.	super release</body></methods><methods><class-id>Fit.FitServer</class-id> <category>accessing</category><body package="Fit">counts	^counts</body><body package="Fit">exitCode	^counts anyFailures ifTrue: [1] ifFalse: [0]</body></methods><methods><class-id>Fit.FitServer class</class-id> <category>instance creation</category><body package="Fit">runOnSocket: aSocketAccessor withToken: aString outputTo: aStream	^(self new)		socket: aSocketAccessor;		socketToken: aString;		outputStream: aStream;		run</body></methods><methods><class-id>Fit.GracefulNamer</class-id> <category>operations</category><body package="Fit">append: aCharacter 	finalName nextPut: aCharacter</body><body package="Fit">disgrace: aString 	finalName := WriteStream on: String new.	self nextState: OutOfWordState.	aString do: 			[:each | 			each isLetter 				ifTrue: [currentState letter: each]				ifFalse: 					[each isDigit 						ifTrue: [currentState digit: each]						ifFalse: [currentState other: each]]].	^finalName contents</body><body package="Fit">nextState: aClass 	currentState := aClass context: self</body></methods><methods><class-id>Fit.GracefulNamer class</class-id> <category>testing</category><body package="Fit">isGracefulName: aString 	| disgracefulNamePattern |	disgracefulNamePattern := '\w([.$]|\w)*[^.$]'.	^(aString matchesRegex: disgracefulNamePattern) not</body></methods><methods><class-id>Fit.GracefulNamer class</class-id> <category>utility</category><body package="Fit">disgrace: aString 	^self new disgrace: aString</body></methods><methods><class-id>Fit.Exceptions.NoSuchFieldException class</class-id> <category>instance creation</category><body package="Fit">named: aString 	^self messageText: 'Could not find field: ' , aString , '.'</body></methods><methods><class-id>Fit.FixtureName</class-id> <category>private</category><body package="Fit">addSelfAndSelfFixtureWithQualifier: qualifierString to: aCollection 	aCollection		add: qualifierString , nameAsString;		add: qualifierString , nameAsString , 'Fixture'</body></methods><methods><class-id>Fit.FixtureName</class-id> <category>accessing</category><body package="Fit">nameAsString: aString	nameAsString := aString</body><body package="Fit">potentialFixtureClassNames: aCollection 	| candidateClassNames |	candidateClassNames := OrderedCollection new.	self isFullyQualified 		ifFalse: 			[aCollection do: 					[:each | 					self addSelfAndSelfFixtureWithQualifier: each , '.' to: candidateClassNames]].	self addSelfAndSelfFixtureWithQualifier: '' to: candidateClassNames.	^candidateClassNames</body><body package="Fit">toString	^nameAsString</body></methods><methods><class-id>Fit.FixtureName</class-id> <category>testing</category><body package="Fit">isFullyQualified	^nameAsString includes: $.</body></methods><methods><class-id>Fit.FixtureName class</class-id> <category>instance creation</category><body package="Fit">fromString: aString 	^self fromString: aString usingGracefulNames: false</body><body package="Fit">fromString: aString usingGracefulNames: aBoolean	| fixtureName |	fixtureName := (ClassNameConversion javaName: aString) smalltalkName.	(aBoolean and: [GracefulNamer isGracefulName: fixtureName])		ifTrue: [fixtureName := GracefulNamer disgrace: fixtureName].	^self new nameAsString: fixtureName</body></methods><methods><class-id>Fit.Decorator.Util.DataType</class-id> <category>operations</category><body package="Fit">add: anObject to: aString repeat: anInteger		| originalValue |	originalValue := realType fitParse: aString.	^(originalValue fitAdd: anObject repeat: anInteger) fitToString</body><body package="Fit">fitParse: aString		^[incrementerType fitParse: aString]		on: Error		do:			[:ex | 			^InvalidInputException				raiseErrorString:					'value ''' , aString , ''' is not a valid ' , self printString]</body></methods><methods><class-id>Fit.Decorator.Util.DataType</class-id> <category>printing</category><body package="Fit">printOn: aStream		aStream nextPutAll: 'DataType (' , realType name asString , ')'</body></methods><methods><class-id>Fit.Decorator.Util.DataType</class-id> <category>accessing</category><body package="Fit">realType: aClass incrementer: anotherClass		realType := aClass.	incrementerType := anotherClass</body></methods><methods><class-id>Fit.Decorator.Util.DataType class</class-id> <category>private</category><body package="Fit">clearPredefinedTypes	"self clearPredefinedTypes"		PredefinedTypes := nil</body><body package="Fit">initializePredefinedTypes		IntegerType := self on: Integer.	DoubleType := self on: Float.	StringType := self on: String.	DateType := self on: Date incrementer: Integer.	PredefinedTypes := (Dictionary new)		at: 'int' put: IntegerType;		at: 'integer' put: IntegerType;		at: 'double' put: DoubleType;		at: 'string' put: StringType;		at: 'date' put: DateType;		yourself</body><body package="Fit">lookupType: aString		^self predefinedTypes		at: aString asLowercase		ifAbsent:			[self userDefinedTypes				at: aString asLowercase				ifAbsent: [self string]]</body><body package="Fit">predefinedTypes		PredefinedTypes ifNil: [self initializePredefinedTypes].	^PredefinedTypes</body><body package="Fit">userDefinedTypes		UserDefinedTypes ifNil: [UserDefinedTypes := Dictionary new].	^UserDefinedTypes</body></methods><methods><class-id>Fit.Decorator.Util.DataType class</class-id> <category>accessing</category><body package="Fit">clearUserDefinedDataTypes		UserDefinedTypes := nil</body><body package="Fit">date		^DateType</body><body package="Fit">double		^DoubleType</body><body package="Fit">integer		^IntegerType</body><body package="Fit">registerUserDefined: aClass as: aString		self userDefinedTypes		at: aString asLowercase		put: (self on: aClass)</body><body package="Fit">string		^StringType</body><body package="Fit">unregisterUserDefined: aString		UserDefinedTypes removeKey: aString asLowercase</body></methods><methods><class-id>Fit.Decorator.Util.DataType class</class-id> <category>instance creation</category><body package="Fit">instance: aString		^self lookupType: aString</body><body package="Fit">on: aClass		^self on: aClass incrementer: aClass</body><body package="Fit">on: aClass incrementer: anotherClass		^self new realType: aClass incrementer: anotherClass</body></methods><methods><class-id>Fit.RecallBinding</class-id> <category>operations</category><body package="Fit">doCell: aParse fixture: aFixture	| symbolName value |	symbolName := aParse text.	(Fixture hasSymbol: symbolName)		ifFalse: 			[^aFixture mark: aParse				exception: (FitFailureException						messageText: 'No such symbol: ' , symbolName)].	value := Fixture symbolAt: symbolName.	adapter field		ifNotNil: 			[adapter set: (adapter parse: value).			aParse addToBody: (aFixture info: '= ' , value)].	adapter method		ifNotNil: 			[aParse body: value.			aFixture check: aParse adapter: adapter]</body></methods><methods><class-id>Fit.ImportFixture</class-id> <category>enumerating</category><body package="Fit">doRow: row	| namespaceName fixtureLoader |	namespaceName := (PackageNameConversion javaName: row parts text)				smalltalkName.	fixtureLoader := FixtureLoader current.	(fixtureLoader isKindOf: FitnesseFixtureLoader)		ifFalse: 			[^self error: row parts				text: 'Fit.ImportFixture can only be used in Fitnesse'].	fixtureLoader addNamespaceToPath: namespaceName</body></methods><methods><class-id>Fit.FitFixtureLoader</class-id> <category>operations</category><body package="Fit">load: aString 	| fixtureName |	fixtureName := FixtureName fromString: aString.	^self instantiateFixture: fixtureName toString</body></methods><methods><class-id>Fit.FitFixtureLoader</class-id> <category>private</category><body package="Fit">noSuchFixtureSignal	^NoSuchFitFixture</body></methods><methods><class-id>Fit.CellComparator</class-id> <category>private</category><body package="Fit">compare	fixture 		mark: cell		right: (typeAdapter equals: expected and: result)		actual: (typeAdapter toString: result)</body><body package="Fit">mark: aParse exception: anError 	fixture mark: aParse exception: anError</body><body package="Fit">parseCell	^	[typeAdapter isRegex		ifTrue: [cell text]		ifFalse: [typeAdapter parse: cell text]]			on: Error			do: [:ex | ^Unparseable new]</body><body package="Fit">tryRelationalMatch	| cantParseException matcher |	cantParseException := CouldNotParseException input: cell text				expectedType: typeAdapter type.	result ifNil: [^self mark: cell exception: cantParseException].	matcher := FitMatcher expression: cell text parameter: result.		[	[fixture mark: cell right: matcher matches.	cell body: matcher message] 			on: FitMatcherException			do: [:ex | self mark: cell exception: cantParseException]] 			on: Error			do: [:ex | self mark: cell exception: ex]</body></methods><methods><class-id>Fit.CellComparator</class-id> <category>comparing</category><body package="Fit">compareCellToResult: aParse adapter: aTypeAdapter for: aFixture 	typeAdapter := aTypeAdapter.	cell := aParse.	fixture := aFixture.		[result := typeAdapter get.	expected := self parseCell.	(expected isKindOf: Unparseable) 		ifTrue: [self tryRelationalMatch]		ifFalse: [self compare]] 			on: Error			do: [:ex | self mark: cell exception: ex]</body></methods><methods><class-id>Fit.RegexQueryBinding</class-id> <category>operations</category><body package="Fit">doCell: aParse fixture: aFixture	aFixture check: aParse adapter: adapter</body></methods><methods><class-id>Fit.ClassNameConversion</class-id> <category>private</category><body package="Fit">extractInnermostClassFrom: aString	| result |	aString isEmpty ifTrue: [^aString].	result := (aString tokensBasedOn: $$) last.	result isEmpty ifTrue: [^aString].	^result</body><body package="Fit">reassembleTokens: aCollection	| tokens className newPackageName |	tokens := aCollection copy.	className := self extractInnermostClassFrom: tokens removeLast.	tokens isEmpty ifTrue: [^className].	newPackageName := super reassembleTokens: tokens.	^newPackageName , '.' , className</body></methods><methods><class-id>Fit.ClassNameConversion</class-id> <category>accessing</category><body package="Fit">classOrNil	smalltalkName isEmpty ifTrue: [^nil].	^smalltalkName asQualifiedReference ifDefinedDo: #yourself elseDo: [nil]</body></methods><methods><class-id>Fit.FileRunner</class-id> <category>accessing</category><body package="Fit">encoding: aSymbolOrNil	encoding := aSymbolOrNil</body><body package="Fit">fixture	^fixture</body><body package="Fit">fixture: aFixture	fixture := aFixture</body><body package="Fit">input: aString	input := aString</body><body package="Fit">output: aStream	output := aStream</body></methods><methods><class-id>Fit.FileRunner</class-id> <category>private</category><body package="Fit">arguments: aCollection	| inputFile outputFile |	aCollection size &gt;= 2 ifFalse: [self usageError].	inputFile := (aCollection at: aCollection size - 1) asFilename.	outputFile := aCollection last asFilename.	(fixture summary)		at: 'input file' put: inputFile fitAsAbsolute asString;		at: 'input update' put: inputFile modificationTimestamp;		at: 'output file' put: outputFile fitAsAbsolute asString.	encoding ifNotNil: [inputFile := inputFile withEncoding: encoding].	input := inputFile contentsOfEntireFile.	output := outputFile writeStream</body><body package="Fit">exception: ex 	tables := Parse tag: 'body' body: 'Unable to parse input. Input ignored'.	^fixture mark: tables exception: ex</body><body package="Fit">exit	output close</body><body package="Fit">usageError	self 		error: 'An input file and output file must be the last two arguments on the command line.'</body></methods><methods><class-id>Fit.FileRunner</class-id> <category>operations</category><body package="Fit">process		[(input indexOfSubCollection: '&lt;wiki&gt;' startingAt: 1) &gt; 0 		ifTrue: 			[tables := Parse input: input tags: #('wiki' 'table' 'tr' 'td').			fixture doTables: tables parts]		ifFalse: 			[tables := Parse input: input tags: #('table' 'tr' 'td').			fixture doTables: tables]] 			on: Error			do: [:ex | self exception: ex].	tables print: output</body><body package="Fit">runWithArguments: aCollection 	self arguments: aCollection.	Session beFitWhile: [self process].	self exit</body></methods><methods><class-id>Fit.FileRunner</class-id> <category>initialize/release</category><body package="Fit">initialize	fixture := Fixture new</body></methods><methods><class-id>Fit.FileRunner class</class-id> <category>instance creation</category><body package="Fit">new	^super new initialize</body><body package="Fit">runInput: inputFile output: outputFile	^self runInput: inputFile output: outputFile withEncoding: nil</body><body package="Fit">runInput: inputFile output: outputFile withEncoding: aSymbolOrNil	^(self new)		encoding: aSymbolOrNil;		runWithArguments: (Array with: inputFile with: outputFile);		yourself</body></methods><methods><class-id>Fit.Decorator.IncrementColumnsValue</class-id> <category>private</category><body package="Fit">run: aFixture table: aParse		| table |	table := Table fromParse: aParse.	[table incrementValuesInColumn: columnName by: delta]		on: InvalidInputException		do:			[:ex | 			"ignored?!?"			].	super run: aFixture table: aParse</body><body package="Fit">setupDecorator: aCollection		aCollection size = 3		ifFalse:			[^InvalidInputException raiseErrorString:					'Column name, Data type, and Delta value must be specified'].	columnName := aCollection first.	delta := Delta		type: (aCollection at: 2)		value: aCollection last.	summary		at: self class columnNameKey			put: columnName;		at: self class deltaKey			put: delta</body><body package="Fit">updateColumnsBasedOnResults: aParse	"Nothing to do"</body></methods><methods><class-id>Fit.Decorator.IncrementColumnsValue class</class-id> <category>constants</category><body package="Fit">columnNameKey		^'columnName'</body><body package="Fit">deltaKey		^'delta'</body></methods><methods><class-id>Fit.FitnesseMarkup</class-id> <category>annotation</category><body package="Fit">formatError: aString 	^'&lt;hr&gt;&lt;pre&gt;&lt;div class="fit_stacktrace"&gt;' , aString , '&lt;/div&gt;&lt;/pre&gt;'</body><body package="Fit">ignore: aParse 	aParse addToTag: ' class="ignore"'</body><body package="Fit">info: aString 	^' &lt;span class="fit_grey"&gt;' , aString , '&lt;/span&gt;'</body><body package="Fit">label: aString 	^' &lt;span class="fit_label"&gt;' , aString , '&lt;/span&gt;'</body><body package="Fit">markError: aParse 	aParse addToTag: ' class="error"'</body><body package="Fit">right: aParse 	aParse addToTag: ' class="pass"'</body><body package="Fit">textFromParse: aParse	^aParse fitnesseText</body><body package="Fit">wrong: aParse 	aParse addToTag: ' class="fail"'</body></methods><methods><class-id>Fit.Field</class-id> <category>initialize-release</category><body package="Fit">named: aString 	getSelector := aString asSymbol.	setSelector := (aString , ':') asSymbol</body></methods><methods><class-id>Fit.Field</class-id> <category>accessing</category><body package="Fit">getFrom: anObject 	^anObject perform: getSelector</body><body package="Fit">getSelector	^getSelector</body><body package="Fit">name	^getSelector</body><body package="Fit">set: anObject in: targetObject 	targetObject perform: setSelector with: anObject</body><body package="Fit">setSelector	^setSelector</body></methods><methods><class-id>Fit.Field</class-id> <category>testing</category><body package="Fit">existsIn: aClass 	^(aClass canUnderstand: getSelector) 		or: [aClass canUnderstand: setSelector]</body></methods><methods><class-id>Fit.Field class</class-id> <category>instance creation</category><body package="Fit">named: aString 	^self new named: aString</body></methods><methods><class-id>Fit.Decorator.Loop</class-id> <category>initialize-release</category><body package="Fit">initialize		super initialize.	counter := 0</body></methods><methods><class-id>Fit.Decorator.Loop</class-id> <category>private</category><body package="Fit">run: aFixture table: aParse		counter timesRepeat: [super run: aFixture table: aParse]</body><body package="Fit">setupDecorator: aCollection		aCollection size = 1		ifFalse:			[^InvalidInputException raiseErrorString: 'Loop count must be specified'].	counter := Number fitParse: aCollection first.	summary		at: self class countKey		put: counter</body><body package="Fit">updateColumnsBasedOnResults: aParse	"Nothing to do"</body></methods><methods><class-id>Fit.Decorator.Loop class</class-id> <category>constants</category><body package="Fit">countKey		^'count'</body></methods><methods><class-id>Fit.FitSystem</class-id> <category>running</category><body package="Fit">fit: argumentStream 	&lt;option: '-fit'&gt;	FileRunner new 		runWithArguments: (CommandLineInterest argumentsFrom: argumentStream).	ObjectMemory quit</body><body package="Fit">fitnesse: argumentStream	&lt;option: '-fitnesse'&gt;	| arguments runner serverClass |	arguments := CommandLineInterest argumentsFrom: argumentStream.	serverClass := (ClassNameConversion javaName: arguments removeFirst) classOrNil.	runner := serverClass new outputStream: OS.Stdout.	ObjectMemory quitWithError: (runner runWithArguments: arguments)</body></methods><methods><class-id>Core.Object class</class-id> <category>fit-utilities</category><body package="Fit">asFitMethodSignature	^MethodSignature returning: self</body><body package="Fit">fitTypeAdapter	^TypeAdapter new type: self</body><body package="Fit">fitTypeSignaturePragmas	&lt;pragmas: #instance&gt;	&lt;pragmas: #class&gt;	^#(#fitTakes: #fitReturns:)</body></methods><methods><class-id>Core.Object</class-id> <category>fit-utilities</category><body package="Fit">fitToString	^self printString</body></methods><methods><class-id>Core.Collection</class-id> <category>fit-utilities</category><body package="Fit">asFitMethodSignature	^MethodSignature returning: self</body></methods><methods><class-id>Core.Character class</class-id> <category>fit-utilities</category><body package="Fit">fitParse: aString	aString isEmpty ifTrue: [^self space].	aString = 'null' ifTrue: [^nil].	^aString first</body></methods><methods><class-id>OS.Filename</class-id> <category>converting</category><body package="Fit">fitAsAbsolute	^self isAbsolute 		ifTrue: [self]		ifFalse: [self class defaultDirectory construct: publicName]</body></methods><methods><class-id>Core.Symbol class</class-id> <category>fit-utilities</category><body package="Fit">fitParse: aString 	^aString asSymbol</body><body package="Fit">fitTypeAdapter	^TypeAdapter new type: self</body></methods><methods><class-id>Core.Symbol</class-id> <category>fit-utilities</category><body package="Fit">fitToString	^self asString</body></methods><methods><class-id>Core.Double</class-id> <category>fit-utilities</category><body package="Fit">fitToString		| string |	string := self printString.	string last = $d		ifTrue:			[^string				copyFrom: 1				to: string size - 1]</body></methods><methods><class-id>Core.Set</class-id> <category>fit-utilities</category><body package="Fit">fitTypeAdapter	^(TypeAdapter adapterFor: self class) componentAdapters: self any</body></methods><methods><class-id>Core.Number class</class-id> <category>fit-utilities</category><body package="Fit">fitParse: aString	| rs result |	aString = 'null' ifTrue: [^nil].	rs := aString readStream.	rs peekFor: $+.	rs atEnd ifTrue: [^self error: 'Invalid number format'].	result := self readFrom: rs.	rs atEnd ifFalse: [^self error: 'Invalid number format'].	^result</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>fit-utilities</category><body package="Fit">fitToString	^'null'</body></methods><methods><class-id>Core.Boolean class</class-id> <category>fit-utilities</category><body package="Fit">fitParse: aString	aString = 'null' ifTrue: [^nil].	^#('true' 'yes' '1' 'y' '+') includes: aString asLowercase</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>arithmetic</category><body package="Fit">fitAdd: aNumber repeat: anInteger		^self + (aNumber * anInteger)</body></methods><methods><class-id>Kernel.Context</class-id> <category>printing</category><body package="Fit">fitStackTrace	"This is mostly an inline of DebuggerService class&gt;&gt;shortStackFor:ofSize:, but allows up to 80 chars per frame, 	hard-codes the size to 30, and avoids the dependency on DebuggerService."	| stream ctx |	stream := WriteStream on: (String new: 400).	ctx := self.	30 timesRepeat: 			[ctx isNil				ifFalse: 					[stream						nextPutAll: (ctx printString contractTo: 80);						cr.					ctx := ctx sender]].	stream position &gt; 0 ifTrue: [stream skip: -1].	^stream contents</body></methods><methods><class-id>Core.CharacterArray class</class-id> <category>fit-utilities</category><body package="Fit">fitParse: aString	^aString</body><body package="Fit">fitTypeAdapter	^StringTypeAdapter new</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>fit-utilities</category><body package="Fit">fitAdd: aString repeat: anInteger		| ws |	ws := (String new: self size + (aString size * anInteger)) writeStream.	ws nextPutAll: self.	anInteger timesRepeat: [ws nextPutAll: aString].	^ws contents</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Fit">fitLowercaseFirst	| result |	self isEmpty ifTrue: [^self].	result := self copy.	result at: 1 put: self first asLowercase.	^result</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>fit-utilities</category><body package="Fit">fitToString	^self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Fit">fitTrimSeparators	"Return a copy of the receiver that has leading and trailing separators removed."	| size index |	(size := self size) == 0 ifTrue: [^self species new: 0].	index := 1.	[(self at: index) isSeparator] whileTrue: 			[index == size ifTrue: [^self species new: 0].			index := index + 1].	[(self at: size) isSeparator] whileTrue: 			[index == size ifTrue: [^self species new: 0].			size := size - 1].	^self copyFrom: index to: size</body><body package="Fit">fitUppercaseFirst	| result |	self isEmpty ifTrue: [^self].	result := self copy.	result at: 1 put: self first asUppercase.	^result</body></methods><methods><class-id>Core.Array class</class-id> <category>fit-utilities</category><body package="Fit">fitTypeAdapter	^ArrayTypeAdapter new</body></methods><methods><class-id>Core.Array</class-id> <category>fit-utilities</category><body package="Fit">fitTypeAdapter	"This method allows using a shortcut when specifying TypeAdapters for collections.	For example, instead of saying ArrayTypeAdapter componentAdapter: NumberTypeAdapter new, 	we can say Array with: Number.  	This method also works for pragma-based type specifications for other collection types.  For example, 	we can use a #fitTakes: or #fitReturns: pragma with an array containing more than one element: 	#( #{OrderedCollection} #{Number} ).  With this kind of  type specification, the first element of the	arrray is the collection type and the second is the element type."	| types adapter |	types := self asOrderedCollection				collect: [:each | TypeAdapter adapterFor: each].	adapter := self size = 1				ifTrue: [TypeAdapter adapterFor: self class]				ifFalse: [types removeFirst].	adapter componentAdapters: types.	^adapter</body></methods><methods><class-id>Core.Date class</class-id> <category>fit-utilities</category><body package="Fit">fitParse: aString 	^self readFrom: aString readStream</body></methods><methods><class-id>Core.Date</class-id> <category>fit-utilities</category><body package="Fit">fitAdd: daysInteger repeat: repeatInteger		^self addDays: daysInteger * repeatInteger</body><body package="Fit">fitToString		^self shortPrintString</body></methods><initialize><class-id>Fit.Parse</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ArithmeticValue</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class></st-source>