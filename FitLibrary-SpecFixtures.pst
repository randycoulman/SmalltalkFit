<?xml version="1.0"?><st-source><!-- Name: FitLibrary-SpecFixturesNotice:                     GNU GENERAL PUBLIC LICENSE                       Version 2, June 1991 Copyright (C) 1989, 1991 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.                            Preamble  The licenses for most software are designed to take away yourfreedom to share and change it.  By contrast, the GNU General PublicLicense is intended to guarantee your freedom to share and change freesoftware- to make sure the software is free for all its users.  ThisGeneral Public License applies to most of the Free SoftwareFoundation's software and to any other program whose authors commit tousing it.  (Some other Free Software Foundation software is covered bythe GNU Lesser General Public License instead.)  You can apply it toyour programs, too.  When we speak of free software, we are referring to freedom, notprice.  Our General Public Licenses are designed to make sure that youhave the freedom to distribute copies of free software (and charge forthis service if you wish), that you receive source code or can get itif you want it, that you can change the software or use pieces of itin new free programs; and that you know you can do these things.  To protect your rights, we need to make restrictions that forbidanyone to deny you these rights or to ask you to surrender the rights.These restrictions translate to certain responsibilities for you if youdistribute copies of the software, or if you modify it.  For example, if you distribute copies of such a program, whethergratis or for a fee, you must give the recipients all the rights thatyou have.  You must make sure that they, too, receive or can get thesource code.  And you must show them these terms so they know theirrights.  We protect your rights with two steps: (1) copyright the software, and(2) offer you this license which gives you legal permission to copy,distribute and/or modify the software.  Also, for each author's protection and ours, we want to make certainthat everyone understands that there is no warranty for this freesoftware.  If the software is modified by someone else and passed on, wewant its recipients to know that what they have is not the original, sothat any problems introduced by others will not reflect on the originalauthors' reputations.  Finally, any free program is threatened constantly by softwarepatents.  We wish to avoid the danger that redistributors of a freeprogram will individually obtain patent licenses, in effect making theprogram proprietary.  To prevent this, we have made it clear that anypatent must be licensed for everyone's free use or not licensed at all.  The precise terms and conditions for copying, distribution andmodification follow.                    GNU GENERAL PUBLIC LICENSE   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION  0. This License applies to any program or other work which containsa notice placed by the copyright holder saying it may be distributedunder the terms of this General Public License.  The "Program", below,refers to any such program or work, and a "work based on the Program"means either the Program or any derivative work under copyright law:that is to say, a work containing the Program or a portion of it,either verbatim or with modifications and/or translated into anotherlanguage.  (Hereinafter, translation is included without limitation inthe term "modification".)  Each licensee is addressed as "you".Activities other than copying, distribution and modification are notcovered by this License; they are outside its scope.  The act ofrunning the Program is not restricted, and the output from the Programis covered only if its contents constitute a work based on theProgram (independent of having been made by running the Program).Whether that is true depends on what the Program does.  1. You may copy and distribute verbatim copies of the Program'ssource code as you receive it, in any medium, provided that youconspicuously and appropriately publish on each copy an appropriatecopyright notice and disclaimer of warranty; keep intact all thenotices that refer to this License and to the absence of any warranty;and give any other recipients of the Program a copy of this Licensealong with the Program.You may charge a fee for the physical act of transferring a copy, andyou may at your option offer warranty protection in exchange for a fee.  2. You may modify your copy or copies of the Program or any portionof it, thus forming a work based on the Program, and copy anddistribute such modifications or work under the terms of Section 1above, provided that you also meet all of these conditions:    a) You must cause the modified files to carry prominent notices    stating that you changed the files and the date of any change.    b) You must cause any work that you distribute or publish, that in    whole or in part contains or is derived from the Program or any    part thereof, to be licensed as a whole at no charge to all third    parties under the terms of this License.    c) If the modified program normally reads commands interactively    when run, you must cause it, when started running for such    interactive use in the most ordinary way, to print or display an    announcement including an appropriate copyright notice and a    notice that there is no warranty (or else, saying that you provide    a warranty) and that users may redistribute the program under    these conditions, and telling the user how to view a copy of this    License.  (Exception: if the Program itself is interactive but    does not normally print such an announcement, your work based on    the Program is not required to print an announcement.)These requirements apply to the modified work as a whole.  Ifidentifiable sections of that work are not derived from the Program,and can be reasonably considered independent and separate works inthemselves, then this License, and its terms, do not apply to thosesections when you distribute them as separate works.  But when youdistribute the same sections as part of a whole which is a work basedon the Program, the distribution of the whole must be on the terms ofthis License, whose permissions for other licensees extend to theentire whole, and thus to each and every part regardless of who wrote it.Thus, it is not the intent of this section to claim rights or contestyour rights to work written entirely by you; rather, the intent is toexercise the right to control the distribution of derivative orcollective works based on the Program.In addition, mere aggregation of another work not based on the Programwith the Program (or with a work based on the Program) on a volume ofa storage or distribution medium does not bring the other work underthe scope of this License.  3. You may copy and distribute the Program (or a work based on it,under Section 2) in object code or executable form under the terms ofSections 1 and 2 above provided that you also do one of the following:    a) Accompany it with the complete corresponding machine-readable    source code, which must be distributed under the terms of Sections    1 and 2 above on a medium customarily used for software interchange; or,    b) Accompany it with a written offer, valid for at least three    years, to give any third party, for a charge no more than your    cost of physically performing source distribution, a complete    machine-readable copy of the corresponding source code, to be    distributed under the terms of Sections 1 and 2 above on a medium    customarily used for software interchange; or,    c) Accompany it with the information you received as to the offer    to distribute corresponding source code.  (This alternative is    allowed only for noncommercial distribution and only if you    received the program in object code or executable form with such    an offer, in accord with Subsection b above.)The source code for a work means the preferred form of the work formaking modifications to it.  For an executable work, complete sourcecode means all the source code for all modules it contains, plus anyassociated interface definition files, plus the scripts used tocontrol compilation and installation of the executable.  However, as aspecial exception, the source code distributed need not includeanything that is normally distributed (in either source or binaryform) with the major components (compiler, kernel, and so on) of theoperating system on which the executable runs, unless that componentitself accompanies the executable.If distribution of executable or object code is made by offeringaccess to copy from a designated place, then offering equivalentaccess to copy the source code from the same place counts asdistribution of the source code, even though third parties are notcompelled to copy the source along with the object code.  4. You may not copy, modify, sublicense, or distribute the Programexcept as expressly provided under this License.  Any attemptotherwise to copy, modify, sublicense or distribute the Program isvoid, and will automatically terminate your rights under this License.However, parties who have received copies, or rights, from you underthis License will not have their licenses terminated so long as suchparties remain in full compliance.  5. You are not required to accept this License, since you have notsigned it.  However, nothing else grants you permission to modify ordistribute the Program or its derivative works.  These actions areprohibited by law if you do not accept this License.  Therefore, bymodifying or distributing the Program (or any work based on theProgram), you indicate your acceptance of this License to do so, andall its terms and conditions for copying, distributing or modifyingthe Program or works based on it.  6. Each time you redistribute the Program (or any work based on theProgram), the recipient automatically receives a license from theoriginal licensor to copy, distribute or modify the Program subject tothese terms and conditions.  You may not impose any furtherrestrictions on the recipients' exercise of the rights granted herein.You are not responsible for enforcing compliance by third parties tothis License.  7. If, as a consequence of a court judgment or allegation of patentinfringement or for any other reason (not limited to patent issues),conditions are imposed on you (whether by court order, agreement orotherwise) that contradict the conditions of this License, they do notexcuse you from the conditions of this License.  If you cannotdistribute so as to satisfy simultaneously your obligations under thisLicense and any other pertinent obligations, then as a consequence youmay not distribute the Program at all.  For example, if a patentlicense would not permit royalty-free redistribution of the Program byall those who receive copies directly or indirectly through you, thenthe only way you could satisfy both it and this License would be torefrain entirely from distribution of the Program.If any portion of this section is held invalid or unenforceable underany particular circumstance, the balance of the section is intended toapply and the section as a whole is intended to apply in othercircumstances.It is not the purpose of this section to induce you to infringe anypatents or other property right claims or to contest validity of anysuch claims; this section has the sole purpose of protecting theintegrity of the free software distribution system, which isimplemented by public license practices.  Many people have madegenerous contributions to the wide range of software distributedthrough that system in reliance on consistent application of thatsystem; it is up to the author/donor to decide if he or she is willingto distribute software through any other system and a licensee cannotimpose that choice.This section is intended to make thoroughly clear what is believed tobe a consequence of the rest of this License.  8. If the distribution and/or use of the Program is restricted incertain countries either by patents or by copyrighted interfaces, theoriginal copyright holder who places the Program under this Licensemay add an explicit geographical distribution limitation excludingthose countries, so that distribution is permitted only in or amongcountries not thus excluded.  In such case, this License incorporatesthe limitation as if written in the body of this License.  9. The Free Software Foundation may publish revised and/or new versionsof the General Public License from time to time.  Such new versions willbe similar in spirit to the present version, but may differ in detail toaddress new problems or concerns.Each version is given a distinguishing version number.  If the Programspecifies a version number of this License which applies to it and "anylater version", you have the option of following the terms and conditionseither of that version or of any later version published by the FreeSoftware Foundation.  If the Program does not specify a version number ofthis License, you may choose any version ever published by the Free SoftwareFoundation.  10. If you wish to incorporate parts of the Program into other freeprograms whose distribution conditions are different, write to the authorto ask for permission.  For software which is copyrighted by the FreeSoftware Foundation, write to the Free Software Foundation; we sometimesmake exceptions for this.  Our decision will be guided by the two goalsof preserving the free status of all derivatives of our free software andof promoting the sharing and reuse of software generally.                            NO WARRANTY  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTYFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHENOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIESPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSEDOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK ASTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THEPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,REPAIR OR CORRECTION.  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITINGWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/ORREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISINGOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITEDTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BYYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHERPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THEPOSSIBILITY OF SUCH DAMAGES.                     END OF TERMS AND CONDITIONS            How to Apply These Terms to Your New Programs  If you develop a new program, and you want it to be of the greatestpossible use to the public, the best way to achieve this is to make itfree software which everyone can redistribute and change under these terms.  To do so, attach the following notices to the program.  It is safestto attach them to the start of each source file to most effectivelyconvey the exclusion of warranty; and each file should have at leastthe "copyright" line and a pointer to where the full notice is found.    <one line to give the program's name and a brief idea of what it does.>    Copyright (C) <year>  <name of author>    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.Also add information on how to contact you by electronic and paper mail.If the program is interactive, make it output a short notice like thiswhen it starts in an interactive mode:    Gnomovision version 69, Copyright (C) year name of author    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.    This is free software, and you are welcome to redistribute it    under certain conditions; type `show c' for details.The hypothetical commands `show w' and `show c' should show the appropriateparts of the General Public License.  Of course, the commands you use maybe called something other than `show w' and `show c'; they could even bemouse-clicks or menu items- whatever suits your program.You should also get your employer (if you work as a programmer) or yourschool, if any, to sign a "copyright disclaimer" for the program, ifnecessary.  Here is a sample; alter the names:  Yoyodyne, Inc., hereby disclaims all copyright interest in the program  `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989  Ty Coon, President of ViceThis General Public License does not permit incorporating your program intoproprietary programs.  If your program is a subroutine library, you mayconsider it more useful to permit linking proprietary applications with thelibrary.  If this is what you want to do, use the GNU Lesser GeneralPublic License instead of this License.Comment: This package contains the fixture and support code to run the FitLibrary specification tests.# Smalltalk FitSmalltalk Fit is a Smalltalk implementation of Ward Cunningham's [Framework for Integrated Tests](http://fit.c2.com), [Fitnesse](http://www.fitnesse.org), and Rick Mugridge's [FitLibrary](http://fitlibrary.sourceforge.net).This version contains the equivalent features of:* fit-java-1.1* fitnesse-20121220* FitLibrary-2.0   Copyright (C) 2004-2013 Randy Coulman    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.See the copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.DbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1545DbUsername: randyDbVersion: 33DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Fit' '') #(#any 'FitLibrary' '') #(#any 'FitLibrary-Internals' ''))PackageName: FitLibrary-SpecFixturesParcel: #('FitLibrary-SpecFixtures')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Fit' #componentType #package) #(#name 'FitLibrary' #componentType #package) #(#name 'FitLibrary-Internals' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Fit' '') #('FitLibrary' '') #('FitLibrary-Internals' ''))PrintStringCache: (33,randy)Version: 33Date: 7:21:06 AM May 24, 2013 --><time-stamp>From VisualWorks® Personal Use Edition, 7.9.1 of October 18, 2012 on May 24, 2013 at 7:21:06 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Specify</name><environment>Fitlibrary</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fitlibrary.*			private Fitlibrary.Specify.Eg.*			private FitlibraryInternals.*			private Fitlibrary.Specify.Parser.*			private Fit.Specify.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>DynamicVariable</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private FitlibraryInternals.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>ListParser</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Specify.Eg.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>ValueObject</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Specify.Eg.*			private Fitlibrary.*			private Fitlibrary.Traverse.*			private FitlibraryInternals.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>SetParser</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Specify.Eg.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Eg</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Set</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>SpecialAction</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private FitlibraryInternals.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Calculate</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fitlibrary.Specify.Eg.*			private FitlibraryInternals.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Constraint</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>ArrayParser</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Global</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private FitlibraryInternals.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Specify</name><environment>FitlibraryGeneric</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>EntityParser</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Specify.Eg.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Autowrap</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>MapParser</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Workflow</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fitlibrary.Specify.Eg.*			private FitlibraryInternals.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>SpeciallyNamedPackage</name><environment>Fitlibrary</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Parser</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.*			private Fit.*			private Fitlibrary.Specify.*			private Fitlibrary.Specify.Eg.*			private Fitlibrary.Traverse.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>CollectionSetUp</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.*			private Fitlibrary.Specify.Eg.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Domain</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Specify.Eg.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>MissingMethod</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Utility</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>MissingProperty</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Suite</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Traverse.Workflow.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Plugin</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>MapTraverse</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Specify.Eg.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Specify</name><environment>Fit</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>InitialClass</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Exception</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.*			private Fit.Exceptions.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Select</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>DefinedAction</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>SpecialisedTables</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			private FitlibraryInternals.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Collections</name><environment>FitlibraryGeneric.Specify</environment><private>false</private><imports>			private Smalltalk.*			private Fitlibrary.Specify.Eg.*			private Fitlibrary.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Access</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><name-space><name>Collection</name><environment>Fitlibrary.Specify</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></name-space><class><name>AnyCharactersInActions</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.AnyCharactersInActions</class-id><body>Spec class for mapping non-identifier characters to names.</body></comment><class><name>Value</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SelfStartingActionFixture</name><environment>Fitlibrary.Specify</environment><super>Fit.ActionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SelfStartingActionFixture</class-id><body>An ActionFixture that uses itself as the actor.  Supports running ActionFixture specs.</body></comment><class><name>CalculateFixtureUnderTest</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CalculateFixtureUnderTest</class-id><body>A fixture for testing CalculateFixture.Instance Variables	count	&lt;Integer&gt;	A number that is manipulated by the test.</body></comment><class><name>MyColumnFixture</name><environment>Fit.Specify</environment><super>Fit.ColumnFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.MyColumnFixture</class-id><body>Simple ColumnFixture for testing FitLibrary flow mode.Instance Variables	x	&lt;Integer&gt;	A sample integer.</body></comment><class><name>PrimitiveArrayFixtureUnderTestMixed</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.PrimitiveArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureUnderTestMixed</class-id><body>A fixture for testing PrimitiveArrayFixture.</body></comment><class><name>CamelRowFixtureUnderTest</name><environment>Fitlibrary.Specify</environment><super>Fit.RowFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CamelRowFixtureUnderTest</class-id><body>A Fixture for testing RowFixture behavior (also used for testing ArrayFixture, indirectly).</body></comment><class><name>SetFixtureUnderTest2</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.SetFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SetFixtureUnderTest2</class-id><body>A fixture for testing SetFixture.</body></comment><class><name>ArrayFixtureUnderTestWithMap</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestWithMap</class-id><body>A Fixture for testing ArrayFixture with embedded Dictionaries.</body></comment><class><name>RuleTableExampleSut</name><environment>Fitlibrary.Specify.Calculate</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>in in2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.RuleTableExampleSut</class-id><body>Fixturing support for testing RuleTable behavior.Instance Variables	in	&lt;Integer&gt;	An example input.	in2	&lt;Integer&gt;	Another example input.</body></comment><class><name>ObjectDelegateForDate</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MyPointStringConstructor</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.MyPointStringConstructor</class-id><body>A variant of MyPoint that uses a #fromString: method for construction, rather than #fitParse:. Fixturing for testing value object parsing.Instance Variables	x	&lt;Integer&gt;	The x coordinate.	y	&lt;Integer&gt;	The y coordinate.</body></comment><class><name>SimplePhone</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>phone </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>PropertyOfInterfaceType</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.PropertyOfInterfaceType</class-id><body>Fixturing support for testing domain object setup of an interface implementation.Instance Variables	user	&lt;AbstractUserAsInterface&gt;	A sample domain object.</body></comment><class><name>FixedPointDelegate</name><environment>Fitlibrary.Specify.ValueObject</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExceptionThrownByToString</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SetFixtureUnderTest3</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.SetFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SetFixtureUnderTest3</class-id><body>A fixture for testing SetFixture.</body></comment><class><name>EmptyCellIsNull</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.EmptyCellIsNull</class-id><body>Fixturing for testing null values in a domain object setup table.Instance Variables	user	&lt;UserWithManager&gt;	A sample domain object.</body></comment><class><name>ExceptionThrownByShow</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ParseMyFixedPointAsStringWithDelegate</name><environment>Fitlibrary.Specify.ValueObject</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>UserAdapter</name><environment>Fitlibrary.Specify.EntityParser</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user users </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>UsePropertyEditor</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>C</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>s </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.C</class-id><body>Simple class for testing PrimitiveArrayFixture with an array of non-primitives.Instance Variables	s	&lt;String&gt;	The string representation of the object.</body></comment><class><name>GenericCollectionsUseObjectFactory</name><environment>FitlibraryGeneric.Specify.Collections</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aList aSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ParseMyPoint</name><environment>Fitlibrary.Specify.ValueObject</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ValueObject.ParseMyPoint</class-id><body>Fixturing for testing value object parsing.</body></comment><class><name>Account</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id paymentHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.Account</class-id><body>Simple account class for testing domain object traverses.Instance Variables	id	&lt;Integer&gt;	The unique identifier of the account.	paymentHistory	&lt;String&gt;	A description of the payment history.</body></comment><class><name>ExceptionThrownByNestedEquals</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ColourMap</name><environment>Fitlibrary.Specify.MapTraverse</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SetUpAndTearDownCalled</name><environment>Fitlibrary.Specify.Constraint</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isSetUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Constraint.SetUpAndTearDownCalled</class-id><body>Fixturing support for checking that setUp and tearDown are sent for a ConstraintFixture/Traverse.Instance Variables	isSetUp	&lt;Boolean&gt;	true if setUp was sent; false otherwise.</body></comment><class><name>Phone</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>country region number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.Phone</class-id><body>A simple phone number class for testing domain objects.Instance Variables	country	&lt;Integer&gt;	The country code.	number	&lt;Integer&gt;	The region code.	region	&lt;Integer&gt;	The phone number.</body></comment><class><name>BadClassFromClassFactoryMethod</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.BadClassFromClassFactoryMethod</class-id><body>Fixturing support for testing domain object setup.</body></comment><class><name>Entity</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ParserDelegateMethod</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.ParserDelegateMethod</class-id><body>Fixturing class for testing parser delegate methods.</body></comment><class><name>MyOtherDoFixture</name><environment>Fitlibrary.Specify.Suite</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>FirstSelectTraverse</name><environment>Fitlibrary.Specify.Select</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Select.FirstSelectTraverse</class-id><body>A DoTraverse for testing the behavior of the 'add named' and 'select' special actions.</body></comment><class><name>RuleTableWithResetAndExecute</name><environment>Fitlibrary.Specify.Calculate</environment><super>Fitlibrary.RuleTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.RuleTableWithResetAndExecute</class-id><body>An example RuleTable for testing reset and execute operations.</body></comment><class><name>PrimitiveArrayFixtureUnderTestEmpty</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.PrimitiveArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureUnderTestEmpty</class-id><body>A fixture for testing PrimitiveArrayFixture.</body></comment><class><name>ObjectDelegate</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ArrayFixtureUnderTestWithValueObjects</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestWithValueObjects</class-id><body>A Fixture for testing ArrayFixture.</body></comment><class><name>AggregateDomainObject</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>book </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Pojo</name><environment>Fitlibrary.Specify.Autowrap</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Autowrap.Pojo</class-id><body>A simple class for testing auto-wrapping of PO(S)O's with DoTraverse.</body></comment><class><name>SelectWithSetUpFailing</name><environment>Fitlibrary.Specify.Select</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Select.SelectWithSetUpFailing</class-id><body>A fixture used for testing the 'select' special action.</body></comment><class><name>Match</name><environment>Fitlibrary.Specify.ArrayParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayParser.Match</class-id><body>Fixturing support for testing array parsing.</body></comment><class><name>TeeTree</name><environment>Fitlibrary.Specify</environment><super>FitlibraryInternals.Tree</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.TeeTree</class-id><body>An alternate Tree implementation for testing tree parsing.Instance Variables	tree	&lt;Tree&gt;	The tree being wrapped by this tree.</body></comment><class><name>Person</name><environment>Fitlibrary.Specify.Plugin</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>InnerCalculate3</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CalculateFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.InnerCalculate3</class-id><body>A fixture for testing CalculateFixture.  Corresponds to a nested class in the original Java.</body></comment><class><name>Colour</name><environment>FitlibraryGeneric.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>colour point </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MyValueHolder</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.MyValueHolder</class-id><body>Fixturing for testing value object parsing.Instance Variables	value	&lt;MyValue&gt;	The value being held.</body></comment><class><name>Keywords</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sum </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.Keywords</class-id><body>Class for testing the use of keywords in do-style tables.Instance Variables	sum	&lt;Double&gt;	The sum being accumulated.</body></comment><class><name>UserAdapter</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.UserAdapter</class-id><body>An adapter that adapts an existing User class to the Fitlibrary DomainFixtured interface.</body></comment><class><name>ExceptionThrownByGetter</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Value2</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Book</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes authors publisher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SetUpMap</name><environment>Fitlibrary.Specify.CollectionSetUp</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iOUMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpMap</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.CollectionSetUp.SetUpSet==========================================================The following comment was copied from the original comments of Fitlibrary.Specify.CollectionSetUp.SetUpList==========================================================</body></comment><class><name>NoNullaryConstructor</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>KeyValue</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MissingClassFactoryMethodForInterface</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.MissingClassFactoryMethodForInterface</class-id><body>Fixturing support for testing domain object setup of an interface implementation.  This class is missing the #concreteClassOfAbstractUserAsInterface: method that would be required to instantiate the correct implementation.</body></comment><class><name>ClassInOddPackage</name><environment>Fitlibrary.SpeciallyNamedPackage</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.SpeciallyNamedPackage.ClassInOddPackage</class-id><body>Referenced from the test page FitLibrary.SpecifiCations.CoreFitSpecifications.PackageImportsAndDefaults.DefaultPackages.</body></comment><class><name>ForcedException</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NotConcrete</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.NotConcrete</class-id><body>Fixturing support for testing domain object setup of an abstract class.Instance Variables	user	&lt;AbstractUser&gt;	The user being created and checked.</body></comment><class><name>NullInCollection</name><environment>Fitlibrary.Specify.Collection</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Collection.NullInCollection</class-id><body>A fixturing class for testing PrimitiveArrayFixture.</body></comment><class><name>ParseCounts</name><environment>Fitlibrary.Specify.ListParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ListParser.ParseCounts</class-id><body>Fixturing for testing ListParser with embedded tables.</body></comment><class><name>ParseMyFixedPointAsStringWithSuperDelegate</name><environment>Fitlibrary.Specify.ValueObject</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SimpleSetUpSut</name><environment>Fitlibrary.Specify.Suite</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count setUps owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ColumnFixtureUnderTest</name><environment>Fit.Specify</environment><super>Fit.ColumnFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b count camelFieldName calendar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.ColumnFixtureUnderTest</class-id><body>Fixture to support running ColumnFixture specs.</body></comment><class><name>RuleTableExample</name><environment>Fitlibrary.Specify.Calculate</environment><super>Fitlibrary.RuleTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.RuleTableExample</class-id><body>An example RuleTable for testing basic operation.</body></comment><class><name>ExceptionAddsCells</name><environment>Fitlibrary.Specify.Workflow</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.ExceptionAddsCells</class-id><body>Fixturing for testing FitLibraryShowException handling.</body></comment><class><name>PrimitiveArrayFixtureWithCollection</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.PrimitiveArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureWithCollection</class-id><body>A fixture for testing PrimitiveArrayFixture.</body></comment><class><name>FinderInDomainAdapter</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>AccessFields</name><environment>Fitlibrary.Specify.Set</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SelectWithTearDownFailing</name><environment>Fitlibrary.Specify.Select</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Select.SelectWithTearDownFailing</class-id><body>A fixture used for testing the 'select' special action.</body></comment><class><name>SetFixtureUnderTestGraphics</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.SetFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SetFixtureUnderTestGraphics</class-id><body>Fixture for testing the use of interpreted HTML in table cells with SetFixtures.</body></comment><class><name>MyClass</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>i </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.MyClass</class-id><body>A helper class for testing various types of Fixtures.Instance Variables	i	&lt;Integer&gt;	An example integer value.</body></comment><class><name>Comparable</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.Comparable</class-id><body>A clone of the Java Comparable interface.  Needed to test CalculateFixture with sub-objects.Subclasses must implement the following messages:	accessing		&lt;=&gt;</body></comment><class><name>MyValue2</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NullString</name><environment>Fitlibrary.Specify.EntityParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>AbstractUser</name><environment>Fitlibrary.Specify.Domain</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.AbstractUser</class-id><body>A simple abstract user class for testing domain object setup.Subclasses must implement the following messages:	accessing		dummyAbstractMethodInstance Variables	name	&lt;String&gt;	The name of the user</body></comment><class><name>NoNullaryUser</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.AbstractUser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.NoNullaryUser</class-id><body>A concrete user with "no default constructor" for testing domain object setup.</body></comment><class><name>UseConstructor</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.UseConstructor</class-id><body>Fixturing for testing value object parsing.</body></comment><class><name>NestedCalculateFixture</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>AbstractUserAsInterface</name><environment>Fitlibrary.Specify.Domain</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.AbstractUserAsInterface</class-id><body>A simple abstract user class that simulates a Java interface for testing domain object setup of an interface implementation.Subclasses must implement the following messages:	accessing		name		name:</body></comment><class><name>BadPayerFromInterface</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.AbstractUserAsInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.BadPayerFromInterface</class-id><body>A concrete implementation of a user for testing domain object setup of an interface implementation.Instance Variables	name	&lt;String&gt;	The name of the user.</body></comment><class><name>Count</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.Count</class-id><body>Fixturing to support testing ListParser with embedded tables.Instance Variables	count	&lt;AbstractProxy | MessageArchiver | Object | ProtoObject | RemoteObject&gt;	description of count</body></comment><class><name>AggregateDoFixture</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ActionFixtureUnderTest</name><environment>Fit.Specify</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.ActionFixtureUnderTest</class-id><body>Actor to support running ActionFixture specs.Instance Variables	result	&lt;Integer&gt;	A sample field for entering and reading back.</body></comment><class><name>NestedDomainAdapterToo</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>InterfaceType</name><environment>FitlibraryGeneric.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>InDomainAdapter</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>OnErrorHandler</name><environment>Fitlibrary.Specify.Global</environment><super>Fitlibrary.OnError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>EntityElement</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entitySubElement type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>PointHolder</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.PointHolder</class-id><body>Helper class for testing multiple levels of returned objects.</body></comment><class><name>AB</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MyPoint</name><environment>FitlibraryGeneric.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NullGenericCollections</name><environment>FitlibraryGeneric.Specify.Collections</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>DynamicVariablesUnderTest</name><environment>Fitlibrary.Specify.DynamicVariable</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DynamicVariable.DynamicVariablesUnderTest</class-id><body>Fixturing support for testing dynamic variable resolution.</body></comment><class><name>ForcedException</name><environment>Fitlibrary.Specify.CollectionSetUp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CollectionSetUp.ForcedException</class-id><body>An error raised when testing CollectionSetUpTraverse.</body></comment><class><name>ColumnFixtureUnderTestWithArgs</name><environment>Fit.Specify</environment><super>Fit.ColumnFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>third </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.ColumnFixtureUnderTestWithArgs</class-id><body>Fixture to support running ColumnFixture specs for tables that provide at least two arguments.Instance Variables	third	&lt;Number&gt;	Third value to add to the table arguments.</body></comment><class><name>RowFixtureUnderTest</name><environment>Fit.Specify</environment><super>Fit.RowFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.RowFixtureUnderTest</class-id><body>Fixture to support running RowFixture specs.</body></comment><class><name>Colour</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SecondSelect</name><environment>Fitlibrary.Specify.Select</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Select.SecondSelect</class-id><body>A DoFixture for testing the behavior of the 'add named' and 'select' special actions.</body></comment><class><name>DomainFixtureUnderTest</name><environment>FitlibraryGeneric.Specify</environment><super>Fitlibrary.DomainFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MyValueHolder2</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.MyValueHolder2</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.Parser.MyValueHolder==========================================================Fixturing for testing value object parsing.Instance Variables	value	&lt;MyValue&gt;	The value being held.</body></comment><class><name>ArrayFixtureUnderTestGraphics</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestGraphics</class-id><body>Fixture for testing the use of interpreted HTML in table cells with ArrayFixtures.</body></comment><class><name>DoTree</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoTree</class-id><body>Fixturing for testing tree parsing.</body></comment><class><name>Sut</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ab </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SetUpTearDownNotCalledOnSut</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setUps tearDowns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.SetUpTearDownNotCalledOnSut</class-id><body>Fixturing class for testing setUp and tearDown.Instance Variables	setUps	&lt;Integer&gt;	Number of times #setUp was sent.	tearDowns	&lt;Integer&gt;	Number of times #tearDown was sent.</body></comment><class><name>ExceptionThrownByFinder</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>PrimitiveActions</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>anInt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Department</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>InError</name><environment>Fitlibrary.Specify.MapTraverse</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ArrayFixtureUnderTestMixed</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestMixed</class-id><body>A Fixture for testing ArrayFixture with embedded Dictionaries.</body></comment><class><name>MapFixture</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.MapFixture</class-id><body>Fixturing support for testing SetFixture.</body></comment><class><name>TemporaryFixturing</name><environment>Fitlibrary.Specify.DefinedAction</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MissingClassFactoryMethod</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.MissingClassFactoryMethod</class-id><body>Fixturing support for testing domain object setup.  This class is missing the #concreteClassOfAbstractUser: method that would be required to instantiate the correct concrete subclass.</body></comment><class><name>ClearStartInActionFixture</name><environment>Fitlibrary.Specify</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ClearStartInActionFixture</class-id><body>A simple fixture that clears out the current actor in ActionFixture.</body></comment><class><name>ExceptionThrownByNestedParse</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NonGenericCollections</name><environment>FitlibraryGeneric.Specify.Collections</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aList aSet aMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>CamelCase</name><environment>Fitlibrary.Specify.Utility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext </inst-vars><class-inst-vars>runtimeContext </class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Author</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name phones address </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ConcreteClassOne</name><environment>FitlibraryGeneric.Specify</environment><super>FitlibraryGeneric.Specify.InterfaceType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SpecialsAndSequence</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.SpecialsAndSequence</class-id><body>Helper class to demonstrate the interaction between sequence-mode and special actions.</body></comment><class><name>User</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ChainedSut</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MyOtherDoTraverse</name><environment>Fitlibrary.Specify.Suite</environment><super>Fitlibrary.Traverse.Workflow.DoTraverse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Suite.MyOtherDoTraverse</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.Suite.MyOtherDoFixture==========================================================</body></comment><class><name>UseToStringForChecking</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.UseToStringForChecking</class-id><body>Fixturing for testing value object parsing.</body></comment><class><name>Parse</name><environment>Fitlibrary.Specify.ArrayParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayParser.Parse</class-id><body>Fixturing support for testing array parsing.</body></comment><class><name>RowFixtureUnderTest2</name><environment>Fit.Specify</environment><super>Fit.RowFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.RowFixtureUnderTest2</class-id><body>Fixture to support running RowFixture specs.</body></comment><class><name>ArrayFixtureUnderTest2</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTest2</class-id><body>A Fixture for testing ArrayFixture.</body></comment><class><name>Xml</name><environment>Fitlibrary.Specify.DynamicVariable</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DynamicVariable.Xml</class-id><body>Fixturing to support testing of dynamic variable resolution.</body></comment><class><name>LocalRowFixture</name><environment>Fitlibrary.Specify</environment><super>Fit.RowFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>row column rows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.LocalRowFixture</class-id><body>A simple RowFixture used for testing various aspects of how do mode works.Instance Variables	column	&lt;Integer&gt;	The index of the column to access.	row	&lt;Integer&gt;	The index of the row to access.	rows	&lt;Array&gt;	The data table.</body></comment><class><name>SucceedConstraint</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ConstraintFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SucceedConstraint</class-id><body>A Fixture for testing ConstraintFixture.</body></comment><class><name>ConstructorNotVisible</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Parse</name><environment>Fitlibrary.Specify.SetParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SetParser.Parse</class-id><body>Fixturing for testing set parsing.</body></comment><class><name>MyValueTwoClassDelegate</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExceptionInObjectFactoryMethod</name><environment>Fitlibrary.Specify.CollectionSetUp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CollectionSetUp.ExceptionInObjectFactoryMethod</class-id><body>A fixturing class for testing CollectionSetUpTraverse.</body></comment><class><name>BadPayer</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.AbstractUser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.BadPayer</class-id><body>A concrete user for testing domain object setup.</body></comment><class><name>CurrentRow</name><environment>Fitlibrary.Specify.Access</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Access.CurrentRow</class-id><body>Fixturing for testing access to the current row of the runtime context.Instance Variables	runtime	&lt;RuntimeContext&gt;	The current runtime context.</body></comment><class><name>CalculateFixtureSetUp</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CalculateFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isSetUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CalculateFixtureSetUp</class-id><body>A fixture for testing CalculateFixture.Instance Variables	isSetUp	&lt;Boolean&gt;	true if #setUp was sent; false otherwise.</body></comment><class><name>EmptyUser</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Empty</name><environment>Fitlibrary.Specify.MapTraverse</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SelectWrap</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.SelectWrap</class-id><body>An example fixture for testing the returning of selected traverses.</body></comment><class><name>PropertyAccess</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.PropertyAccess</class-id><body>Simple class for testing property access.</body></comment><class><name>Sets</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aSetOfColours </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>OnFailureWithResult</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.OnFailureWithResult</class-id><body>A fixturing class for testing that #onFailure is sent at tear-down time if any errors or failures occured.</body></comment><class><name>UseTables</name><environment>Fitlibrary.Specify.SpecialisedTables</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SpecialisedTables.UseTables</class-id><body>Fixturing for testing multiple nested tables within a cell.</body></comment><class><name>Array</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>anIntArray aColourArray a2DArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExtraGlobal</name><environment>Fitlibrary.Specify.Global</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Global.ExtraGlobal</class-id><body>An example class used to test the #addGlobal:resultsInto: special action.</body></comment><class><name>Match</name><environment>Fitlibrary.Specify.MapParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.MapParser.Match</class-id><body>Fixturing for testing map parsing.</body></comment><class><name>Primitives</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>anInt aDouble aBoolean aString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ClassWithHiddenConstructor</name><environment>Fitlibrary.Specify.InitialClass</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.InitialClass.ClassWithHiddenConstructor</class-id><body>Hidden constructors are not applicable in Smalltalk, but this class supports the related test.  Java FitLibrary handles private constructors anyway, so this works the same as in Java.</body></comment><class><name>ActionEntity</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>FixedPointInterface</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>FitLibraryFixedPoint</name><environment>Fitlibrary.Specify.Eg</environment><super>Fitlibrary.Specify.Eg.FixedPointInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SpecialActions</name><environment>Fitlibrary.Specify.SpecialAction</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SpecialAction.SpecialActions</class-id><body>Helper class for testing special actions.</body></comment><class><name>MyValueDelegate</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>RuleTableMethodsThrowExceptions</name><environment>Fitlibrary.Specify.Calculate</environment><super>Fitlibrary.RuleTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.RuleTableMethodsThrowExceptions</class-id><body>An example RuleTable for testing input, output, reset, and execute methods that raise errors.</body></comment><class><name>SelfStarter</name><environment>Fit.Specify</environment><super>Fitlibrary.Specify.SelfStartingActionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>s </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.SelfStarter</class-id><body>An example self-starting ActionFixture to support running ActionFixture specs.Instance Variables	s	&lt;String&gt;	A sample string to enter and retrieve.</body></comment><class><name>TimesCombinationSetUp</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.TimesCombinationSetUp</class-id><body>A Fixture for testing CombinationFixture.</body></comment><class><name>CalculateFixtureTearDown</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CalculateFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CalculateFixtureTearDown</class-id><body>A fixture for testing CalculateFixture.</body></comment><class><name>Colour</name><environment>Fitlibrary.Specify.MissingProperty</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>PrimitiveArrayFixtureUnderTest</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.PrimitiveArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureUnderTest</class-id><body>A fixture for testing PrimitiveArrayFixture.</body></comment><class><name>SimpleSetUp</name><environment>Fitlibrary.Specify.Suite</environment><super>Fitlibrary.Suite.SuiteFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setUpCount tearDownCount suiteSetUpCount suiteTearDownCount totalLocalSetUps totalLocalTearDowns count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>DoSeqAmbiguity</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.DoSeqAmbiguity</class-id><body>Used to specify some potentially confusing do-flow vs sequence-flow situations.</body></comment><class><name>ScientificDoublePair</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>one two </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ScientificDoublePair</class-id><body>A helper class for testing ArrayFixture.Instance Variables:	one	&lt;ScientificDouble&gt;	An example value.	two	&lt;ScientificDouble&gt;	An example value.</body></comment><class><name>AnotherActor</name><environment>Fitlibrary.Specify</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>test </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.AnotherActor</class-id><body>Another actor to support running ActionFixture specs.Instance Variables	test	&lt;Fixture&gt;	The original actor to switch back to.</body></comment><class><name>SetUpWithException</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.SetUpWithException</class-id><body>Fixturing class for testing setUp and tearDown.</body></comment><class><name>Byte</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.Byte</class-id><body>A skeleton class representing 8-bit positive integers (corresponds to the Java byte data type), but only contains enough behavior to pass a parser specification test.Instance Variables	value	&lt;SmallInteger&gt;	The byte value.</body></comment><class><name>SetFixtureUnderTest</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.SetFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SetFixtureUnderTest</class-id><body>A fixture for testing SetFixture.</body></comment><class><name>InJustSut</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>OtherFixturing</name><environment>Fitlibrary.Specify.DefinedAction</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExceptionThrownByAction</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Colour</name><environment>Fitlibrary.Specify.Eg</environment><super>Fitlibrary.Specify.Eg.Comparable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>colour </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.Colour</class-id><body>A support class for testing CalculateFixtureInstance Variables	colour	&lt;String&gt;	The string name of the colo(u)r being represented.</body></comment><class><name>Crash</name><environment>Fitlibrary.Specify.Plugin</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Plugin.Crash</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.Plugin.Dog==========================================================The following comment was copied from the original comments of Fitlibrary.Specify.Plugin.Person==========================================================</body></comment><class><name>UserWithManager</name><environment>Fitlibrary.Specify.Domain</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.UserWithManager</class-id><body>An example domain class for testing domain object setup.Instance Variables	manager	&lt;UserWithManager&gt;	The user's manager.	name	&lt;String&gt;	The user's name.</body></comment><class><name>ResetCounts</name><environment>Fitlibrary.Specify</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ResetCounts</class-id><body>Fixture that resets the test result counts for use in testing the counts.</body></comment><class><name>FailConstraint</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ConstraintFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.FailConstraint</class-id><body>A Fixture for testing ConstraintFixture.</body></comment><class><name>GraphicElement</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>i tree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.GraphicElement</class-id><body>Helper class for testing the use of interpreted HTML in table cells with ArrayFixtures and SetFixtures.Instance Variables	i	&lt;Integer&gt;	Sample integer.	tree	&lt;ListTree&gt;	Sample tree.</body></comment><class><name>PrivateUserFromInterface</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.AbstractUserAsInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.PrivateUserFromInterface</class-id><body>A concrete user for testing domain object setup of an interface implementation.  In Java, this class has a private constructor, but Smalltalk has no such concept.</body></comment><class><name>ClassWithNoNullaryConstructor</name><environment>Fitlibrary.Specify.InitialClass</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.InitialClass.ClassWithNoNullaryConstructor</class-id><body>Fixture support for technical specifications spec.  We fake a class with no no-argument constructors by sending #shouldNotImplement from #new.</body></comment><class><name>DefinedActionUnderTest</name><environment>Fitlibrary.Specify.DefinedAction</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DefinedAction.DefinedActionUnderTest</class-id><body>Fixturing support for testing defined actions and dynamic variables.</body></comment><class><name>TextPassed</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.TextPassed</class-id><body>Helper class that shows how various kinds of strings are matched in test tables.</body></comment><class><name>ResultingObjectIsSubType</name><environment>Fitlibrary.Specify.Calculate</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.ResultingObjectIsSubType</class-id><body>Fixturing support for testing CalculateFixture.</body></comment><class><name>PrivateUser</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.AbstractUser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.PrivateUser</class-id><body>A concrete user for testing domain object setup.  In Java, this class has a private constructor, but Smalltalk has no such concept.</body></comment><class><name>MissingObjectFactoryMethod</name><environment>Fitlibrary.Specify.CollectionSetUp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CollectionSetUp.MissingObjectFactoryMethod</class-id><body>A fixturing class for testing CollectionSetUpTraverse.</body></comment><class><name>Mix</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>FixedPointSuperDelegate</name><environment>Fitlibrary.Specify.ValueObject</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>DoWithTags</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoWithTags</class-id><body>Fixturing to support testing of tagged strings.</body></comment><class><name>SuperPrivateMethods</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>privatePropinSuper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.SuperPrivateMethods</class-id><body>Fixturing for testing domain object checking.Instance Variables	privatePropinSuper	&lt;Integer&gt;	An example "private" property.</body></comment><class><name>PrivatePropertyMethods</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.SuperPrivateMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars>privateProp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.PrivatePropertyMethods</class-id><body>Fixturing for testing domain object checking.Instance Variables	privateProp	&lt;Integer&gt;	An example "private" property</body></comment><class><name>FirstSelect</name><environment>Fitlibrary.Specify.Select</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Select.FirstSelect</class-id><body>A DoFixture for testing the behavior of the 'add named' and 'select' special actions.</body></comment><class><name>CalculateFixtureUnderTest3</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CalculateFixtureUnderTest3</class-id><body>A fixture for testing CalculateFixture.</body></comment><class><name>DoFixtureFlowUnderTest</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoFixtureFlowUnderTest</class-id><body>A DoFixture for testing do workflow.</body></comment><class><name>InnerCalculate2</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CalculateFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.InnerCalculate2</class-id><body>A fixture for testing CalculateFixture.  Corresponds to a nested class in the original Java.</body></comment><class><name>Address</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>address1 address2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Employee</name><environment>Fitlibrary.Specify.Domain</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name manager department </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.Employee</class-id><body>A sample domain object for testing domain object setup.Instance Variables	department	&lt;Department&gt;	The employee's department.	manager	&lt;Manager&gt;	The employee's manager.	name	&lt;String&gt;	The employee's name.</body></comment><class><name>ClassWithParseMethod2</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.ClassWithParseMethod2</class-id><body>Fixturing for testing value object parsing.</body></comment><class><name>LocalCalculateFixture</name><environment>Fitlibrary.Specify.Calculate</environment><super>Fitlibrary.CalculateFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.LocalCalculateFixture</class-id><body>A fixture for testing CalculateFixture.  Corresponds to a nested class in the original Java.</body></comment><class><name>MyPoint2</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Publisher</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>EntityInNestedArray</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>first second </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SimpleDateFormat</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>format </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SimpleDateFormat</class-id><body>Simplified implmentation of Java's SimpleDateFormat.  Contains just enough behavior to pass the tests it needs to pass.Instance Variables	format	&lt;String&gt;	The format specification for dates.</body></comment><class><name>UnparsedPoint</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>InDomainAdapter</name><environment>Fitlibrary.Specify.MissingProperty</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>AccessPrivateFields</name><environment>Fitlibrary.Specify.Set</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Set.AccessPrivateFields</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.Set.AccessFields==========================================================</body></comment><class><name>Rectangle</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y width height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.Rectangle</class-id><body>Replacement for the Java Rectangle class that is language-independent.  Used in specification tests.Instance Variables	height	&lt;Integer&gt;	The height of the rectangle.	width	&lt;Integer&gt;	The width of the rectangle.	x	&lt;Integer&gt;	The x coordinate of the top-left corner.	y	&lt;Integer&gt;	The y coordinate of the top-left corner.</body></comment><class><name>BadConstructorsInNestedObjects</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>employee </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.BadConstructorsInNestedObjects</class-id><body>Fixturing support for testing domain object setup where the nested classes have bad constructors.Instance Variables	employee	&lt;Employee&gt;	An example domain object.</body></comment><class><name>Calendar</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExceptionThrownByParse</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NoNullaryUserFromInterface</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.AbstractUserAsInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.NoNullaryUserFromInterface</class-id><body>A concrete user with "no default constructor" for testing domain object setup of an interface implementation.</body></comment><class><name>DomainAdapterUnderTest</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sut </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Parse</name><environment>Fitlibrary.Specify.MapParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.MapParser.Parse</class-id><body>Fixturing for testing map parsing.</body></comment><class><name>Some</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Some</class-id><body>A helper class for testing ArrayFixture.</body></comment><class><name>HasNewInstancePlugin</name><environment>Fitlibrary.Specify.Plugin</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person persons personList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NestedFinderInDomainAdapter</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Maps</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aStringMap aColourMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ClassWithNoTypeAdapter</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.ClassWithNoTypeAdapter</class-id><body>Fixturing for testing value object parsing.</body></comment><class><name>SetUpList</name><environment>Fitlibrary.Specify.CollectionSetUp</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iOUs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Project2</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Exception.Project2</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.Exception.Project==========================================================</body></comment><class><name>AmbiguousActionMethod</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>PrePopulated</name><environment>FitlibraryGeneric.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aSetOfAttribute aListOfAttribute colour </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Calendar</name><environment>Fit.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>DoCalculateFixtureSetUp</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoCalculateFixtureSetUp</class-id><body>A fixture for testing CalculateFixture.</body></comment><class><name>ParserUnderTest</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.ParserUnderTest</class-id><body>Fixture for testing parsing of primitive types and their corresponding classes.</body></comment><class><name>VariantOnSimple</name><environment>Fitlibrary.Specify.Suite</environment><super>Fitlibrary.Suite.SuiteFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SetUpTearDownOfOther</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.SetUpTearDownOfOther</class-id><body>Fixturing class for testing setUp and tearDown.</body></comment><class><name>ExceptionThrownByNestedToString</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ClassDelegate</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Combine</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CombinationFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isSetUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Combine</class-id><body>A Fixture for testing CombinationFixture.</body></comment><class><name>RuleTableMethodsThrowExceptionsSut</name><environment>Fitlibrary.Specify.Calculate</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inThrowsException outThrowsException in resetThrowsException executeThrowsException </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.RuleTableMethodsThrowExceptionsSut</class-id><body>Fixturing support for testing RuleTable behavior.Instance Variables	executeThrowsException	&lt;Boolean&gt;	True if #execute should raise an error; false otherwise.	in	&lt;Integer&gt;	An example input.	inThrowsException	&lt;Boolean&gt;	True if #in should raise an error; false otherwise.	outThrowsException	&lt;Boolean&gt;	True if #getOut should raise an error; false otherwise.	resetThrowsException	&lt;Boolean&gt;	True if #reset should raise an error; false otherwise.</body></comment><class><name>SubsetFixtureUnderTest</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.SubsetFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SubsetFixtureUnderTest</class-id><body>A Fixture for testing SubsetFixture.</body></comment><class><name>AlienEvaluator</name><environment>Fit.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.AlienEvaluator</class-id><body>Fixturing for alien evaluator specs.</body></comment><class><name>TearDown</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.TearDown</class-id><body>Fixturing class for testing setUp and tearDown.</body></comment><class><name>EntitySubElement</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionEntities </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Person</name><environment>Fitlibrary.Specify.EntityParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Manager</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.Specify.Domain.Employee</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.Manager</class-id><body>A sample domain object for testing domain object setup.  This class "has no default constructor".</body></comment><class><name>GridFixtureUnderTest</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.GridFixtureUnderTest</class-id><body>Fixturing to support testing GridFixture (and ImageFixture).</body></comment><class><name>Value4</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Exception.Value4</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.Exception.Value3==========================================================</body></comment><class><name>ArrayFixtureUnderTestWithScientificDouble</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestWithScientificDouble</class-id><body>A Fixture for testing ArrayFixture.</body></comment><class><name>ErrorMap</name><environment>Fitlibrary.Specify.MapTraverse</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExceptionThrownByNestedShow</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>RuleTableWithResetAndExecuteSut</name><environment>Fitlibrary.Specify.Calculate</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>executes resets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.RuleTableWithResetAndExecuteSut</class-id><body>Fixturing support for testing RuleTable behavior.Instance Variables	executes	&lt;Integer&gt;	The number of times #execute has been sent.	resets	&lt;Integer&gt;	The number of times #execute has been sent.</body></comment><class><name>MockClass</name><environment>Fit.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a s </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.MockClass</class-id><body>Simple class used for testing RowFixtures.Instance Variables	a	&lt;Integer&gt;	Matches the 'a' column in the spec tables.	s	&lt;String&gt; Matches the 's' column in the spec tables.</body></comment><class><name>MockCollection</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>plus ampersand </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.MockCollection</class-id><body>Helper class for testing ArrayFixture.Instance Variables	ampersand	&lt;String&gt;	An example string value.	plus	&lt;Integer&gt;	An example integer value.</body></comment><class><name>Match</name><environment>Fitlibrary.Specify.ListParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ListParser.Match</class-id><body>Fixturing for testing list parsing.</body></comment><class><name>GenericMaps</name><environment>FitlibraryGeneric.Specify.Collections</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aMap aMapOfMaps </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MissingFinderMethod</name><environment>Fitlibrary.Specify.EntityParser</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SimpleSut</name><environment>Fitlibrary.Specify.Suite</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Fields</name><environment>Fitlibrary.Specify.Set</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field1 field2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExceptionThrownByNestedFinder</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ExceptionThrownByEquals</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>DoTable</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoTable</class-id><body>Fixturing for testing nested tables.</body></comment><class><name>WithinFlow</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.WithinFlow</class-id><body>Fixturing class for testing setUp and tearDown.</body></comment><class><name>CalculateFixtureUnderTest2</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CalculateFixtureUnderTest2</class-id><body>A fixture for testing CalculateFixture.</body></comment><class><name>ArrayFixtureUnderTest3</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTest3</class-id><body>A Fixture for testing ArrayFixture.</body></comment><class><name>InnerDate</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dateString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.InnerDate</class-id><body>A customized Date class for specifying parser delegate methods.Instance Variables	dateString	&lt;String&gt;	The string representation of the date.</body></comment><class><name>DoFixtureTearDown</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoFixtureTearDown</class-id><body>Fixturing class for testing setUp and tearDown.</body></comment><class><name>Simple</name><environment>Fitlibrary.Specify.Suite</environment><super>Fitlibrary.Suite.SuiteFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NestedFinderInJustSut</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Colour</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>AutoWrap</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.AutoWrap</class-id><body>A test class for testing the auto-wrapping of objects with Traverses.</body></comment><class><name>StringMap</name><environment>Fitlibrary.Specify.MapTraverse</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>NoParsePoint</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>CheckDynamicVariable</name><environment>Fitlibrary.Specify.DynamicVariable</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>BadClassFromClassFactoryMethodForInterface</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.BadClassFromClassFactoryMethodForInterface</class-id><body>Fixturing for testing domain object setup of an interface implementation.</body></comment><class><name>CalculateFixtureSetUpWithException</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CalculateFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CalculateFixtureSetUpWithException</class-id><body>A fixture for testing CalculateFixture.</body></comment><class><name>InJustSut</name><environment>Fitlibrary.Specify.MissingProperty</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>colour </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SystemUnderTest</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sum concat </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SystemUnderTest</class-id><body>An example system under test for testing DoFixtures.Instance Variables	concat	&lt;String&gt;	 A string that gets concatenated up during tests.	sum	&lt;SmallInteger&gt;	A number that is accumulated during tests.</body></comment><class><name>Lists</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aColourList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MyClassPair</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>one two </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.MyClassPair</class-id><body>A helper class for testing ArrayFixture.Instance Variables	one	&lt;MyClass&gt;	An example value.	two	&lt;MyClass&gt;	An example value.</body></comment><class><name>Colour2</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>MyValue</name><environment>Fitlibrary.Specify.Parser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.MyValue</class-id><body>Fixturing for testing value object parsing.Instance Variables	value	&lt;Integer&gt;	The contained value.</body></comment><class><name>ClearActionFixture</name><environment>Fit.Specify</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary-SpecFixtures</category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fit.Specify.ClearActionFixture</class-id><body>A simple fixture that clears out the current actor in ActionFixture.</body></comment><class><name>Value3</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Parse</name><environment>Fitlibrary.Specify.ListParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ListParser.Parse</class-id><body>Fixturing for testing list parsing.</body></comment><class><name>Department</name><environment>Fitlibrary.Specify.Domain</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>city </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Domain.Department</class-id><body>A simple domain class for testing domain object setup.Instance Variables	city	&lt;String&gt;	The city that the department is in.</body></comment><class><name>DoubleUse</name><environment>Fitlibrary.Specify.Calculate</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>calc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Calculate.DoubleUse</class-id><body>Support class for testing CalculateFixture.Instance Variables	calc	&lt;LocalCalculateFixture&gt;	The fixture to be returned multiple times.</body></comment><class><name>MyPoint2Editor</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.PropertyEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>VariantOnSimpleSut</name><environment>Fitlibrary.Specify.Suite</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>AmbiguousSpecial</name><environment>Fitlibrary.Specify.SpecialAction</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SpecialAction.AmbiguousSpecial</class-id><body>A helper class used for specifying ambiguous action responses.</body></comment><class><name>DoFixtureWithExceptionInConstructor</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoFixtureWithExceptionInConstructor</class-id><body>A test DoFixture that raises an error in its constructor (#new method).</body></comment><class><name>ClassWithParseMethod</name><environment>Fitlibrary.Specify.Parser</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Parser.ClassWithParseMethod</class-id><body>Fixturing for testing value object parsing.</body></comment><class><name>MixedCombination</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CombinationFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.MixedCombination</class-id><body>A Fixture for testing CombinationFixture.</body></comment><class><name>Ab</name><environment>Fitlibrary.Specify.DefinedAction</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DefinedAction.Ab</class-id><body>Helper class for testing dynamic variable resolution.Instance Variables	a	&lt;SmallInteger&gt;	An example Integer.	b	&lt;SmallInteger&gt;	An example Integer.</body></comment><class><name>DoFixtureSetUpWithException</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DoFixtureSetUpWithException</class-id><body>Fixturing class for testing setUp and tearDown.</body></comment><class><name>DirectCombination</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CombinationFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.DirectCombination</class-id><body>A Fixture for testing CombinationFixture.</body></comment><class><name>Project</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>A</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.A</class-id><body>A simple class used to interpret a table when testing DoFixtures.</body></comment><class><name>ArrayFixtureUnderTest</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.ArrayFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.ArrayFixtureUnderTest</class-id><body>A Fixture for testing ArrayFixture.</body></comment><class><name>ExceptionThrownByGetterInCollection</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>ConcretePerson</name><environment>Fitlibrary.Specify.Plugin</environment><super>Fitlibrary.Specify.Plugin.Person</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>PojoGivesErrorsAndFails</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>SetUp</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.SetUp</class-id><body>Fixturing class for testing setUp and tearDown.Instance Variables	setUp	&lt;Boolean&gt;	True if #setUp was sent; false otherwise.</body></comment><class><name>TimesCombination</name><environment>Fitlibrary.Specify</environment><super>Fitlibrary.CombinationFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.TimesCombination</class-id><body>A Fixture for testing CombinationFixture.</body></comment><class><name>MixedMap</name><environment>Fitlibrary.Specify.MapTraverse</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>User</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name owe phones account </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.User</class-id><body>A simple user class for testing domain objects.Instance Variables	account	&lt;Account&gt;	The user's account.	name	&lt;String&gt;	The name of the user.	owe	&lt;Number&gt;	The amount that the user owes us.	phones	&lt;Collection&gt;	The user's phone numbers.</body></comment><class><name>ExceptionThrownBySetter</name><environment>Fitlibrary.Specify.Exception</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>GenericCollections</name><environment>FitlibraryGeneric.Specify.Collections</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aList aListOfLists aListOfString aSet aSetOfSets aListOfSets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>FinderInJustSut</name><environment>Fitlibrary.Specify.MissingMethod</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Match</name><environment>Fitlibrary.Specify.SetParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.SetParser.Match</class-id><body>Fixturing for testing set parsing.</body></comment><class><name>OnFailureWithException</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.OnFailureWithException</class-id><body>A fixturing class for testing that #onFailure is sent at tear-down time if any errors or failures occured.</body></comment><class><name>SetUpSet</name><environment>Fitlibrary.Specify.CollectionSetUp</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iOUSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpSet</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.CollectionSetUp.SetUpList==========================================================</body></comment><class><name>Local</name><environment>Fitlibrary.Specify</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>s </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Local</class-id><body>Simple helper class used by LocalRowFixture for testing FitLibrary features.Instance Variables	s	&lt;String&gt;	A string set and returned by the tests.</body></comment><class><name>Dog</name><environment>Fitlibrary.Specify.Plugin</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Plugin.Dog</class-id><body>The following comment was copied from the original comments of Fitlibrary.Specify.Plugin.Person==========================================================</body></comment><class><name>Objects</name><environment>Fitlibrary.Specify.Domain</environment><super>Fitlibrary.DomainFixtured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><class><name>Sum</name><environment>Fitlibrary.Specify.Workflow</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sum </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Workflow.Sum</class-id><body>Simple class for accumulating numbers.  Used for testing "do" workflow.Instance Variables	sum	&lt;ArithmeticValue&gt;	The accumulated value.</body></comment><class><name>MyPoint</name><environment>Fitlibrary.Specify.Eg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-SpecFixtures</package></attributes></class><comment><class-id>Fitlibrary.Specify.Eg.MyPoint</class-id><body>A custom point class for testing auto-wrapping of collections.Instance Variables	x	&lt;Integer&gt;	The x-coordinate.	y	&lt;Integer&gt;	The y-coordinate.</body></comment><methods><class-id>Fitlibrary.Specify.Exception.Value class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.SelfStartingActionFixture</class-id> <category>enumerating</category><body package="FitLibrary-SpecFixtures">doTable: aParse	self class actor: self.	super doTable: aParse</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureUnderTest</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	count := 1</body></methods><methods><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureUnderTestMixed class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: #(1 2.0 'three') componentType: Object</body></methods><methods><class-id>Fitlibrary.Specify.CamelRowFixtureUnderTest</class-id> <category>abstracts</category><body package="FitLibrary-SpecFixtures">query	^Array		with: (MockCollection plus: 1 ampersand: 'one')		with: (MockCollection plus: 1 ampersand: 'two')		with: (MockCollection plus: 2 ampersand: 'two')</body></methods><methods><class-id>Fitlibrary.Specify.CamelRowFixtureUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">targetClass	^MockCollection</body></methods><methods><class-id>Fitlibrary.Specify.SetFixtureUnderTest2 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: (Array				with: (MockCollection plus: 1 ampersand: 'one')				with: (MockCollection plus: 1 ampersand: 'two')				with: (MockCollection plus: 1 ampersand: 'two')				with: Some new)</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestWithMap</class-id> <category>private</category><body package="FitLibrary-SpecFixtures">makeMapPlus: anInteger ampersand: aString	^(Dictionary new)		at: 'plus' put: anInteger;		at: 'ampersand' put: aString;		yourself</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ObjectDelegateForDate</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self registerParseDelegateObject: self class dateFormat forClass: Timestamp</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ObjectDelegateForDate class</class-id> <category>constants</category><body package="FitLibrary-SpecFixtures">dateFormat	^SimpleDateFormat format: 'yyyy/mm/dd hh:mm'</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPointStringConstructor</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aPoint	^aPoint x = x and: [aPoint y = y]</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPointStringConstructor</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'(&lt;1p&gt;,&lt;2p&gt;)' expandMacrosWith: x with: y</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPointStringConstructor</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setX: xInteger y: yInteger	x := xInteger.	y := yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPointStringConstructor class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	^self new setX: xInteger y: yInteger</body></methods><methods><class-id>Fitlibrary.Specify.SimplePhone</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setPhone: aString	phone := aString</body></methods><methods><class-id>Fitlibrary.Specify.SimplePhone class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">phone: aString	^self new setPhone: aString</body></methods><methods><class-id>Fitlibrary.Specify.Domain.PropertyOfInterfaceType</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.FixedPointDelegate class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	| comma |	((aString beginsWith: '(') and: [aString endsWith: ')'])		ifFalse: [^self error: 'Badly formatted point'].	comma := aString indexOf: $,.	comma isZero ifTrue: [^self error: 'Badly formatted point'].	^FitLibraryFixedPoint		x: (Integer fitParse: (aString copyFrom: 2 to: comma - 1))		y: (Integer fitParse: (aString copyFrom: comma + 1 to: aString size - 1))</body></methods><methods><class-id>Fitlibrary.Specify.SetFixtureUnderTest3 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: OrderedCollection new</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByShow</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.ParseMyFixedPointAsStringWithDelegate</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	ParseDelegation registerParseDelegateClass: FixedPointDelegate		forClass: FitLibraryFixedPoint</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.ParseMyFixedPointAsStringWithDelegate class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.UserAdapter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.UserAdapter</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	users := Dictionary new</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.UserAdapter class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.C</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^s</body></methods><methods><class-id>Fitlibrary.Specify.C</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setString: aString	s := aString</body></methods><methods><class-id>Fitlibrary.Specify.C class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">string: aString	^self new setString: aString</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Account</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setId: anInteger paymentHistory: aString	self id: anInteger.	self paymentHistory: aString</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Account class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">id: anInteger paymentHistory: aString	^self new setId: anInteger paymentHistory: aString</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedEquals</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Constraint.SetUpAndTearDownCalled</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	isSetUp := false</body><body package="FitLibrary-SpecFixtures">setUp	isSetUp := true</body><body package="FitLibrary-SpecFixtures">tearDown	^self error: 'tear down'</body></methods><methods><class-id>Fitlibrary.Specify.Constraint.SetUpAndTearDownCalled</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Constraint.SetUpAndTearDownCalled class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Phone</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setCountry: countryInteger region: regionInteger number: numberInteger	country := countryInteger.	region := regionInteger.	number := numberInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Phone class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">country: countryInteger region: regionInteger number: numberInteger	^self new		setCountry: countryInteger		region: regionInteger		number: numberInteger</body></methods><methods><class-id>Fitlibrary.Specify.Entity</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">string	^string</body></methods><methods><class-id>Fitlibrary.Specify.Entity</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^string</body></methods><methods><class-id>Fitlibrary.Specify.Entity</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= anEntity	^string = anEntity string</body></methods><methods><class-id>Fitlibrary.Specify.Entity</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setString: aString	string := aString</body></methods><methods><class-id>Fitlibrary.Specify.Entity class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">string: aString	^self new setString: aString</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.ParserDelegateMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableWithResetAndExecute</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self systemUnderTest: RuleTableWithResetAndExecuteSut new</body></methods><methods><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureUnderTestEmpty class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: #() componentType: Integer</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ObjectDelegate</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self registerParseDelegateObject: MyValueDelegate new forClass: MyValue2</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestWithValueObjects class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: (Array				with: (MyClassPair i: 1 j: 2)				with: (MyClassPair i: 3 j: 4)				with: (MyClassPair i: 5 j: 6))</body></methods><methods><class-id>Fitlibrary.Specify.AggregateDomainObject</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	book := Book new</body></methods><methods><class-id>Fitlibrary.Specify.AggregateDomainObject class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Select.SelectWithSetUpFailing</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">setUp	self error: 'failure in setUp'</body></methods><methods><class-id>Fitlibrary.Specify.TeeTree</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">rawText	^tree rawText</body><body package="FitLibrary-SpecFixtures">text	^tree text</body></methods><methods><class-id>Fitlibrary.Specify.TeeTree</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^tree fitToString</body></methods><methods><class-id>Fitlibrary.Specify.TeeTree</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setTree: aTree	tree := ListTree title: 'B' children: aTree children</body></methods><methods><class-id>Fitlibrary.Specify.TeeTree class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">onTree: aTree	^self new setTree: aTree</body><body package="FitLibrary-SpecFixtures">parseTree: aTree	^self onTree: aTree</body></methods><methods><class-id>Fitlibrary.Specify.Plugin.Person</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.InnerCalculate3</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self repeatString: String new</body></methods><methods><class-id>FitlibraryGeneric.Specify.Colour class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">named: aString	^self new setColour: aString</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueHolder</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setValue: aMyValue	value := aMyValue</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueHolder class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">value: aMyValue	^self new setValue: aMyValue</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Keywords</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	sum := 0.0</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Keywords class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Value2</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Value2 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^self new</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpMap</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	iOUMap := Dictionary new</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpMap class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Exception.NoNullaryConstructor class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^ShouldNotImplement raise</body></methods><methods><class-id>Fitlibrary.Specify.KeyValue</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setName: nameString value: valueString	name := nameString.	value := valueString</body></methods><methods><class-id>Fitlibrary.Specify.KeyValue class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">name: nameString value: valueString	^self new setName: nameString value: valueString</body></methods><methods><class-id>Fitlibrary.Specify.Domain.NotConcrete</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.ParseMyFixedPointAsStringWithSuperDelegate</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	ParseDelegation registerSuperParseDelegate: FixedPointSuperDelegate new		forClass: FixedPointInterface</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.ParseMyFixedPointAsStringWithSuperDelegate class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSetUpSut</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setCount: anInteger owner: aSimpleSetUp	count := anInteger.	owner := aSimpleSetUp.	setUps := 0</body><body package="FitLibrary-SpecFixtures">setUp	setUps := setUps + 1.	owner incrementLocalSetUps</body><body package="FitLibrary-SpecFixtures">tearDown	owner incrementLocalTearDowns</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSetUpSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSetUpSut class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">count: anInteger owner: aSimpleSetUp	^self new setCount: anInteger owner: aSimpleSetUp</body></methods><methods><class-id>Fit.Specify.ColumnFixtureUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a	^a</body><body package="FitLibrary-SpecFixtures">b	^b</body></methods><methods><class-id>Fit.Specify.ColumnFixtureUnderTest</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	a := 0.	b := 0.	count := 1.	camelFieldName := String new.	calendar := Timestamp new</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableExample</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self systemUnderTest: RuleTableExampleSut new</body></methods><methods><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureWithCollection class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: (Array				with: (C string: 'one')				with: (C string: 'two')				with: (C string: 'three'))		componentType: C</body></methods><methods><class-id>Fitlibrary.Specify.MissingMethod.FinderInDomainAdapter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^FinderInJustSut new</body></methods><methods><class-id>Fitlibrary.Specify.Select.SelectWithTearDownFailing</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">tearDown	self error: 'Failed in tearDown'</body></methods><methods><class-id>Fitlibrary.Specify.SetFixtureUnderTestGraphics class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: (Array				with: (GraphicElement i: 1 tree: 'a')				with: (GraphicElement i: 1 tree: '&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;')				with: (GraphicElement i: 2 tree: '&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;BB&lt;/li&gt;&lt;/ul&gt;'))</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyClass</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= anObject	^self class == anObject class and: [i = anObject i]</body><body package="FitLibrary-SpecFixtures">hash	^i hash</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyClass</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">i	^i</body><body package="FitLibrary-SpecFixtures">plus: aMyClass	^self class i: i + aMyClass i</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyClass</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'i ' , i printString</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyClass</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setI: anInteger	i := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyClass class</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitParse: aString	(aString beginsWith: 'i ')		ifFalse: [self error: 'Invalid value: must start with ''i '''].	^self i: (Number fitParse: (aString copyFrom: 3 to: aString size))</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyClass class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">i: anInteger	^self new setI: anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Comparable</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">&lt;=&gt; anObject	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue2</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^value printString</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue2</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setValue: aValue2	value := aValue2</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	^value</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue2</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aMyValue2	(aMyValue2 isKindOf: self class) ifFalse: [^false].	^value = aMyValue2 value</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue2 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">value: anInteger	^self new setValue: anInteger</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.NullString</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Domain.AbstractUser</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">dummyAbstractMethod	"This is only here to make this class look abstract"	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.Domain.NoNullaryUser</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">dummyAbstractMethod	" *** This method was defined by Fitlibrary.Specify.Domain.AbstractUser as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Fitlibrary.Specify.Domain.NoNullaryUser class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^Fit.Exceptions.ShouldNotImplement raise</body></methods><methods><class-id>Fitlibrary.Specify.Domain.AbstractUserAsInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	^self subclassResponsibility</body><body package="FitLibrary-SpecFixtures">name: aString	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Count</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'Count[' , count printString , ']'</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Count</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setCount: anInteger	count := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Count</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aCount	(aCount isKindOf: self class) ifFalse: [^false].	^count = aCount count</body><body package="FitLibrary-SpecFixtures">hash	^count hash</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Count class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">count: anInteger	^self new setCount: anInteger</body></methods><methods><class-id>Fit.Specify.ActionFixtureUnderTest</class-id> <category>operations</category><body package="FitLibrary-SpecFixtures">enterMethodWithNoArgs</body><body package="FitLibrary-SpecFixtures">enterMethodWithTwoArgs: aString and: anotherString</body><body package="FitLibrary-SpecFixtures">pressThrows	Error raise</body></methods><methods><class-id>Fit.Specify.ActionFixtureUnderTest</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	result := 0</body></methods><methods><class-id>Fitlibrary.Specify.MissingMethod.NestedDomainAdapterToo</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^NestedFinderInJustSut new</body></methods><methods><class-id>FitlibraryGeneric.Specify.InterfaceType</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count	^self subclassResponsibility</body><body package="FitLibrary-SpecFixtures">count: anInteger	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.MissingMethod.InDomainAdapter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^InJustSut new</body></methods><methods><class-id>Fitlibrary.Specify.Global.OnErrorHandler</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">stopOnFailures: failureCount errors: errorCount	runtimeContext currentRow		addShow: ('stopOnError with &lt;1p&gt; fails and &lt;2p&gt; errors'				expandMacrosWith: failureCount				with: errorCount).	errorCount &gt;= 2		ifTrue: 			[runtimeContext currentRow addShow: 'Stopping'.			^true].	^false</body></methods><methods><class-id>Fitlibrary.Specify.EntityElement</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setType: anEntity	type := anEntity.	entitySubElement := EntitySubElement type: type</body></methods><methods><class-id>Fitlibrary.Specify.EntityElement class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">type: anEntity	^self new setType: anEntity</body></methods><methods><class-id>Fitlibrary.Specify.AB</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setA: aInteger b: bInteger	a := aInteger.	b := bInteger</body></methods><methods><class-id>Fitlibrary.Specify.AB class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">a: aInteger b: bInteger	^self new setA: aInteger b: bInteger</body></methods><methods><class-id>FitlibraryGeneric.Specify.MyPoint</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setX: xInteger y: yInteger	x := xInteger.	y := yInteger</body></methods><methods><class-id>FitlibraryGeneric.Specify.MyPoint class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	^self new setX: xInteger y: yInteger</body></methods><methods><class-id>Fit.Specify.ColumnFixtureUnderTestWithArgs</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	third := 0</body></methods><methods><class-id>Fit.Specify.RowFixtureUnderTest</class-id> <category>abstracts</category><body package="FitLibrary-SpecFixtures">query	^Array		with: (MockClass number: 1 string: 'one')		with: (MockClass number: 1 string: 'two')		with: (MockClass number: 2 string: 'two')</body></methods><methods><class-id>Fit.Specify.RowFixtureUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">targetClass	^MockClass</body></methods><methods><class-id>FitlibraryGeneric.Specify.DomainFixtureUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self systemUnderTest: PrePopulated new</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueHolder2</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setValue: aMyValue2	value := aMyValue2</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueHolder2 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">value: aMyValue2	^self new setValue: aMyValue2</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestGraphics class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: (Array				with: (GraphicElement i: 1 tree: 'a')				with: (GraphicElement i: 1 tree: '&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;')				with: (GraphicElement i: 2 tree: '&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;BB&lt;/li&gt;&lt;/ul&gt;'))</body></methods><methods><class-id>Fitlibrary.Specify.Sut</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	ab := OrderedCollection new</body></methods><methods><class-id>Fitlibrary.Specify.Sut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^ChainedSut new</body></methods><methods><class-id>Fitlibrary.Specify.Sut class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUpTearDownNotCalledOnSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">setUp	setUps := setUps + 1</body><body package="FitLibrary-SpecFixtures">tearDown	tearDowns := tearDowns + 1</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUpTearDownNotCalledOnSut</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	setUps := 0.	tearDowns := 0</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUpTearDownNotCalledOnSut class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByFinder</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.MapTraverse.InError</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'InError[]'</body></methods><methods><class-id>Fitlibrary.Specify.MapTraverse.InError class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^self error: aString</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestMixed</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self actuals: self query</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestMixed</class-id> <category>private</category><body package="FitLibrary-SpecFixtures">makeMapPlus: anInteger ampersand: aString	^(Dictionary new)		at: 'plus' put: anInteger;		at: 'ampersand' put: aString;		yourself</body><body package="FitLibrary-SpecFixtures">query	^OrderedCollection		with: (self makeMapPlus: 1 ampersand: 'one')		with: (MockCollection plus: 1 ampersand: 'two')		with: (self makeMapPlus: 2 ampersand: 'two')</body></methods><methods><class-id>Fitlibrary.Specify.MapFixture</class-id> <category>private</category><body package="FitLibrary-SpecFixtures">makeMapPlus: anInteger ampersand: aString	^(Dictionary new)		at: 'plus' put: anInteger;		at: 'ampersand' put: aString;		yourself</body></methods><methods><class-id>Fitlibrary.Specify.ClearStartInActionFixture</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	ActionFixture actor: nil</body></methods><methods><class-id>Fitlibrary.Specify.Utility.CamelCase</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext</body><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Author</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setName: aString phones: aSet address: anAddress	name := aString.	phones := aSet.	address := anAddress</body></methods><methods><class-id>Fitlibrary.Specify.Author class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">name: aString phones: aSet address: anAddress	^self new setName: aString phones: aSet address: anAddress</body></methods><methods><class-id>Fitlibrary.Specify.Exception.User</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'A user'</body></methods><methods><class-id>Fitlibrary.Specify.Exception.User</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= anObject	ForcedException raise</body></methods><methods><class-id>Fit.Specify.RowFixtureUnderTest2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">targetClass	^MockClass</body></methods><methods><class-id>Fit.Specify.RowFixtureUnderTest2</class-id> <category>abstracts</category><body package="FitLibrary-SpecFixtures">query	^Array new</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTest2 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: (Array				with: (MockCollection plus: 1 ampersand: 'one')				with: (MockCollection plus: 1 ampersand: 'two')				with: (MockCollection plus: 2 ampersand: 'two')				with: Some new)</body></methods><methods><class-id>Fitlibrary.Specify.LocalRowFixture</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initializeRows	rows := #('A' 'B') collect: 					[:each1 |					(0 to: 3) collect: 							[:each2 |							#('a' 'b')								collect: [:each3 | Local string: each1 , each2 printString , each3]]]</body><body package="FitLibrary-SpecFixtures">setRow: aRowInteger column: aColumnInteger	self initializeRows.	row := aRowInteger.	column := aColumnInteger</body></methods><methods><class-id>Fitlibrary.Specify.LocalRowFixture</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">query	^(rows at: row) at: column</body><body package="FitLibrary-SpecFixtures">targetClass	^Local</body></methods><methods><class-id>Fitlibrary.Specify.LocalRowFixture class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">row: row column: column	^self new setRow: row column: column</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ConstructorNotVisible class</class-id> <category>private</category><body package="FitLibrary-SpecFixtures">new	^self basicNew</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueTwoClassDelegate class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^MyValue2 value: (Integer fitParse: aString)</body></methods><methods><class-id>Fitlibrary.Specify.Access.CurrentRow</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">runtimeContext: aRuntimeContext	runtime := aRuntimeContext</body><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureSetUp</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	isSetUp := false</body><body package="FitLibrary-SpecFixtures">setUp	isSetUp := true</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Sets</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	aSetOfColours := Set with: Colour red with: Colour green</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Sets class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.OnFailureWithResult</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">onFailure	^'onFailure() called'</body><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Array</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	anIntArray := #(1 2 4).	aColourArray := Core.Array with: Colour red with: Colour green.	a2DArray := Core.Array with: anIntArray with: anIntArray</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Array class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Primitives</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	anInt := 3.	aDouble := 3.14159d.	aBoolean := true.	aString := 'my value'</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Primitives class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.ActionEntity</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setType: anEntity	type := anEntity</body></methods><methods><class-id>Fitlibrary.Specify.ActionEntity class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">type: anEntity	^self new setType: anEntity</body></methods><methods><class-id>Fitlibrary.Specify.Eg.FixedPointInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.Eg.FitLibraryFixedPoint</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setX: xInteger y: yInteger	x := xInteger.	y := yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.FitLibraryFixedPoint</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'(&lt;1p&gt;,&lt;2p&gt;)' expandMacrosWith: x with: y</body></methods><methods><class-id>Fitlibrary.Specify.Eg.FitLibraryFixedPoint</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aFitLibraryFixedPoint	(aFitLibraryFixedPoint isKindOf: self class) ifFalse: [^false].	^x = aFitLibraryFixedPoint x and: [y = aFitLibraryFixedPoint y]</body></methods><methods><class-id>Fitlibrary.Specify.Eg.FitLibraryFixedPoint class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	^self new setX: xInteger y: yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueDelegate</class-id> <category>parsing</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^MyValue2 value: (Integer fitParse: aString)</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableMethodsThrowExceptions</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self systemUnderTest: RuleTableMethodsThrowExceptionsSut new</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureTearDown</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">tearDown	self error: 'TearDown Worked.'</body></methods><methods><class-id>Fitlibrary.Specify.PrimitiveArrayFixtureUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: #(1 2 3) componentType: Integer</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSetUp</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">incrementLocalSetUps	totalLocalSetUps := totalLocalSetUps + 1</body><body package="FitLibrary-SpecFixtures">incrementLocalTearDowns	totalLocalTearDowns := totalLocalTearDowns + 1</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSetUp</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	count := 0.	setUpCount := 0.	tearDownCount := 0.	suiteSetUpCount := 0.	suiteTearDownCount := 0.	totalLocalSetUps := 0.	totalLocalTearDowns := 0</body><body package="FitLibrary-SpecFixtures">setUp	setUpCount := setUpCount + 1</body><body package="FitLibrary-SpecFixtures">suiteSetUp	suiteSetUpCount := suiteSetUpCount + 1</body><body package="FitLibrary-SpecFixtures">suiteTearDown	suiteTearDownCount := suiteTearDownCount + 1</body><body package="FitLibrary-SpecFixtures">tearDown	tearDownCount := tearDownCount + 1</body></methods><methods><class-id>Fitlibrary.Specify.ScientificDoublePair</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setOne: aScientificDouble two: bScientificDouble	one := aScientificDouble.	two := bScientificDouble</body></methods><methods><class-id>Fitlibrary.Specify.ScientificDoublePair class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">i: aDouble j: bDouble	^self new setOne: (ScientificDouble value: aDouble)		two: (ScientificDouble value: bDouble)</body></methods><methods><class-id>Fitlibrary.Specify.AnotherActor</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">test: anActionFixtureUnderTest	test := anActionFixtureUnderTest</body></methods><methods><class-id>Fitlibrary.Specify.AnotherActor</class-id> <category>operations</category><body package="FitLibrary-SpecFixtures">start</body></methods><methods><class-id>Fitlibrary.Specify.AnotherActor</class-id> <category>operatoins</category><body package="FitLibrary-SpecFixtures">switchBack	ActionFixture actor: test</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUpWithException</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">setUp	Error raise</body><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Parser.Byte</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setValue: aNumber	value := aNumber</body></methods><methods><class-id>Fitlibrary.Specify.Parser.Byte class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	| value |	value := Number fitParse: aString.	(value between: 0 and: 127)		ifFalse: [^ArithmeticError raiseErrorString: 'Invalid number format'].	^self value: value</body><body package="FitLibrary-SpecFixtures">value: anInteger	^self new setValue: anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.Byte class</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitLibraryIsPrimitive	^true</body></methods><methods><class-id>Fitlibrary.Specify.SetFixtureUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: CamelRowFixtureUnderTest new query</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.OtherFixturing</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	value := 0</body><body package="FitLibrary-SpecFixtures">setValue: anInteger	value := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.OtherFixturing class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body><body package="FitLibrary-SpecFixtures">value: anInteger	^self new setValue: anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Colour</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">&lt;=&gt; anObject	(anObject isKindOf: self class) ifFalse: [^-1].	^colour &lt;=&gt; anObject colour</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Colour</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= anObject	(anObject isKindOf: self class) ifFalse: [^false].	^colour = anObject colour</body><body package="FitLibrary-SpecFixtures">hash	^colour hash</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Colour</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'Colour[' , colour , ']'</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Colour class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">colour: aString	^self new setColour: aString</body><body package="FitLibrary-SpecFixtures">fitParse: aString	^self colour: aString</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Colour class</class-id> <category>colours</category><body package="FitLibrary-SpecFixtures">black	^self colour: 'black'</body><body package="FitLibrary-SpecFixtures">blue	^self colour: 'blue'</body><body package="FitLibrary-SpecFixtures">green	^self colour: 'green'</body><body package="FitLibrary-SpecFixtures">red	^self colour: 'red'</body><body package="FitLibrary-SpecFixtures">white	^self colour: 'white'</body><body package="FitLibrary-SpecFixtures">yellow	^self colour: 'yellow'</body></methods><methods><class-id>Fitlibrary.Specify.Plugin.Crash</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">makeMeAnInterface	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.ResetCounts</class-id> <category>enumerating</category><body package="FitLibrary-SpecFixtures">doTable: aParse	counts initialize</body></methods><methods><class-id>Fitlibrary.Specify.FailConstraint class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self expected: false</body></methods><methods><class-id>Fitlibrary.Specify.GraphicElement</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setI: anInteger tree: aListTree	i := anInteger.	tree := aListTree</body></methods><methods><class-id>Fitlibrary.Specify.GraphicElement class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">i: anInteger tree: aString	^self new setI: anInteger tree: (ListTree fitParse: aString)</body></methods><methods><class-id>Fitlibrary.Specify.InitialClass.ClassWithNoNullaryConstructor class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^Fit.Exceptions.ShouldNotImplement raise</body></methods><methods><class-id>Fitlibrary.Specify.Domain.PrivateUser</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">dummyAbstractMethod	" *** This method was defined by Fitlibrary.Specify.Domain.AbstractUser as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Fitlibrary.Specify.MissingMethod.Mix class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">colour: aColour quantity: anInteger</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.FixedPointSuperDelegate</class-id> <category>matching</category><body package="FitLibrary-SpecFixtures">expected: expectedFixedPointInterface matches: actualFixedPointInterface	^expectedFixedPointInterface x = actualFixedPointInterface x</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.FixedPointSuperDelegate</class-id> <category>showing</category><body package="FitLibrary-SpecFixtures">show: anObject	anObject ifNil: [^'null'].	^'point: ' , anObject fitToString</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.FixedPointSuperDelegate</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">fitParse: aString	| comma |	((aString beginsWith: '(') and: [aString endsWith: ')'])		ifFalse: [^self error: 'Badly formatted point'].	comma := aString indexOf: $,.	comma isZero ifTrue: [^self error: 'Badly formatted point'].	^FitLibraryFixedPoint		x: (Integer fitParse: (aString copyFrom: 2 to: comma - 1))		y: (Integer fitParse: (aString copyFrom: comma + 1 to: aString size - 1))</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureFlowUnderTest</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self		registerParseDelegateObject: (SimpleDateFormat format: 'yyyy/mm/dd hh:mm')		forClass: Timestamp</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureFlowUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self systemUnderTest: SystemUnderTest new</body></methods><methods><class-id>Fitlibrary.Specify.InnerCalculate2</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self		repeatString: '"';		exceptionString: 'exception'</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPoint2</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aMyPoint2	^x = aMyPoint2 x and: [y = aMyPoint2 y]</body><body package="FitLibrary-SpecFixtures">hash	^x hash hashMultiply bitXor: y hash</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPoint2</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setX: xInteger y: yInteger	x := xInteger.	y := yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPoint2</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'(&lt;1p&gt;,&lt;2p&gt;)' expandMacrosWith: x with: y</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPoint2 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	^self new setX: xInteger y: yInteger</body></methods><methods><class-id>Fitlibrary.Specify.EntityInNestedArray</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	second := Entity string: 'second'</body><body package="FitLibrary-SpecFixtures">setFirst: anEntity	first := anEntity</body></methods><methods><class-id>Fitlibrary.Specify.EntityInNestedArray class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	| first |	first := Entity string: 'first'.	^(self actuals: (Array with: (EntityElement type: first))) setFirst: first</body></methods><methods><class-id>Fitlibrary.Specify.SimpleDateFormat</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitParse: aString 	^(TimestampReader newFor: #fitLibrary) 		readTimestampFrom: aString readStream</body><body package="FitLibrary-SpecFixtures">toString: aTimestamp 	| ws |	ws := String new writeStream.	TimestampPrintPolicy 		print: aTimestamp		on: ws		using: format.	^ws contents</body></methods><methods><class-id>Fitlibrary.Specify.SimpleDateFormat</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setFormat: aString	format := aString</body></methods><methods><class-id>Fitlibrary.Specify.SimpleDateFormat class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">format: aString	^self new setFormat: aString</body></methods><methods><class-id>Fitlibrary.Specify.Eg.UnparsedPoint</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setX: xInteger y: yInteger	x := xInteger.	y := yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.UnparsedPoint class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	^self new setX: xInteger y: yInteger</body></methods><methods><class-id>Fitlibrary.Specify.MissingProperty.InDomainAdapter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^InJustSut new</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Rectangle</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	x := 0.	y := 0.	width := 0.	height := 0</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Rectangle class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadConstructorsInNestedObjects</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	employee := Employee new</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadConstructorsInNestedObjects</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">employee	^employee</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadConstructorsInNestedObjects class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Domain.NoNullaryUserFromInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	" *** This method was defined by Fitlibrary.Specify.Domain.AbstractUserAsInterface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="FitLibrary-SpecFixtures">name: aString	" *** This method was defined by Fitlibrary.Specify.Domain.AbstractUserAsInterface as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Fitlibrary.Specify.Domain.NoNullaryUserFromInterface class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^Fit.Exceptions.ShouldNotImplement raise</body></methods><methods><class-id>Fitlibrary.Specify.DomainAdapterUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^sut</body></methods><methods><class-id>Fitlibrary.Specify.DomainAdapterUnderTest</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	sut := Sut new</body></methods><methods><class-id>Fitlibrary.Specify.DomainAdapterUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Plugin.HasNewInstancePlugin</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.MissingMethod.NestedFinderInDomainAdapter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^NestedDomainAdapterToo new</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Maps</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	aStringMap := Dictionary new.	aColourMap := (Dictionary new)				at: Colour red put: Colour green;				at: Colour yellow put: Colour blue;				yourself</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Maps class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ClassWithNoTypeAdapter</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'77'</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpList</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	iOUs := OrderedCollection new</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpList class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>FitlibraryGeneric.Specify.PrePopulated</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	colour := Colour named: 'yellow'</body></methods><methods><class-id>FitlibraryGeneric.Specify.PrePopulated class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ParserUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">classDouble: aDouble	^true</body><body package="FitLibrary-SpecFixtures">classDoubleNull: aDouble	^aDouble isNil</body><body package="FitLibrary-SpecFixtures">classFloat: aFloat	^true</body><body package="FitLibrary-SpecFixtures">classFloatNull: aFloat	^aFloat isNil</body><body package="FitLibrary-SpecFixtures">classLong: anInteger	^true</body><body package="FitLibrary-SpecFixtures">classLongNull: anInteger	^anInteger isNil</body><body package="FitLibrary-SpecFixtures">classShort: aSmallInteger	^true</body><body package="FitLibrary-SpecFixtures">classShortNull: aSmallInteger	^aSmallInteger isNil</body><body package="FitLibrary-SpecFixtures">integer: anInteger	^true</body><body package="FitLibrary-SpecFixtures">integerNull: anInteger	^anInteger isNil</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ParserUnderTest</class-id> <category>type access</category><body package="FitLibrary-SpecFixtures">signatureFor: aSymbol	(#(#classFloat: #classFloatNull:) includes: aSymbol)		ifTrue: 			[^MethodSignature with: (Float fitTypeAdapter allowNil: true)				returning: Boolean].	(#(#classDouble: #classDoubleNull:) includes: aSymbol)		ifTrue: 			[^MethodSignature with: (Double fitTypeAdapter allowNil: true)				returning: Boolean].	(#(#classShort: #classShortNull:) includes: aSymbol)		ifTrue: 			[^MethodSignature with: (SmallInteger fitTypeAdapter allowNil: true)				returning: Boolean].	(#(#integer: #integerNull: #classLong: #classLongNull:) includes: aSymbol)		ifTrue: 			[^MethodSignature with: (Integer fitTypeAdapter allowNil: true)				returning: Boolean].	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ClassDelegate</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	self registerParseDelegateClass: MyValueTwoClassDelegate forClass: MyValue2</body></methods><methods><class-id>Fitlibrary.Specify.Combine</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	isSetUp := false</body><body package="FitLibrary-SpecFixtures">setUp	isSetUp := true</body><body package="FitLibrary-SpecFixtures">tearDown	self error: 'tear down'</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableMethodsThrowExceptionsSut</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	inThrowsException := false.	outThrowsException := false.	resetThrowsException := false.	executeThrowsException := false.	in := 0</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableMethodsThrowExceptionsSut class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.SubsetFixtureUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: CamelRowFixtureUnderTest new query</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.TearDown</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body><body package="FitLibrary-SpecFixtures">tearDown	Error raise</body></methods><methods><class-id>Fitlibrary.Specify.EntitySubElement</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setType: anEntity	actionEntities := Array with: (ActionEntity type: anEntity)				with: (ActionEntity type: anEntity)</body></methods><methods><class-id>Fitlibrary.Specify.EntitySubElement class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">type: anEntity	^self new setType: anEntity</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.Person</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setName: aString	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.Person class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">named: aString	^self new setName: aString</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Manager class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">named: aString</body><body package="FitLibrary-SpecFixtures">new	^Fit.Exceptions.ShouldNotImplement raise</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestWithScientificDouble class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: (Array				with: (ScientificDoublePair i: 1.11 j: 2.22)				with: (ScientificDoublePair i: 1.11 j: 2.22)				with: (ScientificDoublePair i: 1.11 j: 2.22))</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedShow</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableWithResetAndExecuteSut</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	executes := 0.	resets := 0</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableWithResetAndExecuteSut class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fit.Specify.MockClass</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">number: aNumber 	a := aNumber</body><body package="FitLibrary-SpecFixtures">string: aString 	s := aString</body></methods><methods><class-id>Fit.Specify.MockClass class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">number: aNumber string: aString 	^(self new)		number: aNumber;		string: aString;		yourself</body></methods><methods><class-id>Fitlibrary.Specify.MockCollection</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setPlus: anInteger ampersand: aString	plus := anInteger.	ampersand := aString</body></methods><methods><class-id>Fitlibrary.Specify.MockCollection class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">plus: anInteger ampersand: aString	^self new setPlus: anInteger ampersand: aString</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.GenericMaps</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">cyclicMap: aColour to: bColour	aMapOfMaps at: aColour put: (Dictionary with: bColour -&gt; aColour)</body><body package="FitLibrary-SpecFixtures">initialize	super initialize.	aMap := (Dictionary new)				at: Colour green put: Colour blue;				at: Colour black put: Colour yellow;				yourself.	aMapOfMaps := Dictionary new.	self		cyclicMap: Colour red to: Colour green;		cyclicMap: Colour white to: Colour black;		cyclicMap: Colour blue to: Colour yellow</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.GenericMaps class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSut</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setCount: anInteger	count := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSut class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">count: anInteger	^self new setCount: anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Set.Fields</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">field1: anInteger	field1 := anInteger</body><body package="FitLibrary-SpecFixtures">field2: anInteger	field2 := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Set.Fields class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">field1: anInteger1 field2: anInteger2	^(self new)		field1: anInteger1;		field2: anInteger2;		yourself</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedFinder</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTest3 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: OrderedCollection new</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.InnerDate</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setDateString: aString	dateString := aString</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.InnerDate</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">dateString	^dateString</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.InnerDate</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^dateString</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.InnerDate</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= anInnerDate	^dateString = anInnerDate dateString</body><body package="FitLibrary-SpecFixtures">hash	^dateString hash</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.InnerDate class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fromString: aString	^self new setDateString: aString</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureTearDown</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">tearDown	^self error: 'TearDown Worked.'</body></methods><methods><class-id>Fitlibrary.Specify.Suite.Simple</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	count := 0</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Colour class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.NoParsePoint</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aNoParsePoint	^x = aNoParsePoint x and: [y = aNoParsePoint y]</body><body package="FitLibrary-SpecFixtures">hash	^x hash hashMultiply bitXor: y hash</body></methods><methods><class-id>Fitlibrary.Specify.NoParsePoint</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setX: xInteger y: yInteger	x := xInteger.	y := yInteger</body></methods><methods><class-id>Fitlibrary.Specify.NoParsePoint</class-id> <category>adding</category><body package="FitLibrary-SpecFixtures">plus: aNoParsePoint	^self class x: x + aNoParsePoint x y: y + aNoParsePoint y</body></methods><methods><class-id>Fitlibrary.Specify.NoParsePoint class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	^self new setX: xInteger y: yInteger</body></methods><methods><class-id>Fitlibrary.Specify.DynamicVariable.CheckDynamicVariable</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext</body><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadClassFromClassFactoryMethodForInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureSetUpWithException</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setUp	self error: 'setUp exception.'</body></methods><methods><class-id>Fitlibrary.Specify.MissingProperty.InJustSut</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	colour := Colour new</body></methods><methods><class-id>Fitlibrary.Specify.MissingProperty.InJustSut class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.SystemUnderTest</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	sum := 0.	concat := ''</body></methods><methods><class-id>Fitlibrary.Specify.SystemUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Lists</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	aColourList := OrderedCollection with: Colour red with: Colour green</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Lists class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.MyClassPair</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setOne: aMyClass two: bMyClass	one := aMyClass.	two := bMyClass</body></methods><methods><class-id>Fitlibrary.Specify.MyClassPair class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">i: iInteger j: jInteger	^self new setOne: (MyClass i: iInteger) two: (MyClass i: jInteger)</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Colour2</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Colour2 class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^self new</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setValue: anInteger	value := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aMyValue	^aMyValue class == self class and: [value = aMyValue value]</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^value printString</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	^value</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValue class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	^self value: (Integer fitParse: aString)</body><body package="FitLibrary-SpecFixtures">value: anInteger	^self new setValue: anInteger</body></methods><methods><class-id>Fit.Specify.ClearActionFixture</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	ActionFixture actor: nil</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.DoubleUse</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	calc := LocalCalculateFixture new</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.DoubleUse class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPoint2Editor</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">getAsText	^'[&lt;1p&gt;,&lt;2p&gt;]' expandMacrosWith: value x with: value y</body><body package="FitLibrary-SpecFixtures">setAsText: aString	| comma |	((aString beginsWith: $() and: [aString endsWith: $)])		ifFalse: [^self error: 'Badly formatted point'].	comma := aString indexOf: $,.	comma isZero ifTrue: [^self error: 'Badly formatted point'].	^self value: (MyPoint2 x: (aString copyFrom: 2 to: comma - 1) asNumber				y: (aString copyFrom: comma + 1 to: aString size - 1) asNumber)</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPoint2Editor class</class-id> <category>testing</category><body package="FitLibrary-SpecFixtures">isForClass: aClass	^aClass == MyPoint2</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureWithExceptionInConstructor class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self error: 'Bad constructor'</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.Ab</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	a := 0.	b := 2</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.Ab class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureSetUpWithException</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">setUp	Error raiseErrorString: 'setUp exception.'</body></methods><methods><class-id>Fitlibrary.Specify.DirectCombination class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self systemUnderTest: TimesCombination new</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTest class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self actuals: CamelRowFixtureUnderTest new query</body></methods><methods><class-id>Fitlibrary.Specify.Plugin.ConcretePerson class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^self basicNew</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUp</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	setUp := false</body><body package="FitLibrary-SpecFixtures">setUp	setUp := true</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUp</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUp class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Eg.User</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">addDebt: aDouble	owe := owe + aDouble</body></methods><methods><class-id>Fitlibrary.Specify.Eg.User</class-id> <category>phones</category><body package="FitLibrary-SpecFixtures">addPhoneCountry: countryInteger region: regionInteger number: numberInteger	phones add: (Phone				country: countryInteger				region: regionInteger				number: numberInteger)</body></methods><methods><class-id>Fitlibrary.Specify.Eg.User</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setName: aString owing: aNumber	self name: aString.	self owe: aNumber.	phones := OrderedCollection new</body></methods><methods><class-id>Fitlibrary.Specify.Eg.User class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">named: aString owing: aNumber	^self new setName: aString owing: aNumber</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.GenericCollections</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	aList := OrderedCollection with: Colour red with: Colour green.	aSet := Set with: Colour red with: Colour green.	aListOfLists := OrderedCollection				with: (OrderedCollection with: Colour red with: Colour green)				with: (OrderedCollection with: Colour yellow with: Colour blue).	aSetOfSets := Set with: (Set with: Colour red with: Colour green)				with: (Set with: Colour yellow with: Colour blue).	aListOfSets := OrderedCollection				with: (Set with: Colour red with: Colour green)				with: (Set with: Colour yellow with: Colour blue).	aListOfString := OrderedCollection new</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.GenericCollections class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.OnFailureWithException</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">onFailure	FitLibraryException raiseErrorString: 'onFailure() called'</body><body package="FitLibrary-SpecFixtures">systemUnderTest	^nil</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpSet</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	iOUSet := Set new</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpSet class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Local</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">s: aString	s := aString</body></methods><methods><class-id>Fitlibrary.Specify.Local class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">string: aString	^self new s: aString</body></methods><methods><class-id>Fitlibrary.Specify.Plugin.Dog</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">makeMeAnInterface	^self subclassResponsibility</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Objects</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	user := User new.	user name: 'Paul'.	user account: (Account id: 2 paymentHistory: 'good payer')</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Objects class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Sum</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">initialize	super initialize.	sum := 0</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Sum class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">new	^super new initialize</body></methods><methods><class-id>Fitlibrary.Specify.Eg.MyPoint</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setX: xInteger y: yInteger	x := xInteger.	y := yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.MyPoint</class-id> <category>comparing</category><body package="FitLibrary-SpecFixtures">= aPoint	^aPoint x = x and: [aPoint y = y]</body><body package="FitLibrary-SpecFixtures">hash	^x hash hashMultiply bitXor: y hash</body></methods><methods><class-id>Fitlibrary.Specify.Eg.MyPoint</class-id> <category>fit-utilities</category><body package="FitLibrary-SpecFixtures">fitToString	^'(&lt;1p&gt;,&lt;2p&gt;)' expandMacrosWith: x with: y</body></methods><methods><class-id>Fitlibrary.Specify.Eg.MyPoint class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fitParse: aString	| comma |	((aString beginsWith: $() and: [aString endsWith: $)])		ifFalse: [^self error: 'Badly formatted point'].	comma := aString indexOf: $,.	comma isZero ifTrue: [^self error: 'Badly formatted point'].	^self x: (aString copyFrom: 2 to: comma - 1) asNumber		y: (aString copyFrom: comma + 1 to: aString size - 1) asNumber</body><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	^self new setX: xInteger y: yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.AnyCharactersInActions</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">leftSquareBracket: arg1 ampersandAmpersandRightSquareBracketEquals: arg2	&lt;fitTakes: #(#Boolean #Boolean)&gt;	&lt;fitReturns: #Boolean&gt;	^arg1 &amp; arg2</body><body package="FitLibrary-SpecFixtures">plus: arg1 equals: arg2	&lt;fitTakes: #(#Number #Number)&gt;	&lt;fitReturns: #Number&gt;	^arg1 + arg2</body><body package="FitLibrary-SpecFixtures">quoteQuotePlusQuote: arg1 quoteEquals: arg2	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #String&gt;	^arg1 , ' ' , arg2</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">getCamelFieldName: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^aString</body><body package="FitLibrary-SpecFixtures">increment	&lt;fitReturns: #Integer&gt;	| result |	result := count.	count := count + 1.	^result</body><body package="FitLibrary-SpecFixtures">minusA: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger - bInteger</body><body package="FitLibrary-SpecFixtures">plus12: aListTree _: bListTree	&lt;fitTakes: #(#ListTree #ListTree)&gt;	&lt;fitReturns: #ListTree&gt;	^ListTree title: '' children: (Array with: aListTree with: bListTree)</body><body package="FitLibrary-SpecFixtures">plusA: aInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Integer&gt;	^aInteger</body><body package="FitLibrary-SpecFixtures">plusA: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger</body><body package="FitLibrary-SpecFixtures">plusName: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^aString , '+'</body><body package="FitLibrary-SpecFixtures">sum: aInteger _: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger</body><body package="FitLibrary-SpecFixtures">useCalendar: aCalendar	&lt;fitTakes: #{Calendar}&gt;	&lt;fitReturns: #{Calendar}&gt;	^aCalendar</body><body package="FitLibrary-SpecFixtures">voidMethod	&lt;fitReturns: #Void&gt;</body></methods><methods><class-id>Fit.Specify.MyColumnFixture</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">x: anInteger	&lt;fitTakes: #Integer&gt;	x := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.ArrayFixtureUnderTestWithMap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">map	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection		with: (self makeMapPlus: 1 ampersand: 'one')		with: (self makeMapPlus: 1 ampersand: 'two')		with: (self makeMapPlus: 2 ampersand: 'two')</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableExampleSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">in: anInteger	&lt;fitTakes: #Integer&gt;	in := anInteger</body><body package="FitLibrary-SpecFixtures">out	&lt;fitReturns: #Integer&gt;	^in + in2</body><body package="FitLibrary-SpecFixtures">setIn2: anInteger	&lt;fitTakes: #Integer&gt;	in2 := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ObjectDelegateForDate</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">date	&lt;fitReturns: #Timestamp&gt;	^(Date newDay: 3 monthNumber: 3 year: 2004) asTimestamp</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPointStringConstructor</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPointStringConstructor class</class-id> <category>instance creation</category><body package="FitLibrary-SpecFixtures">fromString: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #MyPointStringConstructor&gt;	| comma |	((aString beginsWith: $() and: [aString endsWith: $)])		ifFalse: [^self error: 'Badly formatted point'].	comma := aString indexOf: $,.	comma isZero ifTrue: [^self error: 'Badly formatted point'].	^self x: (aString copyFrom: 2 to: comma - 1) asNumber		y: (aString copyFrom: comma + 1 to: aString size - 1) asNumber</body></methods><methods><class-id>Fitlibrary.Specify.SimplePhone</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">phone	&lt;fitReturns: #String&gt;	^phone</body></methods><methods><class-id>Fitlibrary.Specify.Domain.PropertyOfInterfaceType</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">abstractUser	&lt;fitReturns: #AbstractUserAsInterface&gt;	^user</body><body package="FitLibrary-SpecFixtures">abstractUser: anAbstractUserAsInterface	&lt;fitTakes: #AbstractUserAsInterface&gt;	user := anAbstractUserAsInterface</body><body package="FitLibrary-SpecFixtures">concreteClassOfAbstractUserAsInterface: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Class&gt;	aString = 'Bad Payer' ifTrue: [^BadPayerFromInterface].	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByToString</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #Value2&gt;	^Value2 new</body></methods><methods><class-id>Fitlibrary.Specify.Domain.EmptyCellIsNull</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">user	&lt;fitReturns: #UserWithManager&gt;	^user</body><body package="FitLibrary-SpecFixtures">user: aUserWithManager	&lt;fitTakes: #UserWithManager&gt;	user := aUserWithManager</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByShow</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">findEmptyUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #EmptyUser&gt;	^EmptyUser new	"Won't match"</body><body package="FitLibrary-SpecFixtures">showEmptyUser: anEmptyUser	&lt;fitTakes: #EmptyUser&gt;	ForcedException raise</body><body package="FitLibrary-SpecFixtures">user	&lt;fitReturns: #EmptyUser&gt;	^EmptyUser new</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.ParseMyFixedPointAsStringWithDelegate</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aFixedPoint: aFixedPoint	&lt;fitTakes: #FitLibraryFixedPoint&gt;	&lt;fitReturns: #FitLibraryFixedPoint&gt;	^aFixedPoint</body><body package="FitLibrary-SpecFixtures">aFixedPointAsDomainObject: aFixedPoint	&lt;fitTakes: #FitLibraryFixedPoint&gt;	&lt;fitReturns: #TraverseBase&gt;	^DomainObjectCheckTraverse systemUnderTest: aFixedPoint</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.UserAdapter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">add: aUser debt: aDouble	&lt;fitTakes: #(#User #Double)&gt;	&lt;fitReturns: #Boolean&gt;	user addDebt: aDouble.	^true</body><body package="FitLibrary-SpecFixtures">findUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #User&gt;	^users at: aString ifAbsent: [^self error: 'Unknown user']</body><body package="FitLibrary-SpecFixtures">user	&lt;fitReturns: #User&gt;	^user</body><body package="FitLibrary-SpecFixtures">user: aUser	&lt;fitTakes: #User&gt;	user := aUser.	users at: user name put: user</body></methods><methods><class-id>Fitlibrary.Specify.Parser.UsePropertyEditor</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aPoint: aMyPoint2	&lt;fitTakes: #MyPoint2&gt;	&lt;fitReturns: #MyPoint2&gt;	^aMyPoint2</body><body package="FitLibrary-SpecFixtures">aPointAsDomainObject: aMyPoint2	&lt;fitTakes: #MyPoint2&gt;	&lt;fitReturns: #TraverseBase&gt;	^DomainObjectCheckTraverse systemUnderTest: aMyPoint2</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.GenericCollectionsUseObjectFactory</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aList	&lt;fitReturns: #(#OrderedCollection #Colour)&gt;	^aList</body><body package="FitLibrary-SpecFixtures">aList: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection   #Colour ))&gt;	aList := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">aSet	&lt;fitReturns: #(#Set #Colour)&gt;	^aSet</body><body package="FitLibrary-SpecFixtures">aSet: newSet	&lt;fitTakes: #(#( #Set   #Colour ))&gt;	aSet := newSet</body><body package="FitLibrary-SpecFixtures">colourRenamed: aColour	&lt;fitTakes: #Colour&gt;	&lt;fitReturns: #Colour&gt;	^aColour</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.ParseMyPoint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aPoint: aMyPoint	&lt;fitTakes: #MyPoint&gt;	&lt;fitReturns: #MyPoint&gt;	^aMyPoint</body><body package="FitLibrary-SpecFixtures">aPointAsDomainObject: aPoint	&lt;fitTakes: #MyPoint&gt;	&lt;fitReturns: #TraverseBase&gt;	^DomainObjectCheckTraverse systemUnderTest: aPoint</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Account</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">id	&lt;fitReturns: #Integer&gt;	^id</body><body package="FitLibrary-SpecFixtures">id: anInteger	&lt;fitTakes: #Integer&gt;	id := anInteger</body><body package="FitLibrary-SpecFixtures">paymentHistory	&lt;fitReturns: #String&gt;	^paymentHistory</body><body package="FitLibrary-SpecFixtures">paymentHistory: aString	&lt;fitTakes: #String&gt;	paymentHistory := aString</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedEquals</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">findUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #User&gt;	^User new</body><body package="FitLibrary-SpecFixtures">project	&lt;fitReturns: #Project2&gt;	^Project2 new</body></methods><methods><class-id>Fitlibrary.Specify.MapTraverse.ColourMap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">colourMap	&lt;fitReturns: #Dictionary&gt;	^(Dictionary new)		at: Colour red put: Colour green;		at: Colour yellow put: Colour blue;		yourself</body></methods><methods><class-id>Fitlibrary.Specify.Constraint.SetUpAndTearDownCalled</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Boolean&gt;	^isSetUp and: [aInteger &lt; bInteger]</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Phone</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">country	&lt;fitReturns: #Integer&gt;	^country</body><body package="FitLibrary-SpecFixtures">country: anInteger	&lt;fitTakes: #Integer&gt;	country := anInteger</body><body package="FitLibrary-SpecFixtures">number	&lt;fitReturns: #Integer&gt;	^number</body><body package="FitLibrary-SpecFixtures">number: anInteger	&lt;fitTakes: #Integer&gt;	number := anInteger</body><body package="FitLibrary-SpecFixtures">region	&lt;fitReturns: #Integer&gt;	^region</body><body package="FitLibrary-SpecFixtures">region: anInteger	&lt;fitTakes: #Integer&gt;	region := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadClassFromClassFactoryMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">abstractUser: anAbstractUser	&lt;fitTakes: #AbstractUser&gt;</body><body package="FitLibrary-SpecFixtures">concreteClassOfAbstractUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Class&gt;	aString = 'No Nullary' ifTrue: [^NoNullaryUser].	aString = 'Private' ifTrue: [^PrivateUser].	aString = 'String' ifTrue: [^String].	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Entity</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">entity	&lt;fitReturns: #Entity&gt;	^ExplicitSelf for: self</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.ParserDelegateMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">findInnerDate: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #InnerDate&gt;	^InnerDate fromString: aString</body><body package="FitLibrary-SpecFixtures">sameDate: anInnerDate	&lt;fitTakes: #InnerDate&gt;	&lt;fitReturns: #InnerDate&gt;	^anInnerDate</body><body package="FitLibrary-SpecFixtures">showInnerDate: anInnerDate	&lt;fitTakes: #InnerDate&gt;	&lt;fitReturns: #String&gt;	^anInnerDate fitToString</body></methods><methods><class-id>Fitlibrary.Specify.Suite.MyOtherDoFixture</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">actionOnThat	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.Select.FirstSelectTraverse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count	&lt;fitReturns: #Integer&gt;	^1</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ObjectDelegate</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aValueSetWithAnObjectDelegate	&lt;fitReturns: #ArrayFixture&gt;	| values |	values := Array with: (MyValueHolder2 value: (MyValue2 value: 1))				with: (MyValueHolder2 value: (MyValue2 value: 2)).	^ArrayFixture actuals: values</body></methods><methods><class-id>Fitlibrary.Specify.AggregateDomainObject</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">checkBook	&lt;fitReturns: #DomainObjectCheckFixture&gt;	^DomainObjectCheckFixture systemUnderTest: book</body><body package="FitLibrary-SpecFixtures">createBook	&lt;fitReturns: #DomainObjectSetUpFixture&gt;	^DomainObjectSetUpFixture systemUnderTest: book</body><body package="FitLibrary-SpecFixtures">name: aString phones: aSet address: anAddress	&lt;fitTakes: #( #String  #{Core.Set}  #Address )&gt;	&lt;fitReturns: #Author&gt;	^Author name: aString phones: aSet address: anAddress</body><body package="FitLibrary-SpecFixtures">name: nameString value: valueString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #KeyValue&gt;	^KeyValue name: nameString value: valueString</body><body package="FitLibrary-SpecFixtures">phone: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #SimplePhone&gt;	^SimplePhone phone: aString</body></methods><methods><class-id>Fitlibrary.Specify.Autowrap.Pojo</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">identity: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Integer&gt;	^anInteger</body></methods><methods><class-id>Fitlibrary.Specify.ArrayParser.Match</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">array123	&lt;fitReturns: #(#Integer)&gt;	^#(1 2 3)</body><body package="FitLibrary-SpecFixtures">arrayEmpty	&lt;fitReturns: #(#Integer)&gt;	^#()</body></methods><methods><class-id>Fitlibrary.Specify.TeeTree</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">children	&lt;fitReturns: #OrderedCollection&gt;	^tree children</body><body package="FitLibrary-SpecFixtures">title	&lt;fitReturns: #String&gt;	^tree title</body></methods><methods><class-id>Fitlibrary.Specify.InnerCalculate3</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">plusA: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger</body></methods><methods><class-id>FitlibraryGeneric.Specify.Colour</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">colour	&lt;fitReturns: #String&gt;	^colour</body><body package="FitLibrary-SpecFixtures">point	&lt;fitReturns: #MyPoint&gt;	^point</body><body package="FitLibrary-SpecFixtures">setPoint: aMyPoint	&lt;fitTakes: #MyPoint&gt;	point := aMyPoint</body></methods><methods><class-id>FitlibraryGeneric.Specify.Colour</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setColour: aString	&lt;fitTakes: #String&gt;	colour := aString.	point := MyPoint x: 3 y: 4</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueHolder</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #MyValue&gt;	^value</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Keywords</class-id> <category>actions</category><body package="FitLibrary-SpecFixtures">buy: quantityInteger atDollar: aFloat withDiscountPercent: percentNumber	&lt;fitTakes: #(#Integer #Double #Number)&gt;	sum := sum + (quantityInteger * aFloat * ((100 - percentNumber) / 100))</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Keywords</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">sum	&lt;fitReturns: #Double&gt;	^sum</body><body package="FitLibrary-SpecFixtures">totalOwingDollar	&lt;fitReturns: #Double&gt;	^sum</body></methods><methods><class-id>Fitlibrary.Specify.Domain.UserAdapter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">slowPayingUser	&lt;fitReturns: #User&gt;	^(User named: 'Poor Payer' owing: 10000.0)		addPhoneCountry: 64 region: 9 number: 3737598;		addPhoneCountry: 64 region: 27 number: 4556112;		account: (Account id: 456778 paymentHistory: 'poor');		yourself</body><body package="FitLibrary-SpecFixtures">user	&lt;fitReturns: #User&gt;	^user</body><body package="FitLibrary-SpecFixtures">user: aUser	&lt;fitTakes: #User&gt;	user := aUser</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByGetter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">checkUser	&lt;fitReturns: #Object&gt;	^DomainObjectCheckTraverse systemUnderTest: User new</body></methods><methods><class-id>Fitlibrary.Specify.Book</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">attributes	&lt;fitReturns: #OrderedCollection&gt;	^attributes</body><body package="FitLibrary-SpecFixtures">attributes: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	attributes := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">authors	&lt;fitReturns: #OrderedCollection&gt;	^authors</body><body package="FitLibrary-SpecFixtures">authors: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	authors := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">publisher	&lt;fitReturns: #Publisher&gt;	^publisher</body><body package="FitLibrary-SpecFixtures">publisher: aPublisher	&lt;fitTakes: #Publisher&gt;	publisher := aPublisher</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpMap</class-id> <category>setup</category><body package="FitLibrary-SpecFixtures">name: aString owe: aDouble	&lt;fitTakes: #(#String #Double)&gt;	&lt;fitReturns: #User&gt;	^User named: aString owing: aDouble</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpMap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">iOUMap	&lt;fitReturns: #Dictionary&gt;	^iOUMap</body><body package="FitLibrary-SpecFixtures">iOUMap: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	anOrderedCollection do: [:each | iOUMap at: each name put: each]</body></methods><methods><class-id>Fitlibrary.Specify.KeyValue</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #String&gt;	^value</body></methods><methods><class-id>Fitlibrary.Specify.Domain.MissingClassFactoryMethodForInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">abstractUser: anAbstractUserAsInterface	&lt;fitTakes: #AbstractUserAsInterface&gt;</body></methods><methods><class-id>Fitlibrary.Specify.Domain.NotConcrete</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">abstractUser	&lt;fitReturns: #AbstractUser&gt;	^user</body><body package="FitLibrary-SpecFixtures">abstractUser: anAbstractUser	&lt;fitTakes: #AbstractUser&gt;	user := anAbstractUser</body><body package="FitLibrary-SpecFixtures">concreteClassOfAbstractUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Class&gt;	aString = 'Bad Payer' ifTrue: [^BadPayer].	^nil</body></methods><methods><class-id>Fitlibrary.Specify.Collection.NullInCollection</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">getList	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: nil with: 'fitlibrary'</body></methods><methods><class-id>Fitlibrary.Specify.ListParser.ParseCounts</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Count&gt;	^Count count: anInteger</body><body package="FitLibrary-SpecFixtures">givenColours: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection</body><body package="FitLibrary-SpecFixtures">givenCounts: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection</body><body package="FitLibrary-SpecFixtures">givenIterator: anOrderedCollection	"Smalltalk doesn't have iterators, so we just use an OrderedCollection again"	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection</body></methods><methods><class-id>Fitlibrary.Specify.ValueObject.ParseMyFixedPointAsStringWithSuperDelegate</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aFixedPoint: aFixedPoint	&lt;fitTakes: #FitLibraryFixedPoint&gt;	&lt;fitReturns: #FitLibraryFixedPoint&gt;	^aFixedPoint</body><body package="FitLibrary-SpecFixtures">aFixedPointAsDomainObject: aFixedPoint	&lt;fitTakes: #FitLibraryFixedPoint&gt;	&lt;fitReturns: #TraverseBase&gt;	^DomainObjectCheckTraverse systemUnderTest: aFixedPoint</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSetUpSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">andMore	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">andMoreBesides	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">andSomeImmediateAction	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">localSetUpCount	&lt;fitReturns: #Integer&gt;	^setUps</body></methods><methods><class-id>Fit.Specify.ColumnFixtureUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a: anInteger	&lt;fitTakes: #Integer&gt;	a := anInteger</body><body package="FitLibrary-SpecFixtures">b: anInteger	&lt;fitTakes: #Integer&gt;	b := anInteger</body><body package="FitLibrary-SpecFixtures">calendar: aCalendar	&lt;fitTakes: #{Calendar}&gt;	calendar := aCalendar</body><body package="FitLibrary-SpecFixtures">camelFieldName: aString	&lt;fitTakes: #String&gt;	camelFieldName := aString</body></methods><methods><class-id>Fit.Specify.ColumnFixtureUnderTest</class-id> <category>actions</category><body package="FitLibrary-SpecFixtures">exceptionMethod	&lt;fitReturns: #Error&gt;	Error raise</body><body package="FitLibrary-SpecFixtures">getCamelFieldName	&lt;fitReturns: #String&gt;	^camelFieldName</body><body package="FitLibrary-SpecFixtures">increment	&lt;fitReturns: #Integer&gt;	| result |	result := count.	count := count + 1.	^result</body><body package="FitLibrary-SpecFixtures">minus	&lt;fitReturns: #Integer&gt;	^a - b</body><body package="FitLibrary-SpecFixtures">plus	&lt;fitReturns: #Integer&gt;	^a + b</body><body package="FitLibrary-SpecFixtures">useCalendar	&lt;fitReturns: #{Calendar}&gt;	^calendar</body><body package="FitLibrary-SpecFixtures">voidMethod	&lt;fitReturns: #Void&gt;</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.ExceptionAddsCells</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">addCellTo: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Error&gt;	(FitLibraryShowException		show: (Show htmlString: 'added: ' , aString , '&lt;hr&gt;next line')) raise</body></methods><methods><class-id>Fitlibrary.Specify.Set.AccessFields</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aSet	&lt;fitReturns: #Set&gt;	^Set with: (Fields field1: 3 field2: 4) with: (Fields field1: 1 field2: 2)</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.NullString</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">findInteger: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Integer&gt;	aString isEmpty ifTrue: [^0].	^(Integer fitParse: aString) abs</body><body package="FitLibrary-SpecFixtures">findString: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	aString isEmpty ifTrue: [^nil].	^aString</body><body package="FitLibrary-SpecFixtures">list	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: (Person named: 'Lars') with: (Person named: nil)</body><body package="FitLibrary-SpecFixtures">nullString	&lt;fitReturns: #String&gt;	^nil</body><body package="FitLibrary-SpecFixtures">otherString: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^aString</body><body package="FitLibrary-SpecFixtures">positiveInt: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Integer&gt;	^anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Domain.AbstractUser</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.Parser.UseConstructor</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aPoint: aMyPointStringConstructor	&lt;fitTakes: #MyPointStringConstructor&gt;	&lt;fitReturns: #MyPointStringConstructor&gt;	^aMyPointStringConstructor</body><body package="FitLibrary-SpecFixtures">aPointAsDomainObject: aPoint	&lt;fitTakes: #MyPoint&gt;	&lt;fitReturns: #TraverseBase&gt;	^DomainObjectCheckTraverse systemUnderTest: aPoint</body></methods><methods><class-id>Fitlibrary.Specify.NestedCalculateFixture</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">firstXPoints: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #Integer&gt;	^anOrderedCollection first x</body><body package="FitLibrary-SpecFixtures">identityPoints: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection</body><body package="FitLibrary-SpecFixtures">identitySetOfPoints: aSet	&lt;fitTakes: #{Core.Set}&gt;	&lt;fitReturns: #{Core.Set}&gt;	^aSet</body><body package="FitLibrary-SpecFixtures">pointX: xInteger y: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #NoParsePoint&gt;	^NoParsePoint x: xInteger y: yInteger</body><body package="FitLibrary-SpecFixtures">pointsList: anArray	&lt;fitTakes: #(#( #Integer ))&gt;	&lt;fitReturns: #OrderedCollection&gt;	| list |	list := OrderedCollection new.	1 to: anArray size		by: 2		do: 			[:index |			list add: (NoParsePoint x: (anArray at: index) y: (anArray at: index + 1))].	^list</body><body package="FitLibrary-SpecFixtures">pointsPoint: aNoParsePoint	&lt;fitTakes: #( #NoParsePoint )&gt;	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: aNoParsePoint with: aNoParsePoint</body><body package="FitLibrary-SpecFixtures">shiftedPointPoint: aNoParsePoint	&lt;fitTakes: #NoParsePoint&gt;	&lt;fitReturns: #NoParsePoint&gt;	^NoParsePoint x: aNoParsePoint x + 1 y: aNoParsePoint y + 1</body><body package="FitLibrary-SpecFixtures">validQuestionPoints: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #Boolean&gt;	[anOrderedCollection isEmpty] whileFalse: 			[| first |			first := anOrderedCollection removeFirst.			(anOrderedCollection includes: first) ifTrue: [^false]].	^true</body><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #NoParsePoint&gt;	^self pointX: xInteger y: yInteger</body><body package="FitLibrary-SpecFixtures">xPoint: aNoParsePoint	&lt;fitTakes: #NoParsePoint&gt;	&lt;fitReturns: #Integer&gt;	^aNoParsePoint x</body><body package="FitLibrary-SpecFixtures">yPoint: aNoParsePoint	&lt;fitTakes: #NoParsePoint&gt;	&lt;fitReturns: #Integer&gt;	^aNoParsePoint y</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadPayerFromInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Count</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count	&lt;fitReturns: #Integer&gt;	^count</body></methods><methods><class-id>Fitlibrary.Specify.AggregateDoFixture</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">add: anOrderedCollection andGives: aNoParsePoint	&lt;fitTakes: #(#OrderedCollection #NoParsePoint)&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection collect: [:each | each plus: aNoParsePoint]</body><body package="FitLibrary-SpecFixtures">set: noParsePoint1 andGives: noParsePoint2	&lt;fitTakes: #(#NoParsePoint #NoParsePoint)&gt;	&lt;fitReturns: #{Core.Set}&gt;	^Core.Set with: noParsePoint1 with: noParsePoint2</body><body package="FitLibrary-SpecFixtures">sum: noParsePoint1 andGives: noParsePoint2	&lt;fitTakes: #(#NoParsePoint #NoParsePoint)&gt;	&lt;fitReturns: #NoParsePoint&gt;	^noParsePoint1 plus: noParsePoint2</body><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #NoParsePoint&gt;	^NoParsePoint x: xInteger y: yInteger</body></methods><methods><class-id>Fit.Specify.ActionFixtureUnderTest</class-id> <category>operations</category><body package="FitLibrary-SpecFixtures">booleanFalse	&lt;fitReturns: #Boolean&gt;	^false</body><body package="FitLibrary-SpecFixtures">booleanTrue	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">checkThrows	&lt;fitReturns: #Object&gt;	Error raise</body><body package="FitLibrary-SpecFixtures">enterResult: aNumber	&lt;fitTakes: #Integer&gt;	result := aNumber</body><body package="FitLibrary-SpecFixtures">enterString: aString	&lt;fitTakes: #String&gt;</body><body package="FitLibrary-SpecFixtures">enterThrows: aString	&lt;fitTakes: #String&gt;	Error raise</body><body package="FitLibrary-SpecFixtures">intResultMethod	&lt;fitReturns: #Integer&gt;	^result</body><body package="FitLibrary-SpecFixtures">pressMethod	&lt;fitReturns: #Object&gt;</body><body package="FitLibrary-SpecFixtures">pressMethodReturningInt	&lt;fitReturns: #Integer&gt;	^123</body><body package="FitLibrary-SpecFixtures">switchActor	&lt;fitReturns: #Object&gt;	ActionFixture actor: (Fitlibrary.Specify.AnotherActor new test: self)</body></methods><methods><class-id>Fitlibrary.Specify.Global.OnErrorHandler</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">exceptions	&lt;fitReturns: #Boolean&gt;	^FitLibraryException raiseErrorString: 'error'</body><body package="FitLibrary-SpecFixtures">fails	&lt;fitReturns: #Boolean&gt;	^false</body><body package="FitLibrary-SpecFixtures">listener	&lt;fitReturns: #OnErrorHandler&gt;	^ExplicitSelf for: self</body></methods><methods><class-id>Fitlibrary.Specify.EntityElement</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">actions	&lt;fitReturns: #(#ActionEntity)&gt;	^Array with: (ActionEntity type: type) with: (ActionEntity type: type)</body><body package="FitLibrary-SpecFixtures">id	&lt;fitReturns: #Integer&gt;	^1</body><body package="FitLibrary-SpecFixtures">sub	&lt;fitReturns: #EntitySubElement&gt;	^entitySubElement</body></methods><methods><class-id>Fitlibrary.Specify.PointHolder</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">point	&lt;fitReturns: #UnparsedPoint&gt;	^UnparsedPoint x: 24 y: 7</body></methods><methods><class-id>Fitlibrary.Specify.AB</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a	&lt;fitReturns: #Integer&gt;	^a</body><body package="FitLibrary-SpecFixtures">b	&lt;fitReturns: #Integer&gt;	^b</body></methods><methods><class-id>FitlibraryGeneric.Specify.MyPoint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">x: anInteger	&lt;fitTakes: #Integer&gt;	x := anInteger</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body><body package="FitLibrary-SpecFixtures">y: anInteger	&lt;fitTakes: #Integer&gt;	y := anInteger</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.NullGenericCollections</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aList	&lt;fitReturns: #(#OrderedCollection #Colour)&gt;	^nil</body><body package="FitLibrary-SpecFixtures">aListOfLists	&lt;fitReturns: #(#OrderedCollection #(#OrderedCollection #Colour))&gt;	^nil</body><body package="FitLibrary-SpecFixtures">aMap	&lt;fitReturns: #(#Dictionary #Colour #Colour)&gt;	^nil</body><body package="FitLibrary-SpecFixtures">aSet	&lt;fitReturns: #(#Set #Colour)&gt;	^nil</body><body package="FitLibrary-SpecFixtures">aSetOfSets	&lt;fitReturns: #(#Set #(#Set #Colour))&gt;	^nil</body><body package="FitLibrary-SpecFixtures">anArray	&lt;fitReturns: #(#Colour)&gt;	^nil</body></methods><methods><class-id>Fitlibrary.Specify.DynamicVariable.DynamicVariablesUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">get: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^aString</body></methods><methods><class-id>Fit.Specify.ColumnFixtureUnderTestWithArgs</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">third: aNumber	&lt;fitTakes: #Number&gt;	third := aNumber</body></methods><methods><class-id>Fit.Specify.ColumnFixtureUnderTestWithArgs</class-id> <category>operations</category><body package="FitLibrary-SpecFixtures">sum	&lt;fitReturns: #Number&gt;	^(Number fitParse: self arguments first)		+ (Number fitParse: (self arguments at: 2)) + third</body></methods><methods><class-id>Fitlibrary.Specify.Select.SecondSelect</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count	&lt;fitReturns: #Integer&gt;	^2</body></methods><methods><class-id>FitlibraryGeneric.Specify.DomainFixtureUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">concreteClassOfInterfaceType: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Class&gt;	^aString = 'concrete one' ifTrue: [ConcreteClassOne] ifFalse: [nil]</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyValueHolder2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #MyValue2&gt;	^value</body></methods><methods><class-id>Fitlibrary.Specify.DoTree</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">it	&lt;fitReturns: #TeeTree&gt;	^TeeTree onTree: self tree</body><body package="FitLibrary-SpecFixtures">teeTree: aTeeTree	&lt;fitTakes: #TeeTree&gt;	&lt;fitReturns: #TeeTree&gt;	^aTeeTree</body><body package="FitLibrary-SpecFixtures">tree	&lt;fitReturns: #ListTree&gt;	^(ListTree title: '')		addChild: (ListTree title: 'a');		addChild: (ListTree title: 'BB');		yourself</body><body package="FitLibrary-SpecFixtures">tree: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #ListTree&gt;	^ListTree fitParse: aString</body></methods><methods><class-id>Fitlibrary.Specify.Sut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	ab add: (AB a: aInteger b: bInteger)</body><body package="FitLibrary-SpecFixtures">ab	&lt;fitReturns: #OrderedCollection&gt;	^ab</body><body package="FitLibrary-SpecFixtures">callInSut: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUpTearDownNotCalledOnSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">passSutOn	&lt;fitReturns: #Fixture&gt;	^DoFixture systemUnderTest: self</body><body package="FitLibrary-SpecFixtures">setUps	&lt;fitReturns: #Integer&gt;	^setUps</body><body package="FitLibrary-SpecFixtures">something	&lt;fitReturns: #Object&gt;</body><body package="FitLibrary-SpecFixtures">tearDowns	&lt;fitReturns: #Integer&gt;	^tearDowns</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByFinder</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">charge: aUser with: aDouble	&lt;fitTakes: #(#EmptyUser #Double)&gt;</body><body package="FitLibrary-SpecFixtures">findEmptyUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #EmptyUser&gt;	ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.Domain.PrimitiveActions</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">anInt	&lt;fitReturns: #Integer&gt;	^anInt</body><body package="FitLibrary-SpecFixtures">anInt: anInteger	&lt;fitTakes: #Integer&gt;	anInt := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Domain.PrimitiveActions</class-id> <category>actions</category><body package="FitLibrary-SpecFixtures">doubleIt	&lt;fitReturns: #Integer&gt;	anInt := anInt + anInt.	^anInt</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Department</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">users	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: User new</body></methods><methods><class-id>Fitlibrary.Specify.MapFixture</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">camelFreeMap	&lt;fitReturns: #{Core.Set}&gt;	^Core.Set		with: (self makeMapPlus: 1 ampersand: 'one')		with: (self makeMapPlus: 1 ampersand: 'two')		with: (self makeMapPlus: 2 ampersand: 'two')</body><body package="FitLibrary-SpecFixtures">map	&lt;fitReturns: #Fixture&gt;	| map |	map := (Dictionary new)				at: 'a' put: 'b';				at: 'c' put: 'd';				yourself.	^SetFixture actuals: map</body><body package="FitLibrary-SpecFixtures">subsetMap	&lt;fitReturns: #Fixture&gt;	| map |	map := (Dictionary new)				at: 'a' put: 'b';				at: 'c' put: 'd';				yourself.	^SubsetFixture actuals: map</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.TemporaryFixturing</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">permanentlyInScope	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.Domain.MissingClassFactoryMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">abstractUser: anAbstractUser	&lt;fitTakes: #AbstractUser&gt;</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedParse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #Value3&gt;	^Value3 new</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.NonGenericCollections</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aList	&lt;fitReturns: #OrderedCollection&gt;	^aList</body><body package="FitLibrary-SpecFixtures">aList: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	aList := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">aMap	&lt;fitReturns: #Dictionary&gt;	^aMap</body><body package="FitLibrary-SpecFixtures">aMap: aDictionary	&lt;fitTakes: #Dictionary&gt;	aMap := aDictionary</body><body package="FitLibrary-SpecFixtures">aSet	&lt;fitReturns: #Set&gt;	^aSet</body><body package="FitLibrary-SpecFixtures">aSet: newSet	&lt;fitTakes: #Set&gt;	aSet := newSet</body><body package="FitLibrary-SpecFixtures">colour: aColour	&lt;fitTakes: #Colour&gt;	&lt;fitReturns: #Colour&gt;	^aColour</body></methods><methods><class-id>Fitlibrary.Specify.Utility.CamelCase</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">identifierName: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^runtimeContext extendedCamel: aString hideJavaKeywordsToo: true</body></methods><methods><class-id>Fitlibrary.Specify.Author</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">address	&lt;fitReturns: #Address&gt;	^address</body><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">phones	&lt;fitReturns: #{Core.Set}&gt;	^phones</body></methods><methods><class-id>FitlibraryGeneric.Specify.ConcreteClassOne</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count	&lt;fitReturns: #Integer&gt;	^count</body><body package="FitLibrary-SpecFixtures">count: anInteger	&lt;fitTakes: #Integer&gt;	count := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SpecialsAndSequence</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">and: aString _: bString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #String&gt;	^aString , bString</body><body package="FitLibrary-SpecFixtures">badNumberException: aInteger _: bString	&lt;fitTakes: #(#Integer #String)&gt;	&lt;fitReturns: #Error&gt;	^BadNumberException raise</body><body package="FitLibrary-SpecFixtures">fitLibraryException: aString _: bString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #Error&gt;	^FitLibraryException raiseErrorString: aString</body><body package="FitLibrary-SpecFixtures">fitLibraryShowException: aString _: bString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #Error&gt;	^(FitLibraryShowException show: (Show htmlString: aString)) raise</body><body package="FitLibrary-SpecFixtures">or: aBoolean _: bBoolean	&lt;fitTakes: #(#Boolean #Boolean)&gt;	&lt;fitReturns: #Boolean&gt;	^aBoolean or: [bBoolean]</body><body package="FitLibrary-SpecFixtures">plus: aInteger _: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger</body><body package="FitLibrary-SpecFixtures">runtimeException: aString _: bString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #Error&gt;	^Error raise</body></methods><methods><class-id>Fitlibrary.Specify.Exception.User</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">boss	&lt;fitReturns: #User&gt;	^User new</body><body package="FitLibrary-SpecFixtures">boss: aUser	&lt;fitTakes: #User&gt;</body><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	ForcedException raise</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.ChainedSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">callInSutSut: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">sumX: xInteger y: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^xInteger + yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Suite.MyOtherDoTraverse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">actionOnThat	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.Parser.UseToStringForChecking</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">useToString	&lt;fitReturns: #Object&gt;	^ClassWithNoTypeAdapter new</body></methods><methods><class-id>Fitlibrary.Specify.ArrayParser.Parse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">givenInts2D: anArray	&lt;fitTakes: #(#(#( #Integer )))&gt;	&lt;fitReturns: #(#( #Integer ))&gt;	^anArray</body><body package="FitLibrary-SpecFixtures">givenInts: anArray	&lt;fitTakes: #(#( #Integer ))&gt;	&lt;fitReturns: #( #Integer )&gt;	^anArray</body><body package="FitLibrary-SpecFixtures">givenStrings: anArray	&lt;fitTakes: #(#( #String ))&gt;	&lt;fitReturns: #( #String )&gt;	^anArray</body></methods><methods><class-id>Fitlibrary.Specify.DynamicVariable.Xml</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">someXml	&lt;fitReturns: #String&gt;	^'&lt;a&gt;A&lt;/a&gt;'</body></methods><methods><class-id>Fitlibrary.Specify.SucceedConstraint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Boolean&gt;	^aInteger &lt; bInteger</body><body package="FitLibrary-SpecFixtures">b: bInteger c: cInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^bInteger &lt; cInteger</body></methods><methods><class-id>Fitlibrary.Specify.SetParser.Parse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Count&gt;	^Count count: anInteger</body><body package="FitLibrary-SpecFixtures">givenColourSet: aSet	&lt;fitTakes: #Set&gt;	&lt;fitReturns: #Set&gt;	^aSet</body><body package="FitLibrary-SpecFixtures">givenSet: aSet	&lt;fitTakes: #Set&gt;	&lt;fitReturns: #Set&gt;	^aSet</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.ExceptionInObjectFactoryMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">badMethod: anInteger _: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	^ForcedException raise</body><body package="FitLibrary-SpecFixtures">create	&lt;fitReturns: #CollectionSetUpTraverse&gt;	^CollectionSetUpTraverse new</body></methods><methods><class-id>Fitlibrary.Specify.Access.CurrentRow</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">actionThatAddsAShowCell	&lt;fitReturns: #Object&gt;	runtime currentRow addShow: 'hello'</body><body package="FitLibrary-SpecFixtures">actionThatFailsCell: aZeroBasedIndex	&lt;fitTakes: #Integer&gt;	(runtime cellAt: aZeroBasedIndex + 1) fail</body><body package="FitLibrary-SpecFixtures">actionThatFailsCell: aZeroBasedIndex withActual: aString	&lt;fitTakes: #(#Integer #String)&gt;	(runtime cellAt: aZeroBasedIndex + 1) failWithMessage: aString</body><body package="FitLibrary-SpecFixtures">actionThatPassesCell: aZeroBasedIndex	&lt;fitTakes: #Integer&gt;	(runtime cellAt: aZeroBasedIndex + 1) pass</body><body package="FitLibrary-SpecFixtures">actionWithErrorInCell: aZeroBasedIndex withMessage: aString	&lt;fitTakes: #(#Integer #String)&gt;	(runtime cellAt: aZeroBasedIndex + 1) errorMessage: aString</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureSetUp</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">resultA: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Integer&gt;	^isSetUp ifTrue: [anInteger + 1] ifFalse: [0]</body></methods><methods><class-id>Fitlibrary.Specify.MapTraverse.Empty</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">emptyMap	&lt;fitReturns: #Dictionary&gt;	^Dictionary new</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SelectWrap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aLessThan: a b: b	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Boolean&gt;	^a &lt; b</body><body package="FitLibrary-SpecFixtures">plusA: a b: b	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^a + b</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.PropertyAccess</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">getIntPropertyWith3	&lt;fitReturns: #Integer&gt;	^3</body><body package="FitLibrary-SpecFixtures">isTrueProperty	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Sets</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aSetOfColours	&lt;fitReturns: #Set&gt;	^aSetOfColours</body><body package="FitLibrary-SpecFixtures">aSetOfColours: aSet	&lt;fitTakes: #Set&gt;	aSetOfColours := aSet</body><body package="FitLibrary-SpecFixtures">colour: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Colour&gt;	^Colour colour: aString</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.OnFailureWithResult</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">end	&lt;fitReturns: #Object&gt;</body><body package="FitLibrary-SpecFixtures">result	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.SpecialisedTables.UseTables</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">returnTables: aTables	&lt;fitTakes: #Tables&gt;	&lt;fitReturns: #Tables&gt;	aTables first first first pass: TestResults new.	^aTables</body><body package="FitLibrary-SpecFixtures">useTables: aTables	&lt;fitTakes: #Tables&gt;	&lt;fitReturns: #Boolean&gt;	aTables first first first pass: TestResults new.	^true</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Array</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a2DArray	&lt;fitReturns: #(#(#Integer))&gt;	^a2DArray</body><body package="FitLibrary-SpecFixtures">a2DArray: anArray	&lt;fitTakes: #(#(#( #Integer )))&gt;	a2DArray := anArray</body><body package="FitLibrary-SpecFixtures">aColourArray	&lt;fitReturns: #(#Colour)&gt;	^aColourArray</body><body package="FitLibrary-SpecFixtures">aColourArray: anArray	&lt;fitTakes: #(#( #Colour ))&gt;	aColourArray := anArray</body><body package="FitLibrary-SpecFixtures">anIntArray	&lt;fitReturns: #(#Integer)&gt;	^anIntArray</body><body package="FitLibrary-SpecFixtures">anIntArray: anArray	&lt;fitTakes: #(#( #Integer ))&gt;	anIntArray := anArray</body><body package="FitLibrary-SpecFixtures">colour: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Colour&gt;	^Colour colour: aString</body></methods><methods><class-id>Fitlibrary.Specify.Global.ExtraGlobal</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">newGlobalAction	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.MapParser.Match</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">mapEmpty	&lt;fitReturns: #Dictionary&gt;	^Dictionary new</body><body package="FitLibrary-SpecFixtures">mapOf123	&lt;fitReturns: #Dictionary&gt;	^Dictionary		with: 1 -&gt; 2		with: 2 -&gt; 3		with: 3 -&gt; 4</body><body package="FitLibrary-SpecFixtures">mapOfStringAbc	&lt;fitReturns: #Dictionary&gt;	^Dictionary		with: 'a' -&gt; 'b'		with: 'b' -&gt; 'c'		with: 'c' -&gt; 'a'</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Primitives</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aBoolean	&lt;fitReturns: #Boolean&gt;	^aBoolean</body><body package="FitLibrary-SpecFixtures">aBoolean: booleanValue	&lt;fitTakes: #Boolean&gt;	aBoolean := booleanValue</body><body package="FitLibrary-SpecFixtures">aDouble	&lt;fitReturns: #Double&gt;	^aDouble</body><body package="FitLibrary-SpecFixtures">aDouble: doubleValue	&lt;fitTakes: #Double&gt;	aDouble := doubleValue</body><body package="FitLibrary-SpecFixtures">aString	&lt;fitReturns: #String&gt;	^aString</body><body package="FitLibrary-SpecFixtures">aString: stringValue	&lt;fitTakes: #String&gt;	aString := stringValue</body><body package="FitLibrary-SpecFixtures">anInt	&lt;fitReturns: #Integer&gt;	^anInt</body><body package="FitLibrary-SpecFixtures">anInt: integerValue	&lt;fitTakes: #Integer&gt;	anInt := integerValue</body></methods><methods><class-id>Fitlibrary.Specify.ActionEntity</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^'First'</body><body package="FitLibrary-SpecFixtures">type	&lt;fitReturns: #Entity&gt;	^type</body></methods><methods><class-id>Fitlibrary.Specify.Eg.FitLibraryFixedPoint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body></methods><methods><class-id>Fitlibrary.Specify.SpecialAction.SpecialActions</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aFalseAction	&lt;fitReturns: #Boolean&gt;	^false</body><body package="FitLibrary-SpecFixtures">aStringWithWhiteSpace	&lt;fitReturns: #String&gt;	| lf |	lf := String with: Character lf.	^'&lt;t&gt;line one&lt;1s&gt;&lt;t&gt;line&lt;t&gt;2' expandMacrosWith: lf</body><body package="FitLibrary-SpecFixtures">aTrueAction	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">anErrorAction	&lt;fitReturns: #Error&gt;	FitLibraryException raiseErrorString: 'whoops'</body><body package="FitLibrary-SpecFixtures">html	&lt;fitReturns: #String&gt;	^'&lt;ul&gt;&lt;li&gt;ita&lt;li&gt;lics&lt;/ul&gt;'</body><body package="FitLibrary-SpecFixtures">intProperty	&lt;fitReturns: #Integer&gt;	^2</body><body package="FitLibrary-SpecFixtures">ten	&lt;fitReturns: #Integer&gt;	^10</body></methods><methods><class-id>Fit.Specify.SelfStarter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">s	&lt;fitReturns: #String&gt;	^s</body></methods><methods><class-id>Fit.Specify.SelfStarter</class-id> <category>operations</category><body package="FitLibrary-SpecFixtures">enterString: aString	&lt;fitTakes: #String&gt;	s := aString</body></methods><methods><class-id>Fitlibrary.Specify.TimesCombinationSetUp</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">combine	&lt;fitReturns: #Fixture&gt;	^Combine new</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureTearDown</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">resultA: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Integer&gt;	self error: 'ex' , anInteger printString</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSetUp</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aFixture	&lt;fitReturns: #DoTraverse&gt;	| sut |	sut := SimpleSetUpSut count: count owner: self.	count := count + 1.	^DoTraverse systemUnderTest: sut</body><body package="FitLibrary-SpecFixtures">setUpCount	&lt;fitReturns: #Integer&gt;	^setUpCount</body><body package="FitLibrary-SpecFixtures">suiteSetUpCount	&lt;fitReturns: #Integer&gt;	^suiteSetUpCount</body><body package="FitLibrary-SpecFixtures">suiteTearDownCount	&lt;fitReturns: #Integer&gt;	^suiteTearDownCount</body><body package="FitLibrary-SpecFixtures">tearDownCount	&lt;fitReturns: #Integer&gt;	^tearDownCount</body><body package="FitLibrary-SpecFixtures">totalLocalSetUps	&lt;fitReturns: #Integer&gt;	^totalLocalSetUps</body><body package="FitLibrary-SpecFixtures">totalLocalTearDowns	&lt;fitReturns: #Integer&gt;	^totalLocalTearDowns</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.DoSeqAmbiguity</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">add: aInteger _: bInteger _: cInteger	&lt;fitTakes: #(#Integer #Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger + cInteger</body><body package="FitLibrary-SpecFixtures">add: aInteger to: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger</body></methods><methods><class-id>Fitlibrary.Specify.ScientificDoublePair</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">one	&lt;fitReturns: #ScientificDouble&gt;	^one</body><body package="FitLibrary-SpecFixtures">two	&lt;fitReturns: #ScientificDouble&gt;	^two</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.OtherFixturing</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">other: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #OtherFixturing&gt;	^self class value: anInteger</body><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #Integer&gt;	^value</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByAction</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">thrown: anInteger	&lt;fitTakes: #Integer&gt;	^ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Colour</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">colour	&lt;fitReturns: #String&gt;	^colour</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Colour</class-id> <category>initialize-release</category><body package="FitLibrary-SpecFixtures">setColour: aString	&lt;fitTakes: #String&gt;	colour := aString</body></methods><methods><class-id>Fitlibrary.Specify.Domain.UserWithManager</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">manager	&lt;fitReturns: #UserWithManager&gt;	^manager</body><body package="FitLibrary-SpecFixtures">manager: aUserWithManager	&lt;fitTakes: #UserWithManager&gt;	manager := aUserWithManager</body><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.FailConstraint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">b: bInteger a: aInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Boolean&gt;	^aInteger &lt; bInteger</body></methods><methods><class-id>Fitlibrary.Specify.GraphicElement</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">i	&lt;fitReturns: #Integer&gt;	^i</body><body package="FitLibrary-SpecFixtures">tree	&lt;fitReturns: #ListTree&gt;	^tree</body></methods><methods><class-id>Fitlibrary.Specify.Domain.PrivateUserFromInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.DefinedActionUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aVoid	&lt;fitReturns: #Void&gt;</body><body package="FitLibrary-SpecFixtures">birds: anAb	&lt;fitTakes: #Ab&gt;	&lt;fitReturns: #Boolean&gt;	^anAb a = 1</body><body package="FitLibrary-SpecFixtures">count	&lt;fitReturns: #Integer&gt;	^22</body><body package="FitLibrary-SpecFixtures">object	&lt;fitReturns: #Ab&gt;	^Ab new</body><body package="FitLibrary-SpecFixtures">submit: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">with: locationString enterText: aString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #Boolean&gt;	(locationString findString: 'password' startingAt: 1) isZero		ifTrue: [^true].	^aString isEmpty</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.TextPassed</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">hasTags: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^aString = '&lt;a&gt;A&lt;b/&gt;&lt;/a&gt;'</body><body package="FitLibrary-SpecFixtures">isSeveralLines: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^aString = ('abc&lt;1s&gt;def' expandMacrosWith: (String with: Character lf))</body><body package="FitLibrary-SpecFixtures">isSeveralLinesWithNewlines: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^aString		= ('&lt;1s&gt;abc&lt;1s&gt;def&lt;1s&gt;' expandMacrosWith: (String with: Character lf))</body><body package="FitLibrary-SpecFixtures">isSeveralLinesWithoutNewline: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^aString = 'abcdef'</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.ResultingObjectIsSubType</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">interfaceColour: aColour	&lt;fitTakes: #Colour&gt;	&lt;fitReturns: #Comparable&gt;	^aColour</body><body package="FitLibrary-SpecFixtures">superclassColour: aColour	&lt;fitTakes: #Colour&gt;	&lt;fitReturns: #Object&gt;	^aColour</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.MissingObjectFactoryMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">missing	&lt;fitReturns: #CollectionSetUpTraverse&gt;	^CollectionSetUpTraverse new</body></methods><methods><class-id>Fitlibrary.Specify.DoWithTags</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">tagText: aTaggedString	&lt;fitTakes: #TaggedString&gt;	&lt;fitReturns: #TaggedString&gt;	^aTaggedString</body><body package="FitLibrary-SpecFixtures">taggedText	&lt;fitReturns: #TaggedString&gt;	^TaggedString string: '&lt;b&gt;bold&lt;/b&gt;'</body></methods><methods><class-id>Fitlibrary.Specify.Domain.SuperPrivateMethods</class-id> <category>private</category><body package="FitLibrary-SpecFixtures">privatePropInSuper	&lt;fitReturns: #Integer&gt;	^privatePropinSuper</body><body package="FitLibrary-SpecFixtures">privatePropInSuper: anInteger	&lt;fitTakes: #Integer&gt;	privatePropinSuper := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Domain.PrivatePropertyMethods</class-id> <category>private</category><body package="FitLibrary-SpecFixtures">privateProp	&lt;fitReturns: #Integer&gt;	^privateProp</body><body package="FitLibrary-SpecFixtures">privateProp: anInteger	&lt;fitTakes: #Integer&gt;	privateProp := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Select.FirstSelect</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">count	&lt;fitReturns: #Integer&gt;	^1</body><body package="FitLibrary-SpecFixtures">second	&lt;fitReturns: #SecondSelect&gt;	^SecondSelect new</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureUnderTest3</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">calc	&lt;fitReturns: #Fixture&gt;	^InnerCalculate3 new</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureFlowUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">anInteger	&lt;fitReturns: #Integer&gt;	^23</body><body package="FitLibrary-SpecFixtures">copyAPoint: aMyPoint	&lt;fitTakes: #MyPoint&gt;	&lt;fitReturns: #MyPoint&gt;	^aMyPoint</body><body package="FitLibrary-SpecFixtures">copyOfListOfEntity: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection</body><body package="FitLibrary-SpecFixtures">entity: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Entity&gt;	^Entity string: aString</body><body package="FitLibrary-SpecFixtures">exception	&lt;fitReturns: #Error&gt;	^self error: 'Forced exception'</body><body package="FitLibrary-SpecFixtures">findEntity: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Entity&gt;	^self entity: aString</body><body package="FitLibrary-SpecFixtures">get: row slice: column	&lt;fitTakes: #(#Number #Number)&gt;	&lt;fitReturns: #Fixture&gt;	^LocalRowFixture row: row + 1 column: column + 1</body><body package="FitLibrary-SpecFixtures">hiddenMethod	&lt;fitReturns: #Object&gt;</body><body package="FitLibrary-SpecFixtures">pointHolder	&lt;fitReturns: #PointHolder&gt;	^PointHolder new</body><body package="FitLibrary-SpecFixtures">showEntity: anEntity	&lt;fitTakes: #Entity&gt;	&lt;fitReturns: #String&gt;	^anEntity fitToString</body><body package="FitLibrary-SpecFixtures">x: xInteger y: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #MyPoint&gt;	^MyPoint x: xInteger y: yInteger</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureFlowUnderTest</class-id> <category>special actions</category><body package="FitLibrary-SpecFixtures">specialAction: aRow resultsInto: aTestResults	&lt;fitTakes: #(#Row #TestResults)&gt;	| cell text |	cell := aRow at: 2.	text := cell resolvedText: self.	text = 'right'		ifTrue: [cell pass: aTestResults]		ifFalse: [text = 'wrong' ifTrue: [cell fail: aTestResults]]</body></methods><methods><class-id>Fitlibrary.Specify.InnerCalculate2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">exceptionMethod	&lt;fitReturns: #Error&gt;	^self error: 'Expected exception'</body><body package="FitLibrary-SpecFixtures">plusA: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger</body></methods><methods><class-id>Fitlibrary.Specify.Address</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">address1	&lt;fitReturns: #String&gt;	^address1</body><body package="FitLibrary-SpecFixtures">address1: aString	&lt;fitTakes: #String&gt;	address1 := aString</body><body package="FitLibrary-SpecFixtures">address2	&lt;fitReturns: #String&gt;	^address2</body><body package="FitLibrary-SpecFixtures">address2: aString	&lt;fitTakes: #String&gt;	address2 := aString</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Employee</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">department: aDepartment	&lt;fitTakes: #Department&gt;	department := aDepartment</body><body package="FitLibrary-SpecFixtures">manager: aManager	&lt;fitTakes: #Manager&gt;	manager := aManager</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ClassWithParseMethod2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">myClass	&lt;fitReturns: #MyClass&gt;	^MyClass i: 3</body><body package="FitLibrary-SpecFixtures">myClass: aMyClass plus: bMyClass	&lt;fitTakes: #(#MyClass #MyClass)&gt;	&lt;fitReturns: #MyClass&gt;	^aMyClass plus: bMyClass</body><body package="FitLibrary-SpecFixtures">sameMyClass: aMyClass	&lt;fitTakes: #MyClass&gt;	&lt;fitReturns: #MyClass&gt;	^aMyClass</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.LocalCalculateFixture</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">cA: aInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^aInteger + bInteger</body></methods><methods><class-id>Fitlibrary.Specify.Parser.MyPoint2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">x: anInteger	&lt;fitTakes: #Integer&gt;	x := anInteger</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body><body package="FitLibrary-SpecFixtures">y: anInteger	&lt;fitTakes: #Integer&gt;	y := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Publisher</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.EntityInNestedArray</class-id> <category>finding</category><body package="FitLibrary-SpecFixtures">findEntity: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Entity&gt;	^aString = 'first' ifTrue: [first] ifFalse: [second]</body></methods><methods><class-id>Fitlibrary.Specify.EntityInNestedArray</class-id> <category>showing</category><body package="FitLibrary-SpecFixtures">showEntity: anEntity	&lt;fitTakes: #Entity&gt;	&lt;fitReturns: #String&gt;	^anEntity fitToString</body></methods><methods><class-id>Fitlibrary.Specify.Eg.UnparsedPoint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body></methods><methods><class-id>Fitlibrary.Specify.Set.AccessPrivateFields</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aSet	&lt;fitReturns: #Set&gt;	^Set with: (Fields field1: 3 field2: 4) with: (Fields field1: 1 field2: 2)</body></methods><methods><class-id>Fitlibrary.Specify.Eg.Rectangle</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">setLocation: xInteger _: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	x := xInteger.	y := yInteger</body><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadConstructorsInNestedObjects</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">employee: anEmployee	&lt;fitTakes: #Employee&gt;	employee := anEmployee</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByParse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #Value&gt;	^Value new</body></methods><methods><class-id>Fitlibrary.Specify.DomainAdapterUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">call: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">create	&lt;fitReturns: #SetUpFixture&gt;	^SetUpFixture systemUnderTest: self</body><body package="FitLibrary-SpecFixtures">productA: anInteger b: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^anInteger * bInteger</body></methods><methods><class-id>Fitlibrary.Specify.MapParser.Parse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">givenMap: aDictionary	&lt;fitTakes: #Dictionary&gt;	&lt;fitReturns: #Dictionary&gt;	^aDictionary</body></methods><methods><class-id>Fitlibrary.Specify.Some</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">some	&lt;fitReturns: #String&gt;	^'one'</body></methods><methods><class-id>Fitlibrary.Specify.Plugin.HasNewInstancePlugin</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">crash: aCrash	&lt;fitTakes: #Crash&gt;</body><body package="FitLibrary-SpecFixtures">dog: aDog	&lt;fitTakes: #Dog&gt;</body><body package="FitLibrary-SpecFixtures">newInstancePlugin: aClass	&lt;fitTakes: #Class&gt;	&lt;fitReturns: #Person&gt;	aClass == Person ifTrue: [^ConcretePerson new].	aClass == Crash ifTrue: [^self error: 'bang'].	^nil</body><body package="FitLibrary-SpecFixtures">person	&lt;fitReturns: #Person&gt;	^person</body><body package="FitLibrary-SpecFixtures">person: aPerson	&lt;fitTakes: #Person&gt;	person := aPerson</body><body package="FitLibrary-SpecFixtures">personList	&lt;fitReturns: #(#OrderedCollection #Person)&gt;	^personList</body><body package="FitLibrary-SpecFixtures">personList: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection   #Person ))&gt;	personList := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">persons	&lt;fitReturns: #(#Person)&gt;	^persons</body><body package="FitLibrary-SpecFixtures">persons: anArray	&lt;fitTakes: #(#( #Person ))&gt;	persons := anArray</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Maps</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aColourMap	&lt;fitReturns: #Dictionary&gt;	^aColourMap</body><body package="FitLibrary-SpecFixtures">aStringMap	&lt;fitReturns: #Dictionary&gt;	^aStringMap</body><body package="FitLibrary-SpecFixtures">aStringMap: aDictionary	&lt;fitTakes: #Dictionary&gt;	aStringMap := aDictionary</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpList</class-id> <category>setup</category><body package="FitLibrary-SpecFixtures">name: aString owe: aDouble	&lt;fitTakes: #(#String #Double)&gt;	&lt;fitReturns: #User&gt;	^User named: aString owing: aDouble</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpList</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">iOUs	&lt;fitReturns: #OrderedCollection&gt;	^iOUs</body><body package="FitLibrary-SpecFixtures">iOUs: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	iOUs := anOrderedCollection</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Project2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">add: aProject	&lt;fitTakes: #Project&gt;</body><body package="FitLibrary-SpecFixtures">leader	&lt;fitReturns: #User&gt;	^User new</body><body package="FitLibrary-SpecFixtures">leader: anUser	&lt;fitTakes: #User&gt;</body></methods><methods><class-id>Fitlibrary.Specify.Exception.AmbiguousActionMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">overloaded: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Integer&gt;	^anInteger</body></methods><methods><class-id>FitlibraryGeneric.Specify.PrePopulated</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aListOfAttribute	&lt;fitReturns: #(#OrderedCollection #InterfaceType)&gt;	^aListOfAttribute</body><body package="FitLibrary-SpecFixtures">aListOfAttribute: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection   #InterfaceType ))&gt;	aListOfAttribute := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">aSetOfAttribute	&lt;fitReturns: #(#Set #InterfaceType)&gt;	^aSetOfAttribute</body><body package="FitLibrary-SpecFixtures">aSetOfAttribute: aSet	&lt;fitTakes: #(#( #Set   #InterfaceType ))&gt;	aSetOfAttribute := aSet</body><body package="FitLibrary-SpecFixtures">colour	&lt;fitReturns: #Colour&gt;	^colour</body></methods><methods><class-id>Fitlibrary.Specify.DoCalculateFixtureSetUp</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">calcSetUp	&lt;fitReturns: #Fixture&gt;	^CalculateFixtureSetUp new</body><body package="FitLibrary-SpecFixtures">calculateSetUpWithException	&lt;fitReturns: #Fixture&gt;	^CalculateFixtureSetUpWithException new</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ParserUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">boolValue: aBoolean	&lt;fitTakes: #Boolean&gt;	&lt;fitReturns: #Boolean&gt;	^aBoolean</body><body package="FitLibrary-SpecFixtures">booleanValue: aBoolean	&lt;fitTakes: #Boolean&gt;	&lt;fitReturns: #Boolean&gt;	^aBoolean</body><body package="FitLibrary-SpecFixtures">byte: aByte	&lt;fitTakes: #Byte&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">char: aCharacter	&lt;fitTakes: #Character&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">character: aCharacter	&lt;fitTakes: #Character&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">classByte: aByte	&lt;fitTakes: #Byte&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">className: aClass	&lt;fitTakes: #Class&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">double: aDouble	&lt;fitTakes: #Double&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">float: aFloat	&lt;fitTakes: #Float&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">int: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">invalid	&lt;fitReturns: #ConstraintTraverse&gt;	^ConstraintTraverse systemUnderTest: self expected: false</body><body package="FitLibrary-SpecFixtures">long: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">short: aSmallInteger	&lt;fitTakes: #SmallInteger&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">string: aSmallInteger	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">valid	&lt;fitReturns: #ConstraintTraverse&gt;	^ConstraintTraverse systemUnderTest: self</body></methods><methods><class-id>Fitlibrary.Specify.Suite.VariantOnSimple</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aFixture	&lt;fitReturns: #DoTraverse&gt;	^DoTraverse systemUnderTest: VariantOnSimpleSut new</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUpTearDownOfOther</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">withOtherSetUp	&lt;fitReturns: #SetUp&gt;	^SetUp new</body><body package="FitLibrary-SpecFixtures">withOtherTearDown	&lt;fitReturns: #TearDown&gt;	^TearDown new</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedToString</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">value	&lt;fitReturns: #Value4&gt;	^Value4 new</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ClassDelegate</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aValueSetWithAClassDelegate	&lt;fitReturns: #ArrayFixture&gt;	| values |	values := Array with: (MyValueHolder2 value: (MyValue2 value: 1))				with: (MyValueHolder2 value: (MyValue2 value: 2)).	^ArrayFixture actuals: values</body></methods><methods><class-id>Fitlibrary.Specify.Combine</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">combine: xInteger and: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	isSetUp ifFalse: [^self error: 'Not set up'].	^xInteger * yInteger</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableMethodsThrowExceptionsSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">execute	&lt;fitReturns: #Void&gt;	executeThrowsException		ifTrue: 			[executeThrowsException := false.			^FitLibraryException raiseErrorString: 'execute exception']</body><body package="FitLibrary-SpecFixtures">executeThrowsException: aBoolean	&lt;fitTakes: #Boolean&gt;	executeThrowsException := aBoolean</body><body package="FitLibrary-SpecFixtures">getOut	&lt;fitReturns: #Integer&gt;	outThrowsException		ifTrue: 			[outThrowsException := false.			^FitLibraryException raiseErrorString: 'out exception'].	^in</body><body package="FitLibrary-SpecFixtures">in: anInteger	&lt;fitTakes: #Integer&gt;	inThrowsException		ifTrue: 			[inThrowsException := false.			^FitLibraryException raiseErrorString: 'in exception'].	in := anInteger</body><body package="FitLibrary-SpecFixtures">inThrowsException: aBoolean	&lt;fitTakes: #Boolean&gt;	inThrowsException := aBoolean</body><body package="FitLibrary-SpecFixtures">outThrowsException: aBoolean	&lt;fitTakes: #Boolean&gt;	outThrowsException := aBoolean</body><body package="FitLibrary-SpecFixtures">reset	&lt;fitReturns: #Void&gt;	resetThrowsException		ifTrue: 			[resetThrowsException := false.			^FitLibraryException raiseErrorString: 'reset exception']</body><body package="FitLibrary-SpecFixtures">resetThrowsException: aBoolean	&lt;fitTakes: #Boolean&gt;	resetThrowsException := aBoolean</body></methods><methods><class-id>Fit.Specify.AlienEvaluator</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">fixture	&lt;fitReturns: #Fixture&gt;	^MyColumnFixture new</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.TearDown</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">anException	&lt;fitReturns: #Error&gt;	Error raise</body><body package="FitLibrary-SpecFixtures">someAction	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.EntitySubElement</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">actions	&lt;fitReturns: #(#ActionEntity)&gt;	^actionEntities</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.Person</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body></methods><methods><class-id>Fitlibrary.Specify.GridFixtureUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">empty	&lt;fitReturns: #GridFixture&gt;	^GridFixture grid: #() elementType: Object</body><body package="FitLibrary-SpecFixtures">images	&lt;fitReturns: #GridFixture&gt;	^GridFixture grid: (Array				with: (#('gameImages/wall.jpg' 'gameImages/space.jpg' 'gameImages/box.jpg' 'gameImages/space.jpg' 'gameImages/wall.jpg')						collect: [:each | ImageNameGraphic expectedFilename: each]))		elementType: ImageNameGraphic</body><body package="FitLibrary-SpecFixtures">imagesForImageFixture	&lt;fitReturns: #GridFixture&gt;	^ImageFixture		filenames: #(#('gameImages/wall.jpg' 'gameImages/space.jpg' 'gameImages/box.jpg' 'gameImages/space.jpg' 'gameImages/wall.jpg'))</body><body package="FitLibrary-SpecFixtures">ints	&lt;fitReturns: #GridFixture&gt;	^GridFixture grid: #(#(1 2) #(3 4)) elementType: Integer</body><body package="FitLibrary-SpecFixtures">strings	&lt;fitReturns: #GridFixture&gt;	^GridFixture grid: #(#('a' 'b') #('c' 'd')) elementType: String</body><body package="FitLibrary-SpecFixtures">trees	&lt;fitReturns: #GridFixture&gt;	^GridFixture		grid: (Array with: (Array with: (ListTree fitParse: 'a')						with: (ListTree fitParse: '&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;'))				with: (Array with: (ListTree fitParse: '&lt;ul&gt;&lt;li&gt;BB&lt;/li&gt;&lt;/ul&gt;')						with: (ListTree fitParse: '&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;BB&lt;/li&gt;&lt;/ul&gt;')))		elementType: ListTree</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Value4</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">colour	&lt;fitReturns: #Colour2&gt;	^Colour2 new</body></methods><methods><class-id>Fitlibrary.Specify.MapTraverse.ErrorMap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">errorMap	&lt;fitReturns: #Dictionary&gt;	^(Dictionary new)		at: 'a' put: InError new;		yourself</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedShow</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">findEmptyUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #EmptyUser&gt;	^EmptyUser new</body><body package="FitLibrary-SpecFixtures">project	&lt;fitReturns: #Project&gt;	^Project new</body><body package="FitLibrary-SpecFixtures">showEmptyUser: anEmptyUser	&lt;fitTakes: #EmptyUser&gt;	&lt;fitReturns: #String&gt;	^ForcedException raise</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.RuleTableWithResetAndExecuteSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">execute	&lt;fitReturns: #Void&gt;	executes := executes + 1</body><body package="FitLibrary-SpecFixtures">executes	&lt;fitReturns: #Integer&gt;	^executes</body><body package="FitLibrary-SpecFixtures">expectedExecutes: anInteger	&lt;fitTakes: #Integer&gt;	anInteger = executes		ifFalse: 			[^FitLibraryException raiseErrorString: 'Was: ' , executes printString]</body><body package="FitLibrary-SpecFixtures">expectedResets: anInteger	&lt;fitTakes: #Integer&gt;	anInteger = resets		ifFalse: [^FitLibraryException raiseErrorString: 'Was: ' , resets printString]</body><body package="FitLibrary-SpecFixtures">reset	&lt;fitReturns: #Void&gt;	resets := resets + 1</body><body package="FitLibrary-SpecFixtures">resets	&lt;fitReturns: #Integer&gt;	^resets</body></methods><methods><class-id>Fit.Specify.MockClass</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a	&lt;fitReturns: #Integer&gt;	^a</body><body package="FitLibrary-SpecFixtures">s	&lt;fitReturns: #String&gt;	^s</body></methods><methods><class-id>Fitlibrary.Specify.MockCollection</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">ampersand	&lt;fitReturns: #String&gt;	^ampersand</body><body package="FitLibrary-SpecFixtures">plus	&lt;fitReturns: #Integer&gt;	^plus</body><body package="FitLibrary-SpecFixtures">prop	&lt;fitReturns: #Integer&gt;	^plus</body></methods><methods><class-id>Fitlibrary.Specify.ListParser.Match</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">counts23	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: (Count count: 2) with: (Count count: 3)</body><body package="FitLibrary-SpecFixtures">iterator23	&lt;fitReturns: #OrderedCollection&gt;	^self counts23</body><body package="FitLibrary-SpecFixtures">list123	&lt;fitReturns: #OrderedCollection&gt;	^#(1 2 3) asOrderedCollection</body><body package="FitLibrary-SpecFixtures">listEmpty	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection new</body><body package="FitLibrary-SpecFixtures">stringAbc	&lt;fitReturns: #OrderedCollection&gt;	^#('a' 'b' 'c') asOrderedCollection</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.GenericMaps</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aListOfMaps	&lt;fitReturns: #ListOfMapsTraverse&gt;	| maps |	maps := OrderedCollection new.	maps add: (Dictionary with: 'color' -&gt; Colour red with: 'count' -&gt; 1).	maps add: (Dictionary with: 'color' -&gt; Colour green with: 'count' -&gt; 2).	maps		add: (Dictionary with: 'color' -&gt; Colour yellow with: 'count' -&gt; 'three').	^ListOfMapsTraverse maps: maps</body><body package="FitLibrary-SpecFixtures">aListOfMapsWithEmpty	&lt;fitReturns: #ListOfMapsTraverse&gt;	| maps |	maps := OrderedCollection new.	maps add: (Dictionary with: 'color' -&gt; Colour red with: 'count' -&gt; 1).	maps add: (Dictionary with: 'count' -&gt; 2).	^ListOfMapsTraverse maps: maps</body><body package="FitLibrary-SpecFixtures">aMap	&lt;fitReturns: #(#Dictionary #Colour #Colour)&gt;	^aMap</body><body package="FitLibrary-SpecFixtures">aMap: aDictionary	&lt;fitTakes: #(#( #Dictionary   #Colour   #Colour ))&gt;	aMap := aDictionary</body><body package="FitLibrary-SpecFixtures">aMapOfMaps	&lt;	fitReturns: #(#{Dictionary} #{Colour} #(#{Dictionary} #{Colour} #{Colour}))&gt;	^aMapOfMaps</body><body package="FitLibrary-SpecFixtures">aMapOfMaps: aDictionary	&lt;	fitTakes: #(#(#{Dictionary} #{Colour} #(#{Dictionary} #{Colour} #{Colour})))&gt;	aMapOfMaps := aDictionary</body><body package="FitLibrary-SpecFixtures">aSubsetMap	&lt;fitReturns: #SubsetMapTraverse&gt;	^SubsetMapTraverse map: aMap copy</body></methods><methods><class-id>Fitlibrary.Specify.EntityParser.MissingFinderMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">add: aUser debt: aDouble	&lt;fitTakes: #(#User #Double)&gt;	&lt;fitReturns: #Boolean&gt;	aUser addDebt: aDouble.	^true</body><body package="FitLibrary-SpecFixtures">user: aUser	&lt;fitTakes: #User&gt;	user := aUser</body></methods><methods><class-id>Fitlibrary.Specify.Suite.SimpleSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">andMore	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">andMoreBesides	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">andSomeImmediateAction	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">count	&lt;fitReturns: #Integer&gt;	^count</body></methods><methods><class-id>Fitlibrary.Specify.Set.Fields</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">field1	&lt;fitReturns: #Integer&gt;	^field1</body><body package="FitLibrary-SpecFixtures">field2	&lt;fitReturns: #Integer&gt;	^field2</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByNestedFinder</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">add: subProject toProject: aProject	&lt;fitTakes: #(#Project #Project)&gt;	aProject add: subProject</body><body package="FitLibrary-SpecFixtures">findEmptyUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #EmptyUser&gt;	^ForcedException raise</body><body package="FitLibrary-SpecFixtures">findProject: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Project&gt;	^Project new</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByEquals</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">findUser: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #User&gt;	^User new</body><body package="FitLibrary-SpecFixtures">user	&lt;fitReturns: #User&gt;	^User new</body></methods><methods><class-id>Fitlibrary.Specify.DoTable</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aTable	&lt;fitReturns: #NestedTable&gt;	^NestedTable parse: (Parse				input: '&lt;html&gt;&lt;table border="1" cellspacing="0"&gt;&lt;tr&gt;&lt;td&gt;one&lt;/td&gt;&lt;td&gt;two&lt;/td&gt;&lt;td&gt;three&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/html&gt;')</body><body package="FitLibrary-SpecFixtures">firstCellStringValue: aTable	&lt;fitTakes: #NestedTable&gt;	&lt;fitReturns: #String&gt;	^aTable stringAt: 1 at: 1 at: 1</body><body package="FitLibrary-SpecFixtures">firstCellValue: aTable	&lt;fitTakes: #NestedTable&gt;	&lt;fitReturns: #NestedTable&gt;	^aTable at: 1 at: 1 at: 1</body><body package="FitLibrary-SpecFixtures">nullTable	&lt;fitReturns: #NestedTable&gt;	^nil</body></methods><methods><class-id>Fitlibrary.Specify.WithinFlow</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">withSetUpException	&lt;fitReturns: #Fixture&gt;	^DoFixtureSetUpWithException new</body><body package="FitLibrary-SpecFixtures">withTearDown	&lt;fitReturns: #Fixture&gt;	^DoFixtureTearDown new</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureUnderTest2</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">calc	&lt;fitReturns: #Fixture&gt;	^InnerCalculate2 new</body></methods><methods><class-id>Fitlibrary.Specify.DoFixtureTearDown</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">anException	&lt;fitReturns: #Error&gt;	^self error: 'ex'</body></methods><methods><class-id>Fitlibrary.Specify.Suite.Simple</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aFixture	&lt;fitReturns: #DoTraverse&gt;	| sut |	sut := SimpleSut count: count.	count := count + 1.	^DoTraverse systemUnderTest: sut</body><body package="FitLibrary-SpecFixtures">countIs: anInteger	&lt;fitTakes: #Integer&gt;	count := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.MissingMethod.NestedFinderInJustSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">addToColourMix: aCollection	&lt;fitTakes: #OrderedCollection&gt;</body><body package="FitLibrary-SpecFixtures">colour: aColour quantity: anInteger	&lt;fitTakes: #(#Colour #Integer)&gt;	^Mix colour: aColour quantity: anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.AutoWrap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aListOfPoint	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: (MyPoint x: 0 y: 0) with: (MyPoint x: 5 y: 5)</body><body package="FitLibrary-SpecFixtures">aSetOfPoint	&lt;fitReturns: #Set&gt;	^Set with: (MyPoint x: 0 y: 0) with: (MyPoint x: 5 y: 5)</body><body package="FitLibrary-SpecFixtures">anArrayOfInt	&lt;fitReturns: #(#Integer)&gt;	^(1 to: 3) asArray</body><body package="FitLibrary-SpecFixtures">anArrayOfInteger	&lt;fitReturns: #(#Integer)&gt;	^(1 to: 3) asArray</body><body package="FitLibrary-SpecFixtures">anArrayOfPoint	&lt;fitReturns: #(#Point)&gt;	^Array with: (MyPoint x: 0 y: 0) with: (MyPoint x: 5 y: 5)</body><body package="FitLibrary-SpecFixtures">anIteratorOfPoint	"we don't really have iterators in Smalltalk"	&lt;fitReturns: #OrderedCollection&gt;	^self aListOfPoint</body></methods><methods><class-id>Fitlibrary.Specify.MapTraverse.StringMap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">stringMap	&lt;fitReturns: #Dictionary&gt;	^(Dictionary new)		at: 'a' put: 'b';		at: 'A' put: 'B';		yourself</body></methods><methods><class-id>Fitlibrary.Specify.NoParsePoint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">x: anInteger	&lt;fitTakes: #Integer&gt;	x := anInteger</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body><body package="FitLibrary-SpecFixtures">y: anInteger	&lt;fitTakes: #Integer&gt;	y := anInteger</body></methods><methods><class-id>Fitlibrary.Specify.DynamicVariable.CheckDynamicVariable</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">check: variableString as: valueString	&lt;fitTakes: #(#String #String)&gt;	| expected dynamicVariable |	expected := '&lt;a&gt;&lt;user password="kiwi"&gt;rick&lt;/user&gt;&lt;a&gt;'.	valueString = expected		ifFalse: 			[^FitLibraryException				raiseErrorString: variableString , ' was ' , valueString].	dynamicVariable := runtimeContext dynamicVariableAt: variableString.	dynamicVariable = expected		ifFalse: 			[^FitLibraryException				raiseErrorString: variableString , ' internally was ' , dynamicVariable].	^true</body></methods><methods><class-id>Fitlibrary.Specify.Domain.BadClassFromClassFactoryMethodForInterface</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">abstractUser: anAbstractUserAsInterface	&lt;fitTakes: #AbstractUserAsInterface&gt;</body><body package="FitLibrary-SpecFixtures">concreteClassOfAbstractUserAsInterface: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Class&gt;	aString = 'No Nullary' ifTrue: [^NoNullaryUserFromInterface].	aString = 'Private' ifTrue: [^PrivateUserFromInterface].	aString = 'String' ifTrue: [^String].	^nil</body></methods><methods><class-id>Fitlibrary.Specify.CalculateFixtureSetUpWithException</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">resultA: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Integer&gt;	^anInteger + 1</body></methods><methods><class-id>Fitlibrary.Specify.MissingProperty.InJustSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">colour	&lt;fitReturns: #Colour&gt;	^colour</body><body package="FitLibrary-SpecFixtures">colour: aColour	&lt;fitTakes: #Colour&gt;	colour := aColour</body></methods><methods><class-id>Fitlibrary.Specify.SystemUnderTest</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aListOfPoint	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: (MyPoint x: 0 y: 0) with: (MyPoint x: 5 y: 5)</body><body package="FitLibrary-SpecFixtures">aParseFailure: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">aRightAction: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">aRightBooleanAction: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">aWrongAction: x _: y	&lt;fitTakes: #(#Double #Double)&gt;	&lt;fitReturns: #Boolean&gt;	^false</body><body package="FitLibrary-SpecFixtures">add: aNumber	&lt;fitTakes: #Number&gt;	&lt;fitReturns: #Number&gt;	^sum := sum + aNumber</body><body package="FitLibrary-SpecFixtures">ambiguous: anInteger	&lt;fitTakes: #Integer&gt;</body><body package="FitLibrary-SpecFixtures">ambiguous: aInteger is: bInteger	&lt;fitTakes: #(#Integer #Integer)&gt;</body><body package="FitLibrary-SpecFixtures">anExceptionAction	&lt;fitReturns: #Error&gt;	^self error: 'testing'</body><body package="FitLibrary-SpecFixtures">anotherObject	&lt;fitReturns: #Fixture&gt;	^DoFixture systemUnderTest: A new</body><body package="FitLibrary-SpecFixtures">appends	&lt;fitReturns: #String&gt;	^concat</body><body package="FitLibrary-SpecFixtures">booleanProperty	&lt;fitReturns: #Boolean&gt;	^true</body><body package="FitLibrary-SpecFixtures">copyOfListOfPoint: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection</body><body package="FitLibrary-SpecFixtures">hiddenMethod	&lt;fitReturns: #Error&gt;	FitLibraryException raiseErrorString: 'testing'</body><body package="FitLibrary-SpecFixtures">intProperty	&lt;fitReturns: #Integer&gt;	^2</body><body package="FitLibrary-SpecFixtures">plus	&lt;fitReturns: #Number&gt;	^self sum</body><body package="FitLibrary-SpecFixtures">sameDate: aTimestamp	&lt;fitTakes: #Timestamp&gt;	&lt;fitReturns: #Timestamp&gt;	^aTimestamp</body><body package="FitLibrary-SpecFixtures">stringProperty	&lt;fitReturns: #String&gt;	^'apple pie'</body><body package="FitLibrary-SpecFixtures">stringPropertyWithNonBreakingSpace	&lt;fitReturns: #String&gt;	^'apple&amp;nbsp;pie'</body><body package="FitLibrary-SpecFixtures">stringPropertyWithTwoBlanks	&lt;fitReturns: #String&gt;	^'apple  pie'</body><body package="FitLibrary-SpecFixtures">sum	&lt;fitReturns: #Number&gt;	^sum</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Lists</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aColourList	&lt;fitReturns: #OrderedCollection&gt;	^aColourList</body><body package="FitLibrary-SpecFixtures">aColourList: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	aColourList := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">colour: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Colour&gt;	^Colour colour: aString</body></methods><methods><class-id>Fitlibrary.Specify.MyClassPair</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">one	&lt;fitReturns: #MyClass&gt;	^one</body><body package="FitLibrary-SpecFixtures">two	&lt;fitReturns: #MyClass&gt;	^two</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Value3</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">colour	&lt;fitReturns: #Colour&gt;	^Colour new</body></methods><methods><class-id>Fitlibrary.Specify.ListParser.Parse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">givenIntegers: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #(#Integer)&gt;	^anOrderedCollection collect: #asInteger</body><body package="FitLibrary-SpecFixtures">givenList: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #OrderedCollection&gt;	^anOrderedCollection</body><body package="FitLibrary-SpecFixtures">givenStrings: anOrderedCollection	&lt;fitTakes: #OrderedCollection&gt;	&lt;fitReturns: #(#String)&gt;	^anOrderedCollection asArray</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Department</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">city: aString	&lt;fitTakes: #String&gt;	city := aString</body></methods><methods><class-id>Fitlibrary.Specify.Calculate.DoubleUse</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">calculating	&lt;fitReturns: #Fixture&gt;	^calc</body></methods><methods><class-id>Fitlibrary.Specify.Suite.VariantOnSimpleSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">andSomeImmediateAction	&lt;fitReturns: #Boolean&gt;	^false</body></methods><methods><class-id>Fitlibrary.Specify.SpecialAction.AmbiguousSpecial</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">act2Is: aString _: bString	&lt;fitTakes: #(#String #String)&gt;</body><body package="FitLibrary-SpecFixtures">act2LessThan: aString _: bString	&lt;fitTakes: #(#String #String)&gt;</body><body package="FitLibrary-SpecFixtures">actIs: aString	&lt;fitTakes: #String&gt;</body><body package="FitLibrary-SpecFixtures">check1: aString	&lt;fitTakes: #String&gt;</body><body package="FitLibrary-SpecFixtures">not1: aString	&lt;fitTakes: #String&gt;</body></methods><methods><class-id>Fitlibrary.Specify.Parser.ClassWithParseMethod</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aValueSetWithItsOwnParseMethod	&lt;fitReturns: #ArrayFixture&gt;	| values |	values := Array with: (MyValueHolder value: (MyValue value: 1))				with: (MyValueHolder value: (MyValue value: 2)).	^ArrayFixture actuals: values</body></methods><methods><class-id>Fitlibrary.Specify.MixedCombination</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">combine: aString and: anInteger	&lt;fitTakes: #(#String #Integer)&gt;	&lt;fitReturns: #Boolean&gt;	^anInteger = 1</body></methods><methods><class-id>Fitlibrary.Specify.DefinedAction.Ab</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">a	&lt;fitReturns: #Integer&gt;	^a</body><body package="FitLibrary-SpecFixtures">a: anInteger	&lt;fitTakes: #Integer&gt;	a := anInteger</body><body package="FitLibrary-SpecFixtures">b	&lt;fitReturns: #Integer&gt;	^b</body></methods><methods><class-id>Fitlibrary.Specify.Exception.Project</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">add: aProject	&lt;fitTakes: #Project&gt;</body><body package="FitLibrary-SpecFixtures">leader	&lt;fitReturns: #EmptyUser&gt;	^EmptyUser new</body><body package="FitLibrary-SpecFixtures">leader: anEmptyUser	&lt;fitTakes: #EmptyUser&gt;</body></methods><methods><class-id>Fitlibrary.Specify.A</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">accessOther	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownByGetterInCollection</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">departments	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: Department new</body><body package="FitLibrary-SpecFixtures">users	&lt;fitReturns: #OrderedCollection&gt;	^OrderedCollection with: User new</body></methods><methods><class-id>Fitlibrary.Specify.Plugin.ConcretePerson</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.PojoGivesErrorsAndFails</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">returnsFalse	&lt;fitReturns: #Boolean&gt;	^false</body><body package="FitLibrary-SpecFixtures">throwsException	&lt;fitReturns: #Integer&gt;	^FitLibraryException raiseErrorString: 'error'</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.SetUp</class-id> <category>testing</category><body package="FitLibrary-SpecFixtures">isSetUp	&lt;fitReturns: #Boolean&gt;	^setUp</body></methods><methods><class-id>Fitlibrary.Specify.TimesCombination</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">combine: xInteger and: yInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^xInteger * yInteger</body></methods><methods><class-id>Fitlibrary.Specify.MapTraverse.MixedMap</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">mixedMap	&lt;fitReturns: #Dictionary&gt;	^(Dictionary new)		at: Colour red put: Colour green;		at: (Count count: 1) put: (Count count: 2);		yourself</body></methods><methods><class-id>Fitlibrary.Specify.Eg.User</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">account	&lt;fitReturns: #Account&gt;	^account</body><body package="FitLibrary-SpecFixtures">account: anAccount	&lt;fitTakes: #Account&gt;	account := anAccount</body><body package="FitLibrary-SpecFixtures">name	&lt;fitReturns: #String&gt;	^name</body><body package="FitLibrary-SpecFixtures">name: aString	&lt;fitTakes: #String&gt;	name := aString</body><body package="FitLibrary-SpecFixtures">owe	&lt;fitReturns: #Number&gt;	^owe</body><body package="FitLibrary-SpecFixtures">owe: aNumber	&lt;fitTakes: #Number&gt;	owe := aNumber</body><body package="FitLibrary-SpecFixtures">phones	&lt;fitReturns: #(#OrderedCollection #Phone)&gt;	^phones</body><body package="FitLibrary-SpecFixtures">phones: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection   #Phone ))&gt;	phones := anOrderedCollection</body></methods><methods><class-id>Fitlibrary.Specify.Exception.ExceptionThrownBySetter</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">createUser	&lt;fitReturns: #Object&gt;	^DomainObjectSetUpTraverse systemUnderTest: User new</body></methods><methods><class-id>FitlibraryGeneric.Specify.Collections.GenericCollections</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">aList	&lt;fitReturns: #(#OrderedCollection #Colour)&gt;	^aList</body><body package="FitLibrary-SpecFixtures">aList: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection   #Colour ))&gt;	aList := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">aListOfLists	&lt;fitReturns: #(#OrderedCollection #(#OrderedCollection #Colour))&gt;	^aListOfLists</body><body package="FitLibrary-SpecFixtures">aListOfLists: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection  #( #OrderedCollection   #Colour )))&gt;	aListOfLists := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">aListOfSets	&lt;fitReturns: #(#OrderedCollection #(#Set #Colour))&gt;	^aListOfSets</body><body package="FitLibrary-SpecFixtures">aListOfSets: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection  #( #Set   #Colour )))&gt;	aListOfSets := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">aListOfString	&lt;fitReturns: #(#OrderedCollection #String)&gt;	^aListOfString</body><body package="FitLibrary-SpecFixtures">aListOfString: anOrderedCollection	&lt;fitTakes: #(#( #OrderedCollection   #String ))&gt;	aListOfString := anOrderedCollection</body><body package="FitLibrary-SpecFixtures">aSet	&lt;fitReturns: #(#Set #Colour)&gt;	^aSet</body><body package="FitLibrary-SpecFixtures">aSet: newSet	&lt;fitTakes: #(#( #Set   #Colour ))&gt;	aSet := newSet</body><body package="FitLibrary-SpecFixtures">aSetOfSets	&lt;fitReturns: #(#Set #(#Set #Colour))&gt;	^aSetOfSets</body><body package="FitLibrary-SpecFixtures">aSetOfSets: newSet	&lt;fitTakes: #(#( #Set  #( #Set   #Colour )))&gt;	aSetOfSets := newSet</body></methods><methods><class-id>Fitlibrary.Specify.MissingMethod.FinderInJustSut</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">addToColourMix: aColour	&lt;fitTakes: #Colour&gt;</body></methods><methods><class-id>Fitlibrary.Specify.SetParser.Match</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">setEmpty	&lt;fitReturns: #Set&gt;	^Set new</body><body package="FitLibrary-SpecFixtures">setOf123	&lt;fitReturns: #Set&gt;	^#(1 2 3) asSet</body><body package="FitLibrary-SpecFixtures">setOfCount123	&lt;fitReturns: #Set&gt;	^Set		with: (Count count: 1)		with: (Count count: 2)		with: (Count count: 3)</body><body package="FitLibrary-SpecFixtures">setOfCounts23	&lt;fitReturns: #Set&gt;	^Set with: (Count count: 2) with: (Count count: 3)</body><body package="FitLibrary-SpecFixtures">setOfStringAbc	&lt;fitReturns: #Set&gt;	^#('a' 'b' 'c') asSet</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.OnFailureWithException</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">end	&lt;fitReturns: #Object&gt;</body><body package="FitLibrary-SpecFixtures">result	&lt;fitReturns: #Boolean&gt;	^true</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpSet</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">iOUSet	&lt;fitReturns: #Set&gt;	^iOUSet</body><body package="FitLibrary-SpecFixtures">iOUSet: aSet	&lt;fitTakes: #Set&gt;	iOUSet := aSet</body></methods><methods><class-id>Fitlibrary.Specify.CollectionSetUp.SetUpSet</class-id> <category>setup</category><body package="FitLibrary-SpecFixtures">name: aString owe: aDouble	&lt;fitTakes: #(#String #Double)&gt;	&lt;fitReturns: #User&gt;	^User named: aString owing: aDouble</body></methods><methods><class-id>Fitlibrary.Specify.Local</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">s	&lt;fitReturns: #String&gt;	^s</body></methods><methods><class-id>Fitlibrary.Specify.Domain.Objects</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">user	&lt;fitReturns: #User&gt;	^user</body><body package="FitLibrary-SpecFixtures">user: aUser	&lt;fitTakes: #User&gt;	user := aUser</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Sum</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">getSum	&lt;fitReturns: #Integer&gt;	^sum</body></methods><methods><class-id>Fitlibrary.Specify.Workflow.Sum</class-id> <category>operations</category><body package="FitLibrary-SpecFixtures">add: anInteger	&lt;fitTakes: #Integer&gt;	sum := sum + anInteger</body></methods><methods><class-id>Fitlibrary.Specify.Eg.MyPoint</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">x	&lt;fitReturns: #Integer&gt;	^x</body><body package="FitLibrary-SpecFixtures">x: anInteger	&lt;fitTakes: #Integer&gt;	x := anInteger</body><body package="FitLibrary-SpecFixtures">y	&lt;fitReturns: #Integer&gt;	^y</body><body package="FitLibrary-SpecFixtures">y: anInteger	&lt;fitTakes: #Integer&gt;	y := anInteger</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="FitLibrary-SpecFixtures">charAt: aZeroBasedIndex	"Needed for FitLibrary.Specifications.MultipleFlowObjects.NotDoFixture"	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Character&gt;	^self at: aZeroBasedIndex + 1</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Fixture</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>counts summary arguments listener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>DoFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>SuiteFixture</name><environment>Fitlibrary.Suite</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>SetFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>CombinationFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>DomainFixtured</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ArrayFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>ConstraintFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>PrimitiveArrayFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FitLibraryFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>SubsetFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.CollectionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ColumnFixture</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columnBindings hasExecuted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>PropertyEditor</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>OnError</name><environment>Fitlibrary</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>CalculateFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.FunctionFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>RuleTable</name><environment>Fitlibrary</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasErrors columnTargets resetMethod executeMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>DoTraverse</name><environment>Fitlibrary.Traverse.Workflow</environment><super>Fitlibrary.Traverse.TraverseBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatchRowInFlow doAutoWrapper prefixSpecialAction sequencing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>RowFixture</name><environment>Fit</environment><super>Fit.ColumnFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results missing surplus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>ActionFixture</name><environment>Fit</environment><super>Fit.Fixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parsedCells </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>DomainFixture</name><environment>Fitlibrary</environment><super>Fitlibrary.DoFixture</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary</package></attributes></class><class><name>Tree</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class></st-source>