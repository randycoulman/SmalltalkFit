<?xml version="1.0"?><st-source><!-- Name: FitLibrary-InternalsNotice:                     GNU GENERAL PUBLIC LICENSE                       Version 2, June 1991 Copyright (C) 1989, 1991 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.                            Preamble  The licenses for most software are designed to take away yourfreedom to share and change it.  By contrast, the GNU General PublicLicense is intended to guarantee your freedom to share and change freesoftware- to make sure the software is free for all its users.  ThisGeneral Public License applies to most of the Free SoftwareFoundation's software and to any other program whose authors commit tousing it.  (Some other Free Software Foundation software is covered bythe GNU Lesser General Public License instead.)  You can apply it toyour programs, too.  When we speak of free software, we are referring to freedom, notprice.  Our General Public Licenses are designed to make sure that youhave the freedom to distribute copies of free software (and charge forthis service if you wish), that you receive source code or can get itif you want it, that you can change the software or use pieces of itin new free programs; and that you know you can do these things.  To protect your rights, we need to make restrictions that forbidanyone to deny you these rights or to ask you to surrender the rights.These restrictions translate to certain responsibilities for you if youdistribute copies of the software, or if you modify it.  For example, if you distribute copies of such a program, whethergratis or for a fee, you must give the recipients all the rights thatyou have.  You must make sure that they, too, receive or can get thesource code.  And you must show them these terms so they know theirrights.  We protect your rights with two steps: (1) copyright the software, and(2) offer you this license which gives you legal permission to copy,distribute and/or modify the software.  Also, for each author's protection and ours, we want to make certainthat everyone understands that there is no warranty for this freesoftware.  If the software is modified by someone else and passed on, wewant its recipients to know that what they have is not the original, sothat any problems introduced by others will not reflect on the originalauthors' reputations.  Finally, any free program is threatened constantly by softwarepatents.  We wish to avoid the danger that redistributors of a freeprogram will individually obtain patent licenses, in effect making theprogram proprietary.  To prevent this, we have made it clear that anypatent must be licensed for everyone's free use or not licensed at all.  The precise terms and conditions for copying, distribution andmodification follow.                    GNU GENERAL PUBLIC LICENSE   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION  0. This License applies to any program or other work which containsa notice placed by the copyright holder saying it may be distributedunder the terms of this General Public License.  The "Program", below,refers to any such program or work, and a "work based on the Program"means either the Program or any derivative work under copyright law:that is to say, a work containing the Program or a portion of it,either verbatim or with modifications and/or translated into anotherlanguage.  (Hereinafter, translation is included without limitation inthe term "modification".)  Each licensee is addressed as "you".Activities other than copying, distribution and modification are notcovered by this License; they are outside its scope.  The act ofrunning the Program is not restricted, and the output from the Programis covered only if its contents constitute a work based on theProgram (independent of having been made by running the Program).Whether that is true depends on what the Program does.  1. You may copy and distribute verbatim copies of the Program'ssource code as you receive it, in any medium, provided that youconspicuously and appropriately publish on each copy an appropriatecopyright notice and disclaimer of warranty; keep intact all thenotices that refer to this License and to the absence of any warranty;and give any other recipients of the Program a copy of this Licensealong with the Program.You may charge a fee for the physical act of transferring a copy, andyou may at your option offer warranty protection in exchange for a fee.  2. You may modify your copy or copies of the Program or any portionof it, thus forming a work based on the Program, and copy anddistribute such modifications or work under the terms of Section 1above, provided that you also meet all of these conditions:    a) You must cause the modified files to carry prominent notices    stating that you changed the files and the date of any change.    b) You must cause any work that you distribute or publish, that in    whole or in part contains or is derived from the Program or any    part thereof, to be licensed as a whole at no charge to all third    parties under the terms of this License.    c) If the modified program normally reads commands interactively    when run, you must cause it, when started running for such    interactive use in the most ordinary way, to print or display an    announcement including an appropriate copyright notice and a    notice that there is no warranty (or else, saying that you provide    a warranty) and that users may redistribute the program under    these conditions, and telling the user how to view a copy of this    License.  (Exception: if the Program itself is interactive but    does not normally print such an announcement, your work based on    the Program is not required to print an announcement.)These requirements apply to the modified work as a whole.  Ifidentifiable sections of that work are not derived from the Program,and can be reasonably considered independent and separate works inthemselves, then this License, and its terms, do not apply to thosesections when you distribute them as separate works.  But when youdistribute the same sections as part of a whole which is a work basedon the Program, the distribution of the whole must be on the terms ofthis License, whose permissions for other licensees extend to theentire whole, and thus to each and every part regardless of who wrote it.Thus, it is not the intent of this section to claim rights or contestyour rights to work written entirely by you; rather, the intent is toexercise the right to control the distribution of derivative orcollective works based on the Program.In addition, mere aggregation of another work not based on the Programwith the Program (or with a work based on the Program) on a volume ofa storage or distribution medium does not bring the other work underthe scope of this License.  3. You may copy and distribute the Program (or a work based on it,under Section 2) in object code or executable form under the terms ofSections 1 and 2 above provided that you also do one of the following:    a) Accompany it with the complete corresponding machine-readable    source code, which must be distributed under the terms of Sections    1 and 2 above on a medium customarily used for software interchange; or,    b) Accompany it with a written offer, valid for at least three    years, to give any third party, for a charge no more than your    cost of physically performing source distribution, a complete    machine-readable copy of the corresponding source code, to be    distributed under the terms of Sections 1 and 2 above on a medium    customarily used for software interchange; or,    c) Accompany it with the information you received as to the offer    to distribute corresponding source code.  (This alternative is    allowed only for noncommercial distribution and only if you    received the program in object code or executable form with such    an offer, in accord with Subsection b above.)The source code for a work means the preferred form of the work formaking modifications to it.  For an executable work, complete sourcecode means all the source code for all modules it contains, plus anyassociated interface definition files, plus the scripts used tocontrol compilation and installation of the executable.  However, as aspecial exception, the source code distributed need not includeanything that is normally distributed (in either source or binaryform) with the major components (compiler, kernel, and so on) of theoperating system on which the executable runs, unless that componentitself accompanies the executable.If distribution of executable or object code is made by offeringaccess to copy from a designated place, then offering equivalentaccess to copy the source code from the same place counts asdistribution of the source code, even though third parties are notcompelled to copy the source along with the object code.  4. You may not copy, modify, sublicense, or distribute the Programexcept as expressly provided under this License.  Any attemptotherwise to copy, modify, sublicense or distribute the Program isvoid, and will automatically terminate your rights under this License.However, parties who have received copies, or rights, from you underthis License will not have their licenses terminated so long as suchparties remain in full compliance.  5. You are not required to accept this License, since you have notsigned it.  However, nothing else grants you permission to modify ordistribute the Program or its derivative works.  These actions areprohibited by law if you do not accept this License.  Therefore, bymodifying or distributing the Program (or any work based on theProgram), you indicate your acceptance of this License to do so, andall its terms and conditions for copying, distributing or modifyingthe Program or works based on it.  6. Each time you redistribute the Program (or any work based on theProgram), the recipient automatically receives a license from theoriginal licensor to copy, distribute or modify the Program subject tothese terms and conditions.  You may not impose any furtherrestrictions on the recipients' exercise of the rights granted herein.You are not responsible for enforcing compliance by third parties tothis License.  7. If, as a consequence of a court judgment or allegation of patentinfringement or for any other reason (not limited to patent issues),conditions are imposed on you (whether by court order, agreement orotherwise) that contradict the conditions of this License, they do notexcuse you from the conditions of this License.  If you cannotdistribute so as to satisfy simultaneously your obligations under thisLicense and any other pertinent obligations, then as a consequence youmay not distribute the Program at all.  For example, if a patentlicense would not permit royalty-free redistribution of the Program byall those who receive copies directly or indirectly through you, thenthe only way you could satisfy both it and this License would be torefrain entirely from distribution of the Program.If any portion of this section is held invalid or unenforceable underany particular circumstance, the balance of the section is intended toapply and the section as a whole is intended to apply in othercircumstances.It is not the purpose of this section to induce you to infringe anypatents or other property right claims or to contest validity of anysuch claims; this section has the sole purpose of protecting theintegrity of the free software distribution system, which isimplemented by public license practices.  Many people have madegenerous contributions to the wide range of software distributedthrough that system in reliance on consistent application of thatsystem; it is up to the author/donor to decide if he or she is willingto distribute software through any other system and a licensee cannotimpose that choice.This section is intended to make thoroughly clear what is believed tobe a consequence of the rest of this License.  8. If the distribution and/or use of the Program is restricted incertain countries either by patents or by copyrighted interfaces, theoriginal copyright holder who places the Program under this Licensemay add an explicit geographical distribution limitation excludingthose countries, so that distribution is permitted only in or amongcountries not thus excluded.  In such case, this License incorporatesthe limitation as if written in the body of this License.  9. The Free Software Foundation may publish revised and/or new versionsof the General Public License from time to time.  Such new versions willbe similar in spirit to the present version, but may differ in detail toaddress new problems or concerns.Each version is given a distinguishing version number.  If the Programspecifies a version number of this License which applies to it and "anylater version", you have the option of following the terms and conditionseither of that version or of any later version published by the FreeSoftware Foundation.  If the Program does not specify a version number ofthis License, you may choose any version ever published by the Free SoftwareFoundation.  10. If you wish to incorporate parts of the Program into other freeprograms whose distribution conditions are different, write to the authorto ask for permission.  For software which is copyrighted by the FreeSoftware Foundation, write to the Free Software Foundation; we sometimesmake exceptions for this.  Our decision will be guided by the two goalsof preserving the free status of all derivatives of our free software andof promoting the sharing and reuse of software generally.                            NO WARRANTY  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTYFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHENOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIESPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSEDOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK ASTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THEPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,REPAIR OR CORRECTION.  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITINGWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/ORREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISINGOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITEDTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BYYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHERPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THEPOSSIBILITY OF SUCH DAMAGES.                     END OF TERMS AND CONDITIONS            How to Apply These Terms to Your New Programs  If you develop a new program, and you want it to be of the greatestpossible use to the public, the best way to achieve this is to make itfree software which everyone can redistribute and change under these terms.  To do so, attach the following notices to the program.  It is safestto attach them to the start of each source file to most effectivelyconvey the exclusion of warranty; and each file should have at leastthe "copyright" line and a pointer to where the full notice is found.    <one line to give the program's name and a brief idea of what it does.>    Copyright (C) <year>  <name of author>    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.Also add information on how to contact you by electronic and paper mail.If the program is interactive, make it output a short notice like thiswhen it starts in an interactive mode:    Gnomovision version 69, Copyright (C) year name of author    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.    This is free software, and you are welcome to redistribute it    under certain conditions; type `show c' for details.The hypothetical commands `show w' and `show c' should show the appropriateparts of the General Public License.  Of course, the commands you use maybe called something other than `show w' and `show c'; they could even bemouse-clicks or menu items- whatever suits your program.You should also get your employer (if you work as a programmer) or yourschool, if any, to sign a "copyright disclaimer" for the program, ifnecessary.  Here is a sample; alter the names:  Yoyodyne, Inc., hereby disclaims all copyright interest in the program  `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989  Ty Coon, President of ViceThis General Public License does not permit incorporating your program intoproprietary programs.  If your program is a subroutine library, you mayconsider it more useful to permit linking proprietary applications with thelibrary.  If this is what you want to do, use the GNU Lesser GeneralPublic License instead of this License.Comment: This package contains the internals for FitLibrary.  The FitLibrary package was too big and confusing with everything in one package.If you find that you need to depend on this package directly, I consider that a bug.  Please let me know so I can fix it.  See the package comment on the FitLibrary package for contact information.There is a (disregarded) circular dependency on FitLibrary; this package isn't intended to be used on its own.# Smalltalk FitSmalltalk Fit is a Smalltalk implementation of Ward Cunningham's [Framework for Integrated Tests](http://fit.c2.com), [Fitnesse](http://www.fitnesse.org), and Rick Mugridge's [FitLibrary](http://fitlibrary.sourceforge.net).This version contains the equivalent features of:* fit-java-1.1* fitnesse-20121220* FitLibrary-2.0   Copyright (C) 2004-2013 Randy Coulman    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.See the copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.DbIdentifier: nilDbTrace: nilDbUsername: DbVersion: DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Fit' '') #(#any 'Regex11' ''))DisregardedPrerequisites: #(#(#name 'FitLibrary' #componentType #package) #(#name 'Fit-Book-Fixtures' #componentType #package))Namespace: Smalltalk.FitlibraryInternalsPackageName: FitLibrary-InternalsParcel: #('FitLibrary-Internals')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Fit' #componentType #package) #(#name 'Regex11' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Fit' '') #('Regex11' ''))PrintStringCache: nilVersion: Date: 3:37:38 PM January 23, 2016 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.0 of September 26, 2014 on January 23, 2016 at 3:37:38 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>FitlibraryInternals</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Fit.*			private Fitlibrary.*			private FitlibraryInternals.DomainAdapter.*			private FitlibraryInternals.Log.*			private Fitlibrary.Traverse.*			private Fitlibrary.Suite.*			private Fitlibrary.Traverse.Workflow.*			private FitlibraryGeneric.*			</imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></name-space><name-space><name>Utility</name><environment>FitlibraryInternals</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></name-space><name-space><name>DomainAdapter</name><environment>FitlibraryInternals</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></name-space><name-space><name>Log</name><environment>FitlibraryInternals</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></name-space><class><name>TableElementOnParse</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TableElementOnParse</class-id><body>Abstract base class of all components of a Fitnesse table.  Wraps the Fit.Parse data structure.  Contrast with TableElementOnList, which provides the same interface in the Java version, but uses a collection to hold sub-elements.  See the TableConversion comment for more information.Subclasses must implement the following messages:	private		wrapParse:Instance Variables	parse	&lt;Parse&gt;	 The Fit.Parse represented by this element.</body></comment><class><name>TableOnParse</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.TableElementOnParse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TableOnParse</class-id><body>Represents a single Fitnesse table.  Wraps a Fit.Parse data structure.  Contrast with TableOnList, which provides the same interface in the Java version, but uses a collection to hold the rows.  See the TableConversion comment for more information.</body></comment><class><name>IgnoredException</name><environment>FitlibraryInternals</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ignoredError </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.IgnoredException</class-id><body>An error that is ignored because the problem has already been signalled locally in the table.Instance Variables	ignoredError	&lt;GenericException&gt;	The error being ignored.</body></comment><class><name>AbstractDoCaller</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>problem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.AbstractDoCaller</class-id><body>The base class of all actions that can be invoked from a row of a DoTraverse/DoFixture.Instance Variables	problem	&lt;Error&gt;	An error that occurred while trying to invoke the action.</body></comment><class><name>MultiDefinedActionCaller</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDoCaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext furtherRows methodName multiParameterSubstitution </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MultiDefinedActionCaller</class-id><body>A DoCaller that looks up and invokes a MultiDefinedAction.Instance Variables	furtherRows	&lt;Boolean&gt;	True if there are rows after the paramters row; false otherwise.	methodName	&lt;String&gt;	The name of the defined action.	multiParameterSubstitution	&lt;ParameterBinder&gt;	The ParameterBinder that represents the DefinedAction to call.	runtimeContext	&lt;RuntimeContext&gt;	The active context of the test run.</body></comment><class><name>TypedObject</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject typeAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TypedObject</class-id><body>Associates an object with its type information in the form of a Fit TypeAdapter. Instance Variables	subject	&lt;Object&gt;	The object being wrapped.	typeAdapter	&lt;TypeAdapter&gt;	The type information.</body></comment><class><name>DefinedActionCaller</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDoCaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binder runtimeContext methodName actualArgs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefinedActionCaller</class-id><body>A DoCaller that looks up and invokes a DefinedAction.Instance Variables	actualArgs	&lt;SequenceableCollection&gt;	The arguments to pass to the DefinedAction.	binder	&lt;ParameterBinder&gt;	The ParameterBinder that represents the DefinedAction to call.	methodName	&lt;String&gt;	The name of the DefinedAction to call.	runtimeContext	&lt;RuntimeContext&gt;	The active context of the test run.</body></comment><class><name>DelegateParser</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DelegateParser</class-id><body>Base class for delegating parsing to another object or class.Subclasses must implement the following messages:	parsing		parse:</body></comment><class><name>AbstractDelegateObjectParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegate parseMethod matchesMethod showMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.AbstractDelegateObjectParser</class-id><body>Base class for delegating parsing, showing, and matching to another object.Instance Variables	delegate	&lt;Object&gt;	The object to delegate to.	matchesMethod	&lt;CompiledMethod&gt;	The method to invoke for matching objects.	parseMethod	&lt;CompiledMethod&gt;	The method to invoke for parsing strings into objects.	showMethod	&lt;CompiledMethod&gt;	The method to invoke for showing an object as a string.</body></comment><class><name>DelegateObjectParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDelegateObjectParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DelegateObjectParser</class-id><body>Delegate parsing, matching, and showing of a specific class to another object.</body></comment><class><name>MethodClosure</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object method signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MethodClosure</class-id><body>A MethodClosure is the combination of a method to invoke, and the receiver for that method. Instance Variables	method	&lt;CompiledMethod&gt;	The method to invoke.	object	&lt;Object&gt;	The receiver to invoke the method on.	signature	&lt;MethodSignature&gt;	The reported MethodSignature for the method.</body></comment><class><name>TemporaryPlugBoardForRuntime</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TemporaryPlugBoardForRuntime</class-id><body>Maintains a per-process DefinedActionsRepository.</body></comment><class><name>Filter</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>downstream startLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Filter</class-id><body>The abstract base class of table comparison filters.  Filters allow table matching to look for important markup rather than character-for-character matching when necessary.  Filters can be aggregated into a "pipeline" such that, if one filter doesn't apply, the next one in line gets a chance as well.Subclasses must implement the following messages:	private		matchAfterPrefixActual:expected:Instance Variables	downstream	&lt;Filter&gt;	The next filter in the pipeline.	startLabel	&lt;String&gt;		Text to search for.  Content must match up to and including this label.  Matching after the label is controlled by subclass implementations of #matchAfterPrefixActual:expected:.</body></comment><class><name>StackTraceFilter</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.StackTraceFilter</class-id><body>Compare table content containing error stack traces.  Content is considered to match as long as expected and actual both contain stack traces; the details of the traces are irrelevant.</body></comment><class><name>Tree</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Tree</class-id><body>The abstract base class of trees that are interpreted from HTML lists.Subclasses must implement the following messages:	accessing		children		text		title</body></comment><class><name>AbstractFileHandler</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>file </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.AbstractFileHandler</class-id><body>Abstract base class of fixturing support for working with files from test tables.Subclasses must implement the following messages:	initialize-release		fileNameIs:Instance Variables	file	&lt;Filename&gt;	The filename to operate on.</body></comment><class><name>FileHandler</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractFileHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FileHandler</class-id><body>Fixturing support for working with files from test tables.</body></comment><class><name>GlobalActionScope</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GlobalActionScope</class-id><body>The global scope for finding actions based on text in table cells.Instance Variables	runtime	&lt;RuntimeContextContainer&gt;	The runtime context for the current test suite run.</body></comment><class><name>DoFlow</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>current doFlowOnTable runtime scopeStack setUpTearDown domainCheck domainInject suiteFixture </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DoFlow</class-id><body>Runs a storytest in flow mode.  Integrates various pieces of functionality:* Ordinary Do flow* DomainFixture flow, with switching for 3 phases: inject, do, check* SuiteFixtureInstance Variables	current	&lt;DoFlow&gt;	The current table evaluator.	doFlowOnTable	&lt;DoFlowOnTable&gt;	Interprets a table in ordinary Do flow mode.	runtime	&lt;RuntimeContextContainer&gt;	The runtime context for the current test suite run.</body></comment><class><name>DoFlowWithExtraTableAddedWhenNeeded</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DoFlow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DoFlowWithExtraTableAddedWhenNeeded</class-id><body>A variant of DoFlow that adds an extra error table at the end of the test if necessary.</body></comment><class><name>ActionSignature</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name arity methodSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ActionSignature</class-id><body>Represents the signature (in Smalltalk, just the selector) of an action in a "do" table.Instance Variables	name	&lt;String&gt;	The name of the action.</body></comment><class><name>FitLibraryException</name><environment>FitlibraryInternals</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FitLibraryException</class-id><body>The base class of all FitLibrary errors.</body></comment><class><name>ParseException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ParseException</class-id><body>The base class of errors that occur while parsing table cells.</body></comment><class><name>CouldNotParseException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ParseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.CouldNotParseException</class-id><body>The FitLibrary version of an error that is raised when a value cannot be parsed.</body></comment><class><name>MethodSpec</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext numArgs segments matchGetter matchSetter mergeFront basicCamelName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MethodSpec</class-id><body>The specification of a method to be looked up on a target object.  A MethodSpec knows how many arguments are expected and is build incrementally by adding method name segments (Strings), generally from table cells in a test.  From these segments, we can produce a Java-style function name or a canonical Smalltalk selector.  Since FitLibrary allows the keywords (method name segments) in a do-style table to be divided up in any random order, we do method lookup by producing the Java-style function name, and by converting Smalltalk selectors to the same format and checking for equality.This class doesn't  appear in the original Java, but is a handy abstraction.Instance Variables	numArgs	&lt;Number&gt;	The number of arguments the method takes.	runtimeContext	&lt;RuntimeContextContainer&gt;	The current runtime context.  Used for camel-casing names.	segments	&lt;(SequenceableCollection of: (String))&gt;	Portions of the method name being constructed.</body></comment><class><name>Matcher</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>endLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Matcher</class-id><body>The abstract base class of table comparison matchers.  Matchers are Filters that allow flexible matching between start and end labels, but require all text before and after the label pair to match exactly.Subclasses must implement the following messages:	private		matchInsideActual:expected:Instance Variables	endLabel	&lt;String&gt;	The end text to search for.  Matching before the label is controlled by subclass implementations of #matchInsideActual:expected:. Content after this label must match exactly.</body></comment><class><name>FitLabelMatcher</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Matcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FitLabelMatcher</class-id><body>Compare table content containing fit labels.  Content is considered to match as long as the actual label begins with the expected label.  All other details of the content are irrelevant.</body></comment><class><name>LookupClosureStandard</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.LookupClosureStandard</class-id><body>Implements the standard FitLibrary way of looking up MethodClosures.</body></comment><class><name>MissingTablesException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MissingTablesException</class-id><body>An error that is raised when a nested table is expected, but not there.</body></comment><class><name>StringMatcher</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.StringMatcher</class-id><body>Compare strings that might contain non-breaking whitespace.  StringMatcher polymorphically participates in a filter pipeline as the endpoint (see Filter and Matcher).</body></comment><class><name>DynamicVariablesMap</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>map </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DynamicVariablesMap</class-id><body>The base class for all types of dynamic variables.  Essentially a wrapper around a Dictionary.Instance Variables	map	&lt;Dictionary&gt;	The currently defined variables.</body></comment><class><name>GlobalDynamicVariables</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DynamicVariablesMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GlobalDynamicVariables</class-id><body>Stores dynamic variables that are global to an entire test page and resolves them to their values when requested to do so.</body></comment><class><name>TableReportListener</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TableReportListener</class-id><body>Listens for completion of each table and of all of the tables, and reports results back to Fitnesse via server.The server back-reference is used to simulate the inner class used in the Java implementation.Instance Variables	server	&lt;FitServerBridge&gt;	Back-reference to the owning object.  See above.</body></comment><class><name>Parser</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Parser</class-id><body>Abstract base class of all FitLibrary parsers.Subclasses must implement the following messages:	matching		expectedCell:matches:resultsInto:	parsing		parse:resultsInto:	showing		show:</body></comment><class><name>CollectionParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluator showParser valueParser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.CollectionParser</class-id><body>An abstract Parser for handling cells that represent collections of objects.Subclasses must implement the following messages:	private		targetClass		traverseClassInstance Variables	evaluator	&lt;Traverse&gt;	The Traverse that is evaluating the table.	showParser	&lt;Parser&gt;	The parser used to show list elements.	valueParser	&lt;Parser&gt;	The parser used to parse list elements.</body></comment><class><name>MapParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.CollectionParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyTypeAdapter valueTypeAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MapParser</class-id><body>An Parser for handling cells that represent dictionaries.</body></comment><class><name>GenericMapParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.MapParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GenericMapParser</class-id><body>A Parser for handling Dictionaries where the key and value types are known (a.k.a. Java Generics).</body></comment><class><name>FitLibraryExceptionInHtml</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FitLibraryExceptionInHtml</class-id><body>A FitLibrary error that may contain an HTML error message that does not need to be escaped.</body></comment><class><name>MissingMethodException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryExceptionInHtml</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signatures classes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MissingMethodException</class-id><body>Error raised when a method cannot be found.Instance Variables	classes	&lt;Collection&gt;	The candidate classes for finding the method.	signatures	&lt;Colection&gt;	The possible name variations for the method.</body></comment><class><name>StopWatch</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.StopWatch</class-id><body>Used to time parts of test pages.Instance Variables	start	&lt;Time&gt;	The time the stopwatch was started.</body></comment><class><name>LookupMethodTargetStandard</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.LookupMethodTargetStandard</class-id><body>Implements the standard FitLibrary way of looking up CalledMethodTargets (i.e., message receivers).</body></comment><class><name>RuntimeContext</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suiteWideRuntimeContext foldingTexts testResults testResultsStack currentRow logConfiguration dynamicVariables definedActionCallManager currentTable onErrorHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.RuntimeContext</class-id><body>Representation of runtime state that is passed around during the execution of a suite of storytests.</body></comment><class><name>TableElement</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag elements tagAnnotation leader trailer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TableElement</class-id><body>Abstract base class of all components of a Fitnesse table.  Sub-components are held in a collection of elements.  Contrast with TableElementOnParse, which provides the same interface in the Java version, but wraps the Fit.Parse data structure.  See the TableConversion comment for more information.Instance Variables	elements	&lt;(SequenceableCollection of: TableElementOnList)&gt;	 The sub-components of this table element.	leader	&lt;String&gt;	Text that appears before this table element.	tag	&lt;String&gt;	The HTML tag that represents this table element.	tagAnnotation	&lt;String&gt;	Additional attributes for the tag.	trailer	&lt;String&gt;	Text that appears after this table element.</body></comment><class><name>Row</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.TableElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowIsHidden </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Row</class-id><body>Represents a row of a Fitnesse table. Cells are held in a collection.  Contrast with RowOnParse, which provides the same interface in the Java version, but wraps the Fit.Parse data structure.  See the TableConversion comment for more information.</body></comment><class><name>InnerTableContext</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table rowIndex evaluator typedSubject runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.InnerTableContext</class-id><body>Represents the context used by various ways of evaulating a test table.This class doesn't exist in the Java implementation, but is used in Smalltalk to eliminate a big, ugly "typecase".Instance Variables	evaluator	&lt;Traverse&gt;	The object currently running the test.	rowIndex	&lt;Integer&gt;	The index of the current row of the table.	table	&lt;TableOnList&gt;	The table to evaluate.</body></comment><class><name>NotRejectedException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NotRejectedException</class-id><body>An Eror that is raised if a 'not' or 'reject' special action doesn't either return a Boolean or raise an error.</body></comment><class><name>SuiteWideRuntimeContext</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>global scope timeouts tableEvaluator maxErrorsBeforeStopping maxFailsBeforeStopping addTimings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SuiteWideRuntimeContext</class-id><body>The portion of the runtime context that applies to the entire test suite.Instance Variables	global	&lt;GlobalActionScope&gt;	 The global action scope used to look up actions for storytests.</body></comment><class><name>PlugBoard</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.PlugBoard</class-id><body>A utility class that allows client fixture code to substitute (plug-in) its own facilities for handling various functions within FitLibrary.</body></comment><class><name>InvalidMapString</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ParseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.InvalidMapString</class-id><body>An error that is raised when a MapTraverse table cell contains an incorrectly formatted entry.</body></comment><class><name>DoFlowOnTable</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>flowEvaluator doFlower runtime scopeStack setUpTearDown </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DoFlowOnTable</class-id><body>Interprets a single table in Do Flow mode.Instance Variables	doFlower	&lt;DoFlow&gt;	The owning DoFlow that is interpreting the entire storytest.	flowEvaluator	&lt;DoTraverse&gt;	Helper for evaluating the table in flow mode.	runtime	&lt;RuntimeContextContainer&gt;	The runtime context for the current test suite run.</body></comment><class><name>DefinedActionCallManager</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>callsInProgress shows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefinedActionCallManager</class-id><body>Track calls to defined actions, watching for recursion.Instance Variables	callsInProgress	&lt;OrderedCollection&gt;	The defined action calls currently in progress.</body></comment><class><name>SelfConstructorParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parseMethod receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SelfConstructorParser</class-id><body>A Parser that handles objects that define a constructor method that takes a String.Instance Variables	parseMethod	&lt;CompiledMethod&gt;	The constructor method.	receiver	&lt;Class&gt;	The class to construct.</body></comment><class><name>DelegatingParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegateParser evaluator typeAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DelegatingParser</class-id><body>A Parser that delegates the parsing, showing, and matching tasks to a DelegateParser.Instance Variables	delegateParser	&lt;DelegateParser&gt;	The object to delgate to.	evaluator	&lt;TraverseBase&gt;	The evaluator that is processing the current test table.</body></comment><class><name>DispatchRowInFlow</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluator sequencing dynamicSequencing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DispatchRowInFlow</class-id><body>Helper that evaluates a single row of a test table and invokes any actions specified by that row.</body></comment><class><name>CalledMethodTarget</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments closure parameterParsers resultParser everySecond repeatString exceptionString evaluator runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.CalledMethodTarget</class-id><body>Sends a message with values collected from row cells, and possibly checks the result against a cell.  Constructs Parsers for getting cell values, comparisons, etc.Instance Variables	args	&lt;SequenceableCollection&gt;	The arguments to pass to the method (collected from row cells).	closure	&lt;MethodClosure&gt;	The message/receiver to be sent.	parameterParsers	&lt;SequenceableCollection&gt;	The Parsers used to parse cell values.</body></comment><class><name>ConstantMethodTarget</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.CalledMethodTarget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ConstantMethodTarget</class-id><body>A CalledMethodTarget that always returns the same value when invoked.Instance Variables	value	&lt;Object&gt;	The value to return.</body></comment><class><name>MissingMethodMessage</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>missingMethods possibleClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MissingMethodMessage</class-id><body>Helper class for constructing a "method missing" message.This class is not in the original Java implementation, but is used to clean up the implementation.Instance Variables	missingMethods	&lt;Collection&gt;	The message selectors that couldn't be found.	possibleClasses	&lt;Collection&gt;	The candidate classes where the method could live.</body></comment><class><name>ClassNotFoundException</name><environment>FitlibraryInternals</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ClassNotFoundException</class-id><body>An error raised when a class cannot be found.  This mirrors the core Java exception of the same name.</body></comment><class><name>FitLibrarySelectors</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><class><name>FitLibraryExceptionWithHelp</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FitLibraryExceptionWithHelp</class-id><body>The base class of errors that have a help page (that is currently not used).</body></comment><class><name>MissingCellsException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryExceptionWithHelp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MissingCellsException</class-id><body>An error that is raised when a table has fewer cells in a row than expected/required.</body></comment><class><name>TwoStageSpecial</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>secondStageBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TwoStageSpecial</class-id><body>The second stage of a two-stage special do-table action.In Java, this is an abstract class that is only ever subclassed anonymously.  In Smalltalk, we use a block in place of the abstract method that is implemented by the anonymous subclasses.Instance Variables	secondStageBlock	&lt;BlockClosure&gt;	A one-arg block (taking a TestResults) that is invoked when running the second stage of the special action.</body></comment><class><name>RowWrongWidthException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.RowWrongWidthException</class-id><body>An error raised when a row has the wrong number of cells for the its Fixture/Traverse.</body></comment><class><name>CreateFromClassNameCaller</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDoCaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object exceptionToThrow className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.CreateFromClassNameCaller</class-id><body>A DoFixture action that instantiates an object from a class name specified in the table.Instance Variables	object	&lt;Object&gt;	The instantiated object.</body></comment><class><name>MapElement</name><environment>FitlibraryInternals.Utility</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Utility.MapElement</class-id><body>An element of a collection that was built from a Dictionary.Instance Variables	key	&lt;Object&gt;	The lookup key of the element.	value	&lt;Object&gt;	The value of the element.</body></comment><class><name>HtmlParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.HtmlParser</class-id><body>A Parser that doesn't interpret cell contents as text, but rather in some other way.</body></comment><class><name>TreeParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.HtmlParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TreeParser</class-id><body>A Parser that converts an HTML list into a ListTree.Instance Variables	targetClass	&lt;Tree&gt;	The specific Tree class to be constructed.</body></comment><class><name>DoAutoWrapper</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DoAutoWrapper</class-id><body>Wraps a non-Fixture/Traverse object in the appropriate type of Traverse.</body></comment><class><name>SelfParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parseMethod receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SelfParser</class-id><body>A Parser for objects that can handle parsing on their own via a class-side #fitParse: method.Instance Variables	parseMethod	&lt;CompiledMethod&gt;	The method to use for parsing strings into objects.	receiver	&lt;Class&gt;	The class being parsed.</body></comment><class><name>TableListener</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listener testResults </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TableListener</class-id><body>Listener that gets notified when a table is complete, and when a storytest is complete.  Forwards the notifications on to a ReportListener.Instance Variables	listener	&lt;EmptyFixtureListener | TableReportListener&gt;	The ReportListener to forward notifications to.	testResults	&lt;TestResultsOnCounts&gt;	The results of the current test run.</body></comment><class><name>ColumnTarget</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ColumnTarget</class-id><body>Abstract base class for method targets representing columns of a RuleTable.Subclasses must implement the following messages:	acting		actOn:resultsInto:	testing		isOutputInstance Variables	target	&lt;CalledMethodTarget&gt;	The method target to call.</body></comment><class><name>OutputColumnTarget</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ColumnTarget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.OutputColumnTarget</class-id><body>Represents a method target for an output column of a RuleTable.</body></comment><class><name>ByStringParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variableResolver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ByStringParser</class-id><body>Special parser used for methods that take generic Objects.</body></comment><class><name>DefinedActionParameterTranslation</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefinedActionParameterTranslation</class-id><body>A utility class that translates old-style plain text parameters into new-style @{parameters}.</body></comment><class><name>BooleanMethodException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryExceptionWithHelp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.BooleanMethodException</class-id><body>An error raised if a non-Boolean-returning method is specified in a ConstraintFixture/Traverse.</body></comment><class><name>EmptyFixtureListener</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.EmptyFixtureListener</class-id><body>A do-nothing ReportListener for cases where no listening is required.  Essentially follows the NullObject pattern.</body></comment><class><name>DefinedMultiAction</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefinedMultiAction</class-id><body>A MultiDefinedAction is, like a DefinedAction, essentially a subroutine that is created in Fitnesse rather than in fixture code.  The difference is that a MultiDefinedAction can be called multiple times by specifying the parameters in the columns in a table rather than the do-style calls of a DefinedAction.Instance Variables	name	&lt;String&gt;	The name of the action.</body></comment><class><name>DefinedAction</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DefinedMultiAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argumentCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefinedAction</class-id><body>A DefinedAction is. like a MultiDefinedAction, essentially a subroutine that is created in Fitnesse rather than in fixture code.  The difference is that a MultiDefinedAction can be called multiple times by specifying the parameters in the columns in a table rather than the do-style calls of a DefinedAction.Instance Variables	argumentCount	&lt;Integer&gt;	The number of arguments taken by the action.</body></comment><class><name>MatchOneMethodClosure</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodSpec subject selector signature compiledMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MatchOneMethodClosure</class-id><body>Helper for looking up methods.  Extracted from LookupClosureStandard.Instance Variables	compiledMethod	&lt;CompiledMethod&gt;	The method under consideration.	methodSpec	&lt;MethodSpec&gt;	The specification for the desired method.	selector	&lt;Symbol&gt;	The selector under consideration.	signature	&lt;MethodSignature&gt;	The signature of the method under consideration.	subject	&lt;Object&gt;	The target object that might contain the method.</body></comment><class><name>NoSuchPropertyException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NoSuchPropertyException</class-id><body>An error that is raised when a getter method cannot be found when attempting to bind columns in a CollectionTraverse table.</body></comment><class><name>NoValueProvidedException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ParseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NoValueProvidedException</class-id><body>Raised when attempting to check a table value when none was provided.</body></comment><class><name>ParameterBinder</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>formalParameters tables pageName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ParameterBinder</class-id><body>Binds actual parameters to formal parameters for a DefinedAction.Instance Variables	formalParameters	&lt;SequenceableCollection&gt;	The parameters accepted by the defined action.	tables	&lt;Tables&gt;	The tables that comprise the DefinedAction body.</body></comment><class><name>LogConfiguration</name><environment>FitlibraryInternals.Log</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>appender </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Log.LogConfiguration</class-id><body>Very simple implementation of the Java ConfigureLog4j class.This implementation doesn't have the full logging framework that the Java version has.Instance Variables	appender	&lt;ShowAfterTableAppender&gt;	The log appender to use.</body></comment><class><name>ClassIsAbstract</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ClassIsAbstract</class-id><body>An error raised when attempting to instantiate an abstract class.</body></comment><class><name>StringDifferencingStandard</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.StringDifferencingStandard</class-id><body>Implements the standard FitLibrary way of comparing strings.  Uses the new-ish SequenceableCollectionDifferences object to do the work. Can be replaced or customized using PlugBoard.</body></comment><class><name>LocalFile</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.LocalFile</class-id><body>Represents a file on the local file system.Instance Variables	filename	&lt;String&gt;	The name of the file.</body></comment><class><name>Tables</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.TableElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Tables</class-id><body>Represents a set of Fitnesse tables. Tables are held in a collection.  Contrast with TablesOnParse, which provides the same interface in the Java version, but wraps the Fit.Parse data structure.  See the TableConversion comment for more information.</body></comment><class><name>SetParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.CollectionParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SetParser</class-id><body>A Parser for handling cells that contain sets (actually SequenceableCollections) of objects.</body></comment><class><name>GenericSetParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.SetParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GenericSetParser</class-id><body>A Parser for handling sets where the element type is known (a.k.a Java Generics).Instance Variables	componentType	&lt;TypeAdapter&gt;	The element type.</body></comment><class><name>PrefixSpecialAction</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.PrefixSpecialAction</class-id><body>Supports prefixed special actions in do-style tables.Instance Variables	actionContext	&lt;DoTraverse&gt;	The evaulator that is evaluating the test.</body></comment><class><name>GraphicParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.HtmlParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GraphicParser</class-id><body>Parser for handling HTML image links in table cells.</body></comment><class><name>DefineActionsOnPageSlowly</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>topPageName runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefineActionsOnPageSlowly</class-id><body>Create defined actions from a wiki page by connecting to the Fitnesse server.Instance Variables	runtimeContext	&lt;RuntimeContext&gt;	The context of the currently running test suite.	topPageName	&lt;String&gt;	The name of the top-level page containing the defined actions.</body></comment><class><name>FitServerBridge</name><environment>FitlibraryInternals</environment><super>Fit.AbstractFitServer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suiteTestResults reportListener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FitServerBridge</class-id><body>A variant of Fit.FitServer needed to run FitLibrary.Subclasses must implement the following messages:	private		doTablesInHtml:Instance Variables	arguments	&lt;FitServerArguments&gt;	Needed data parsed from the command-line arguments.	outputStream	&lt;Stream&gt;	Stream for writing error information, typically Transcript or OS.Stdout/OS.Stderr.	reportListener	&lt;TableReportListener&gt;	Object to notify upon completion of each table and all tables.	socket	&lt;SocketAccessor&gt;	Socket for communicating with Fitnesse.	socketOutput	&lt;Stream&gt;	WriteStream for sending data to Fitnesse.	socketReader	&lt;Socket&gt;	Alias for socket; in the Java implementation, this is the ReadStream half of the Fitnesse socket.	suiteTestResults	&lt;TestResultsOnCounts&gt;	Aggregate test results for the entire test suite being run.</body></comment><class><name>TestResults</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>counts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TestResults</class-id><body>The results of a test run.  Wraps Fit.Counts to provide a more suitable interface for FitLibrary.Instance Variables	counts	&lt;Counts&gt;	The actual test results.</body></comment><class><name>SimpleWikiTranslator</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SimpleWikiTranslator</class-id><body>Translate wiki syntax into HTML.</body></comment><class><name>MethodLookup</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lookupClosure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MethodLookup</class-id><body>Helper class for looking up methods.This class isn't in the original Java implementation.  Rather, it contains parts of the un-ported GenericTypedObject behavior.Instance Variables	lookupClosure	&lt;LookupClosureStandard&gt;	The method lookup policy.</body></comment><class><name>DefinedActionBodyCollector</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefinedActionBodyCollector</class-id><body>Collect defined actions from a Fitnesse page.</body></comment><class><name>SingleNestedTableException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SingleNestedTableException</class-id><body>Raised when attempting to access a single embedded table in a cell when multiple tables are present.</body></comment><class><name>ValidCall</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableCall </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ValidCall</class-id><body>Represents a valid DefinedAction call from a plain text table.Instance Variables	tableCall	&lt;SequenceableCollection&gt;	The DefinedAction call, broken up into what will become table cells.</body></comment><class><name>NullParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NullParser</class-id><body>A parser that does nothing.  Implements the NullObject pattern.</body></comment><class><name>FitHandler</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FitHandler</class-id><body>Bridge class for running Fit Fixture tables from FitLibrary.</body></comment><class><name>ListParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.CollectionParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ListParser</class-id><body>A Parser for handling cells that contain lists (actually SequenceableCollections) of objects.</body></comment><class><name>GenericListParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ListParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GenericListParser</class-id><body>A Parser for handling lists (OrderedCollections) where the element type is known (a.k.a Java Generics).Instance Variables	componentType	&lt;TypeAdapter&gt;	The element type.</body></comment><class><name>VariableResolution</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text tables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.VariableResolution</class-id><body>Represents the result of resolving the dynamic variable references within a table cell.Instance Variables:	tables	&lt;Tables&gt;	The tables to add to the cell (empty if the variable's value was not a Tables).	text	&lt;String&gt;	The replacement text for the cell.</body></comment><class><name>ExceptionHandlingStandard</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ExceptionHandlingStandard</class-id><body>Implements the standard FitLibrary way of handling exceptions.  Can be replaced or customized using PlugBoard.</body></comment><class><name>BadNumberException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ParseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.BadNumberException</class-id><body>An error that is raised when trying to parse a number and failing.</body></comment><class><name>PlainTextAnalyser</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedActionsRepository runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.PlainTextAnalyser</class-id><body>Analyses a plain text table looking for valid defined action calls.Instance Variables	definedActionsRepository	&lt;DefinedActionsRepositoryStandard&gt;	The repository of available DefinedActions.	runtimeContext	&lt;RuntimeContext&gt;	The context of the currently-running test suite.</body></comment><class><name>NullFromClassFactoryMethod</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NullFromClassFactoryMethod</class-id><body>An error raised when a #concreteClass* method returns nil.</body></comment><class><name>InputColumnTarget</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ColumnTarget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.InputColumnTarget</class-id><body>Represents a method target for an input column of a RuleTable.</body></comment><class><name>DoAction</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target row innerFrom sequencing runtime from to </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DoAction</class-id><body>A flexible special do-style action.Instance Variables	from	&lt;Integer&gt;	The first cell of the special action call.	innerFrom	&lt;Integer&gt;	The first cell of the method to be checked with the special action.	row	&lt;RowOnList&gt;	The table row being processed.	runtime	&lt;RuntimeContextContainer&gt;	The current runtime context.	sequencing	&lt;Boolean&gt;	Use sequence mode if true; do mode if false.	target	&lt;CalledMethodTarget&gt;	The special action method to run.	to	&lt;Integer&gt;	The last cell of the special action call.</body></comment><class><name>GenericFinder</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>findStringMethod typeAdapter showMethod findExceptionMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GenericFinder</class-id><body>A helper for DomainObjectParser that looks up methods for finding and displaying Entities in fixturing classes.Instance Variables	findExceptionMessage	&lt;String&gt;	The message to show when a find method cannot be found.	findStringMethod	&lt;MethodClosure&gt;	The method used to find the entity.	showMethod	&lt;MethodClosure&gt;	The method used to display the entity.	typeAdapter	&lt;TypeAdapter&gt;	The type of object to find/show.</body></comment><class><name>AliasMethodSpec</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.AliasMethodSpec</class-id><body>A variant of MethodSpec that takes a specific selector to match.  This is used for alias methods (see implementors of #aliasForSelector:).Instance Variables	selector	&lt;Symbol&gt;	The selector to match.</body></comment><class><name>TablesOnParse</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.TableElementOnParse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TablesOnParse</class-id><body>Represents a set of Fitnesse tables.  Wraps a Fit.Parse data structure.  Contrast with TablesOnList, which provides the same interface in the Java version, but holds the tables in a collection.  See the TableConversion comment for more information.</body></comment><class><name>CellOnParse</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.TablesOnParse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.CellOnParse</class-id><body>Represents a cell in a Fitnesse table.  Wraps a Fit.Parse data structure.  Contrast with CellOnList, which provides the same interface in the Java version, but uses a collection to hold any nested tables.  See the TableConversion comment for more information.</body></comment><class><name>PropertyEditorBasedParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluator editor typeAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.PropertyEditorBasedParser</class-id><body>A parser that uses a PropertyEditor to parse and show objects.Instance Variables	editor	&lt;PropertyEditor&gt;	The property editor to delegate to.	evaluator	&lt;TraverseBase&gt;	The evaluator that is processing the current table.	typeAdapter	&lt;TypeAdapter&gt;	The type being parsed.</body></comment><class><name>ScopeStack</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack selectObjects globals global flowEvaluator selectNames suite abandon stopOnError </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ScopeStack</class-id><body>Tracks the stack of test evaluation scopes during the course of a test suite run.Instance Variables	flowEvaluator	&lt;Traverse&gt;	The current flow-mode evaulator.	global	&lt;GlobalActionScope&gt;		The global action scope.	globals	&lt;(Collection of: Object))&gt;	All globals.	selectObjects	&lt;(Collection of: (Object))&gt;	Objects "selected" into the current scope (? - haven't got that far yet).	stack	&lt;OrderedCollection&gt;	The stack of "system under test" objects that have been in scope.</body></comment><class><name>SpecialCaller</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDoCaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodName specialMethod twoStageSpecial </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SpecialCaller</class-id><body>A DoFixture action that looks up and invokes a special do-action as specified by the test table.Instance Variables	methodName	&lt;String&gt;	The name of the special action method.	specialMethod	&lt;MethodClosure&gt;	The special action method.	twoStageSpecial	&lt;TwoStageSpecial&gt;	The second stage of a two-stage special action.</body></comment><class><name>ScopeState</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>restoreBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ScopeState</class-id><body>Encapsulates the state of a ScopeStack at a point in time, and is able to unwind the stack to that point.Use a block to simulate a Java anonymous inner class.Instance Variables	restoreBlock	&lt;BlockClosure&gt;	The block that restores the stack to its original state.</body></comment><class><name>ListTree</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Tree</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title children text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ListTree</class-id><body>A tree structure returned by TreeParser when interpreting an HTML list as a tree.Instance Variables	children	&lt;(Collection of: Tree)&gt;	The child sub-trees.	text	&lt;String&gt;	The untagged text in the tree.	title	&lt;String&gt;	The root text of the tree.</body></comment><class><name>DefinedActionsRepositoryStandard</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedActionMapForCamel classMapForCamel definedMultiActionMap definedActionMapForPlainText classMapForPlainText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefinedActionsRepositoryStandard</class-id><body>A repository containing all currently-defined DefinedActions.Instance Variables	definedActionMapForCamel	&lt;Dictionary&gt;	Actions to be found via camel-case name lookup.</body></comment><class><name>ImageNameGraphic</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expectedFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ImageNameGraphic</class-id><body>A helper object for ImageFixture that represents an expected HTML image link.Instance Variables	expectedFile	&lt;String&gt;	The name of the image file.</body></comment><class><name>MissingRowException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryExceptionWithHelp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.MissingRowException</class-id><body>An error that is raised when a table has fewer rows than required.</body></comment><class><name>RowProxy</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.RowProxy</class-id><body>A proxy of a Row that can access the currently active row in a runtime context.Instance Variables	rowBlock	&lt;BlockClosure&gt;	A block that provides access to the currently active test results.</body></comment><class><name>StringAdapter</name><environment>FitlibraryInternals.DomainAdapter</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DomainAdapter.StringAdapter</class-id><body>An adapter around strings for use with the 'as string' special action.Most of the methods here translate the Java method name into the Smalltalk method name.  A few of the methods used in the SpecialActions.TestAsString spec translate directly; for these, method signatures are provided in the SequenceableCollection&gt;&gt;signatureFor: extension method.Instance Variables	subject	&lt;String&gt;	The String being adapted.</body></comment><class><name>RowOnParse</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.TableElementOnParse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.RowOnParse</class-id><body>Represents a row in a Fitnesse table.  Wraps a Fit.Parse data structure.  Contrast with RowOnList, which provides the same interface in the Java version, but uses a collection to hold the cells.  See the TableConversion comment for more information.</body></comment><class><name>LocalDynamicVariables</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DynamicVariablesMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.LocalDynamicVariables</class-id><body>Stores dynamic variables that are local to a test table row and resolves them to their values when requested to do so.Instance Variables	outer	&lt;DynamicVariablesMap&gt;	The next outer variable scope.</body></comment><class><name>ParseDelegation</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ParseDelegation</class-id><body>Utility class for registering and looking up parse delegates for various classes.</body></comment><class><name>FoldFilter</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>downstream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FoldFilter</class-id><body>A Filter that ignores content within an included section of a specification test.Instance Variables	downstream	&lt;Filter&gt;	The next filter in the filter pipeline.</body></comment><class><name>GetterParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.GetterParser</class-id><body>A Parser that wraps and delegates to another Parser, but invokes a method to obtain its result.Instance Variables	parser	&lt;Parser&gt;	The wrapped parser.</body></comment><class><name>TablesCompare</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorReport matcherPipeline variableResolver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TablesCompare</class-id><body>A helper class for comparing actual and expected tables on behalf of SpecifyFixture.Instance Variables	errorReport	&lt;SpecifyErrorReport&gt;	 Collects differences for later reporting.</body></comment><class><name>Table</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.TableElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Table</class-id><body>Represents a single Fitnesse table. Rows are held in a collection.  Contrast with TableOnParse, which provides the same interface in the Java version, but wraps the Fit.Parse data structure.  See the TableConversion comment for more information.</body></comment><class><name>SetUpTearDown</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceCounter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SetUpTearDown</class-id><body>Send #setUp and #tearDown to the full System Under Test chain of an object as necessary.Instance Variables	referenceCounter	&lt;SetUpTearDownReferenceCounter&gt;	Helper that tracks objects, so that we can send messages at the appropriate time.</body></comment><class><name>SimpleParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adapter evaluator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SimpleParser</class-id><body>A Parser that uses the Fit-style TypeAdapter parsing mechanism to convert cell text into objects and vice versa.This class doesn't exist in the Java implementation, but does approximately the same job as PropertyEditorBasedParser.Instance Variables	adapter	&lt;TypeAdapter&gt;	The Fit TypeAdapter used to do the parsing.</body></comment><class><name>DoActionCaller</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDoCaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodName target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DoActionCaller</class-id><body>A DoFixture action that looks up and invokes a method as specified by the test table.</body></comment><class><name>PositionedTarget</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>innerFrom innerTo sequencing specialName specialTarget methodSpec innerTarget innerTargetMissingMessage innerName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.PositionedTarget</class-id><body>A special action method target that knows where in the table row it was found.Instance Variables	innerFrom	&lt;Integer&gt;	The first cell of the method to check against the special action.	innerTarget	&lt;CalledMethodTarget&gt;	The method to check against the special action.	innerTargetMissingMessage	&lt;String&gt;	The message to show if the inner target method cannot be found.	innerTo	&lt;Integer&gt;	The last cell of the method to check against the special action.	methodSpec	&lt;MethodSpec&gt;	The specification of the inner method to call.	sequencing	&lt;Boolean&gt;	True if using sequence mode; false if do mode.	specialName	&lt;String&gt;	The name of the special action method.	specialTarget	&lt;CalledMethodTarget&gt;	The special action method to call.</body></comment><class><name>ListTreeError</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.ListTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ListTreeError</class-id><body>A ListTree that represents an error condition.</body></comment><class><name>FoldingTexts</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>folds useOldMarkup </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FoldingTexts</class-id><body>Accumulates messages to be added to the end of a table or test page.Instance Variables	folds	&lt;Dictionary&gt;	The accumulated messages, keyed by their titles.</body></comment><class><name>Cell</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Tables</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullText cellIsInHiddenRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Cell</class-id><body>Represents a cell in a Fitnesse table. Nested tables are held in a collection.  Contrast with CellOnParse, which provides the same interface in the Java version, but wraps the Fit.Parse data structure.  See the TableConversion comment for more information.Instance Variables	fullText	&lt;String&gt;	The full, unescaped contents of the cell.</body></comment><class><name>TablesParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TablesParser</class-id><body>A Parser for working with cells that contain multiple nested tables,</body></comment><class><name>SetUpTearDownCaller</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>row testResults setUpTearDown </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SetUpTearDownCaller</class-id><body>Helper class for sending #setUp, #onFailure, and #tearDown to a fixturing class when appropriate.Instance Variables	row	&lt;Row&gt;	The row being processed.	testResults	&lt;TestResults&gt;	The accumulated test results.</body></comment><class><name>DomainObjectParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluator adapter finder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DomainObjectParser</class-id><body>A parser for parsing domain objects in tables.Instance Variables	adapter	&lt;TypeAdapter&gt;	The type of the object to parse.	evaluator	&lt;TraverseBase&gt;	The object that is evaluating the table.</body></comment><class><name>NotSubclassFromClassFactoryMethod</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NotSubclassFromClassFactoryMethod</class-id><body>An error raised when a #concreteClass* method returns a class which is not a subclass of the desired abstract class.</body></comment><class><name>SetUpTearDownReferenceCounter</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceCounts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SetUpTearDownReferenceCounter</class-id><body>Ensures that an object has its #setUp method sent once when it's first added and has its #tearDown method sent once when it's last removed.This allows for objects that are referenced several times, such as through the "calculate" action.Instance Variables	referenceCounts	&lt;Dictionary&gt;	The reference counts for the objects being tracked.</body></comment><class><name>DelegateObjectSuperParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDelegateObjectParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DelegateObjectSuperParser</class-id><body>Delegate parsing, matching, and showing of a class or any of its subclasses to another object.</body></comment><class><name>NoNullaryConstructor</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NoNullaryConstructor</class-id><body>An error that is raised when a #new method sends #shouldNotImplement.</body></comment><class><name>SpecifyErrorReport</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showAfter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.SpecifyErrorReport</class-id><body>Reports SpecifyFixture errors in an "after table".Instance Variables	showAfter	&lt;Traverse&gt;	The Traverse that knows how to display the "after table".</body></comment><class><name>ArrayParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentParser runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ArrayParser</class-id><body>A Parser that handles cells containing arrays of primitives or nested arrays.Instance Variables	componentParser	&lt;Parser&gt;	The Parser for parsing the elements of the array.</body></comment><class><name>AmbiguousActionException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.AmbiguousActionException</class-id><body>An Error that is raised when FitLibrary can't distinguish between two or more ambiguous actions in a table row.</body></comment><class><name>StringMatchStats</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>same sameButTwo longestMatch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.StringMatchStats</class-id><body>Accumulate information about matching segments of two strings.  Report the quality of the overall match.Instance Variables	longestMatch	&lt;Integer&gt;	The longest matching subsequence.	same	&lt;Integer&gt;	The total number of matching characters.	sameButTwo	&lt;Integer&gt;	The number of short (&lt;=2) matching segments.</body></comment><class><name>ActionSpecial</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDoCaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluator positionedTargets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ActionSpecial</class-id><body>A DoCaller that runs more flexible special do actions..Instance Variables	evaluator	&lt;Traverse&gt;	The evaluator processing the table.	positionedTargets	&lt;(SequenceableCollection of: PositionedTarget)&gt;	Potential target methods along with their positions in the table.</body></comment><class><name>ShowAfterTableAppender</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ShowAfterTableAppender</class-id><body>A log appender that shows the log information in a separate table after the test table.Instance Variables	runtimeContext	&lt;RuntimeContextContainer&gt;	The runtime context of the current test run.</body></comment><class><name>CycleException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryExceptionWithHelp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.CycleException</class-id><body>Raised when a cycle is detected in a system-under-test chain.</body></comment><class><name>ExtraCellsException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryExceptionWithHelp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ExtraCellsException</class-id><body>An error that is raised when a table has more cells in a row than expected/required.</body></comment><class><name>FailingDelegateParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.FailingDelegateParser</class-id><body>A DelegateParser that reports a CouldNotParseException when parsing.Instance Variables	type	&lt;Class&gt;	The class to be parsed.</body></comment><class><name>ClassMethodTarget</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType evaluator actualType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ClassMethodTarget</class-id><body>A method target that looks up class factory methods.</body></comment><class><name>RelativeFileHandler</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractFileHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.RelativeFileHandler</class-id><body>Fixturing support for working with relative files from test tables.</body></comment><class><name>CellProxy</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cell testResultsBlock variableResolver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.CellProxy</class-id><body>A proxy of a Cell that can access the currently active test results. Messages are forwarded on to the proxied cell along with the latest test results.Instance Variables	cell	&lt;CellOnList&gt;	 The cell being proxied.	testResultsBlock	&lt;BlockClosure&gt;	A block that provides access to the currently active test results.</body></comment><class><name>NestedTableExpectedException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NestedTableExpectedException</class-id><body>Raised when we expect to see nested tables but there are none.</body></comment><class><name>NestedTable</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NestedTable</class-id><body>A table that is nested within a cell of an outer table.Instance Variables	parse	&lt;Parse&gt;	The Parse representing the nested table contents.</body></comment><class><name>PostFixSpecialCaller</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.AbstractDoCaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodName specialMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.PostFixSpecialCaller</class-id><body>A DoFixture action that looks up and invokes a special do-action as specified by the test table.  Postfix actions come between the method call and the expected result, rather than in the first cell of the table as with a SpecialCaller.Instance Variables	methodName	&lt;String&gt;	The name of the special method.	specialMethod	&lt;MethodClosure&gt;	The special action method.</body></comment><class><name>TableParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.HtmlParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TableParser</class-id><body>A Parser for working with nested tables.</body></comment><class><name>TypeAdapterParserBridge</name><environment>FitlibraryInternals</environment><super>Fit.TypeAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parserBlock componentAdapters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TypeAdapterParserBridge</class-id><body>A basic TypeAdapter for FitLibrary.  It provides a bridge from the method signature definitions to the new-in-FitLibrary2 Parser hierarchy in FitLibrary.Instance Variables	parser	&lt;Parser&gt;	The Parser to use.</body></comment><class><name>DefineActionsOnPage</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.DefineActionsOnPageSlowly</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootLocation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.DefineActionsOnPage</class-id><body>Create defined actions from a wiki page by accessing the page text directly from the file system.Instance Variables	rootLocation	&lt;String&gt;	The name of the Fitnesse root directory.</body></comment><class><name>ExtendedCamelCase</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.ExtendedCamelCase</class-id><body>A utility class for converting strings of any character in a test table into camelCase method names.</body></comment><class><name>PassFail</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasPassed result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.PassFail</class-id><body>A helper object that hangs onto the results of an Eventually operation.Instance Variables	hasPassed	&lt;Boolean&gt;	Whether or not the action has passed.	result	&lt;Object&gt;	The resulting object.</body></comment><class><name>Eventually</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeout start sleepPeriod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.Eventually</class-id><body>A helper object that polls a special action, waiting up to a given timeout for it to pass.Instance Variables	sleepPeriod	&lt;Number&gt;	The number of milliseconds to sleep between polls.	start	&lt;Number&gt;	The start time in milliseconds.	timeout	&lt;Integer&gt;	The timeout in milliseconds.</body></comment><class><name>VoidMethodException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryExceptionWithHelp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.VoidMethodException</class-id><body>An error raised when a method returning Void is used in a CalculateFixture.</body></comment><class><name>TableConversion</name><environment>FitlibraryInternals</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TableConversion</class-id><body>Utility class for converting from TableElementOnParse + subclasses to TableElementOnList + subclasses and vice versa.Until something forces us to change, the Smalltalk implementation uses TableElementOnList exclusively, converting only when necessary.  As a result, TableElementOnParse and subclasses do not implement the full API that TableElementOnList does.</body></comment><class><name>TaggedStringParser</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.HtmlParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.TaggedStringParser</class-id><body>A Parser for handling TaggedStrings.</body></comment><class><name>NoSystemUnderTestException</name><environment>FitlibraryInternals</environment><super>FitlibraryInternals.FitLibraryException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>FitLibrary-Internals</package></attributes></class><comment><class-id>FitlibraryInternals.NoSystemUnderTestException</class-id><body>An error that is raised when there should be a system under test defined, but isn't.</body></comment><shared-variable><name>Replacements</name><environment>FitlibraryInternals.ExtendedCamelCase</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>FitLibrary-Internals</package></attributes></shared-variable><shared-variable><name>FitnesseDirectory</name><environment>FitlibraryInternals.DefineActionsOnPageSlowly</environment><private>false</private><constant>false</constant><category>directory</category><attributes><package>FitLibrary-Internals</package></attributes></shared-variable><shared-variable><name>Cache</name><environment>FitlibraryInternals.FitLibrarySelectors</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>FitLibrary-Internals</package></attributes></shared-variable><shared-variable><name>NextId</name><environment>FitlibraryInternals.FoldingTexts</environment><private>false</private><constant>false</constant><category>ids</category><attributes><package>FitLibrary-Internals</package></attributes></shared-variable><shared-variable><name>UseOldMarkup</name><environment>FitlibraryInternals.FoldingTexts</environment><private>false</private><constant>false</constant><category>options</category><initializer>false</initializer><attributes><package>FitLibrary-Internals</package></attributes></shared-variable><shared-variable><name>ParseDelegates</name><environment>FitlibraryInternals.ParseDelegation</environment><private>false</private><constant>false</constant><category>delegates</category><attributes><package>FitLibrary-Internals</package></attributes></shared-variable><shared-variable><name>SuperParseDelegates</name><environment>FitlibraryInternals.ParseDelegation</environment><private>false</private><constant>false</constant><category>delegates</category><attributes><package>FitLibrary-Internals</package></attributes></shared-variable><methods><class-id>FitlibraryInternals.TableElementOnParse</class-id> <category>accessing</category><body package="FitLibrary-Internals">leader	parse ifNil: [^''].	^parse leader ifNil: ['']</body><body package="FitLibrary-Internals">leader: aString	parse leader: aString</body><body package="FitLibrary-Internals">parse	^parse</body><body package="FitLibrary-Internals">tag	| tag index |	tag := parse tag.	index := tag indexOf: Character space.	index isZero ifTrue: [^tag copyFrom: 2 to: tag size - 1].	^tag copyFrom: 2 to: index - 1</body><body package="FitLibrary-Internals">tagLine	| tag index |	parse ifNil: [^''].	tag := parse tag.	index := tag indexOf: Character space.	index isZero ifTrue: [^''].	^tag copyFrom: index + 1 to: tag size - 1</body><body package="FitLibrary-Internals">tagLine: aString	parse		tag: '&lt;' , self tag				, (aString isEmpty ifTrue: [''] ifFalse: [' ' , aString]) , '&gt;'</body><body package="FitLibrary-Internals">trailer	parse ifNil: [^''].	^parse trailer ifNil: ['']</body><body package="FitLibrary-Internals">trailer: aString	parse trailer: aString</body></methods><methods><class-id>FitlibraryInternals.TableElementOnParse</class-id> <category>enumeration</category><body package="FitLibrary-Internals">do: aBlock	self iterating: parse parts do: aBlock</body><body package="FitLibrary-Internals">iterating: aParse do: aBlock	aParse ifNil: [^self].	aParse do: [:each | aBlock value: (self class elementClass parse: each)]</body></methods><methods><class-id>FitlibraryInternals.TableElementOnParse</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">parse: aParse	parse := aParse</body></methods><methods><class-id>FitlibraryInternals.TableElementOnParse</class-id> <category>converting</category><body package="FitLibrary-Internals">asParse	^parse</body></methods><methods><class-id>FitlibraryInternals.TableElementOnParse class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">parse: aParse	"Use basicNew here to avoid infinite recursion with default subclass instance creation methods"	^self basicNew parse: aParse</body></methods><methods><class-id>FitlibraryInternals.TableElementOnParse class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.TableOnParse</class-id> <category>adding</category><body package="FitLibrary-Internals">add: aRow	parse parts ifNil: [parse parts: aRow parse] ifNotNil: [parse parts last more: aRow parse]</body></methods><methods><class-id>FitlibraryInternals.TableOnParse</class-id> <category>converting</category><body package="FitLibrary-Internals">asTableOnList	^TableConversion convertTable: self to: Table</body></methods><methods><class-id>FitlibraryInternals.TableOnParse class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^RowOnParse</body></methods><methods><class-id>FitlibraryInternals.TableOnParse class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	| parse |	parse := Parse tag: 'table' body: ''.	parse addToTag: ' border="1" cellspacing = "0"'.	^self parse: parse</body></methods><methods><class-id>FitlibraryInternals.IgnoredException</class-id> <category>printing</category><body package="FitLibrary-Internals">description	^'Ignored: ' , ignoredError errorString</body></methods><methods><class-id>FitlibraryInternals.IgnoredException</class-id> <category>accessing</category><body package="FitLibrary-Internals">ignoredError	^ignoredError</body></methods><methods><class-id>FitlibraryInternals.IgnoredException</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setIgnoredError: anError	ignoredError := anError</body></methods><methods><class-id>FitlibraryInternals.IgnoredException</class-id> <category>fitLibrary</category><body package="FitLibrary-Internals">fitLibraryExceptionMessage	^''</body></methods><methods><class-id>FitlibraryInternals.IgnoredException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">on: anError	^self new setIgnoredError: anError</body></methods><methods><class-id>FitlibraryInternals.AbstractDoCaller</class-id> <category>testing</category><body package="FitLibrary-Internals">isAmbiguous	^false</body><body package="FitLibrary-Internals">isPartiallyValid	^false</body><body package="FitLibrary-Internals">isProblem	^problem notNil</body><body package="FitLibrary-Internals">isValid	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.AbstractDoCaller</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^self subclassResponsibility</body><body package="FitLibrary-Internals">partialErrorMessage	^'NOT AN ERROR'</body><body package="FitLibrary-Internals">problem	^problem</body><body package="FitLibrary-Internals">problem: anError	problem := anError</body></methods><methods><class-id>FitlibraryInternals.AbstractDoCaller</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.MultiDefinedActionCaller</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRow: aRow runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext.	furtherRows := runtimeContext hasRowsAfter: aRow.	methodName := aRow resolvedTextAt: 1				resolver: runtimeContext variableResolver.	multiParameterSubstitution := TemporaryPlugBoardForRuntime				definedActionsRepository lookupMulti: methodName</body></methods><methods><class-id>FitlibraryInternals.MultiDefinedActionCaller</class-id> <category>testing</category><body package="FitLibrary-Internals">isValid	^furtherRows and: [multiParameterSubstitution notNil]</body></methods><methods><class-id>FitlibraryInternals.MultiDefinedActionCaller</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^'multi defined action ' , methodName</body></methods><methods><class-id>FitlibraryInternals.MultiDefinedActionCaller</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	^(MultiDefinedActionRunnerTraverse binder: multiParameterSubstitution		runtimeContext: runtimeContext) asFitLibraryTypedObject</body></methods><methods><class-id>FitlibraryInternals.MultiDefinedActionCaller class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">row: aRow runtimeContext: aRuntimeContext	^self new setRow: aRow runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.TypedObject</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setSubject: anObject typeAdapter: aTypeAdapter	subject := anObject.	typeAdapter := aTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.TypedObject</class-id> <category>testing</category><body package="FitLibrary-Internals">hasTypedSystemUnderTest	^(subject respondsTo: #systemUnderTest)		and: [subject systemUnderTest notNil]</body><body package="FitLibrary-Internals">isNull	^subject isNil</body></methods><methods><class-id>FitlibraryInternals.TypedObject</class-id> <category>runtime</category><body package="FitLibrary-Internals">injectRuntime: aRuntimeContext	(subject respondsTo: #runtimeContext:)		ifTrue: [subject runtimeContext: aRuntimeContext].	self hasTypedSystemUnderTest		ifTrue: [self typedSystemUnderTest injectRuntime: aRuntimeContext]</body></methods><methods><class-id>FitlibraryInternals.TypedObject</class-id> <category>accessing</category><body package="FitLibrary-Internals">classType	^typeAdapter type</body><body package="FitLibrary-Internals">subject	^subject</body><body package="FitLibrary-Internals">traverse: anEvaluator	^(typeAdapter parameterParser: anEvaluator) traverseFor: self</body><body package="FitLibrary-Internals">typeAdapter	^typeAdapter</body><body package="FitLibrary-Internals">typedSystemUnderTest	(subject respondsTo: #typedSystemUnderTest)		ifTrue: [subject typedSystemUnderTest].	(subject respondsTo: #systemUnderTest)		ifTrue: [^self class subject: subject systemUnderTest].	^self error: 'No SUT'</body></methods><methods><class-id>FitlibraryInternals.TypedObject</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">asFitLibraryTypedObject	^self</body><body package="FitLibrary-Internals">autoWrapped: anEvaluator	| wrapped |	subject ifNil: [^self].	wrapped := subject fitLibraryAutoWrappedFor: self evaluator: anEvaluator.	^self == wrapped ifTrue: [self] ifFalse: [self class subject: wrapped]</body></methods><methods><class-id>FitlibraryInternals.TypedObject</class-id> <category>private</category><body package="FitLibrary-Internals">addNullaryActionNamed: aSymbol inCells: cellsCollection to: targetsCollection factory: aBlock runtimeContext: aRuntimeContext	| method from to |	((MethodSpec		baseName: cellsCollection first		numArgs: aSymbol numArgs		runtimeContext: aRuntimeContext) matchesSelector: aSymbol)		ifTrue: 			[from := 2.			to := cellsCollection size]		ifFalse: 			[((MethodSpec				baseName: cellsCollection last				numArgs: aSymbol numArgs				runtimeContext: aRuntimeContext) matchesSelector: aSymbol)				ifTrue: 					[from := 1.					to := cellsCollection size - 1]				ifFalse: [^self]].	method := (subject class findSelector: aSymbol) last.	targetsCollection add: (aBlock value: method value: from value: to)</body><body package="FitLibrary-Internals">addPostfixActionNamed: aSymbol inCells: cellsCollection to: targetsCollection factory: aBlock runtimeContext: aRuntimeContext	| methodSpec start method |	methodSpec := MethodSpec numArgs: aSymbol numArgs				runtimeContext: aRuntimeContext.	start := cellsCollection size - (2 * aSymbol numArgs) + 3.	start to: start + aSymbol numArgs - 2		by: 2		do: [:index | methodSpec addSegment: (cellsCollection at: index)].	(methodSpec matchesSelector: aSymbol)		ifTrue: 			[method := (subject class findSelector: aSymbol) last.			targetsCollection add: (aBlock						value: method						value: 1						value: start - 1)]</body><body package="FitLibrary-Internals">addPrefixActionNamed: aSymbol inCells: cellsCollection to: targetsCollection factory: aBlock runtimeContext: aRuntimeContext	| methodSpec start method |	methodSpec := MethodSpec numArgs: aSymbol numArgs				runtimeContext: aRuntimeContext.	start := 1.	start to: start + aSymbol numArgs - 2		by: 2		do: [:index | methodSpec addSegment: (cellsCollection at: index)].	(methodSpec matchesSelector: aSymbol)		ifTrue: 			[method := (subject class findSelector: aSymbol) last.			targetsCollection add: (aBlock						value: method						value: aSymbol numArgs * 2 - 1						value: cellsCollection size)]</body></methods><methods><class-id>FitlibraryInternals.TypedObject</class-id> <category>finding</category><body package="FitLibrary-Internals">add: aSelector ifActionSpecialMethodFrom: cellCollection factoryBlock: aBlock into: actionCollection runtimeContext: aRuntimeContext	| paramCount signature |	signature := (MethodSignature forSelector: aSelector in: subject)				ifNil: [^self].	paramCount := signature numArgs.	^(paramCount &gt; 0 and: [cellCollection size &gt; paramCount])		ifTrue: 			[signature isNullary				ifTrue: 					[self						addNullaryActionNamed: aSelector						inCells: cellCollection						to: actionCollection						factory: aBlock						runtimeContext: aRuntimeContext]				ifFalse: 					[signature isPostfix						ifTrue: 							[self								addPostfixActionNamed: aSelector								inCells: cellCollection								to: actionCollection								factory: aBlock								runtimeContext: aRuntimeContext]						ifFalse: 							[signature isPrefix								ifTrue: 									[self										addPrefixActionNamed: aSelector										inCells: cellCollection										to: actionCollection										factory: aBlock										runtimeContext: aRuntimeContext]]]]</body><body package="FitLibrary-Internals">findActionSpecialMethodsFrom: aCollection factoryBlock: aBlock runtimeContext: aRuntimeContext	| list |	list := OrderedCollection new.	FitLibrarySelectors subject: subject		selectorsDo: 			[:each |			self				add: each				ifActionSpecialMethodFrom: aCollection				factoryBlock: aBlock				into: list				runtimeContext: aRuntimeContext].	^list</body></methods><methods><class-id>FitlibraryInternals.TypedObject class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">null	^self subject: nil</body><body package="FitLibrary-Internals">subject: anObject	^self subject: anObject		typeAdapter: (TypeAdapter adapterFor: anObject class)</body><body package="FitLibrary-Internals">subject: anObject typeAdapter: aTypeAdapter	^self new setSubject: anObject typeAdapter: aTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCaller</class-id> <category>private</category><body package="FitLibrary-Internals">actualArgsIn: aRow	^self actualArgsIn: aRow into: OrderedCollection new</body><body package="FitLibrary-Internals">actualArgsIn: aRow into: aCollection	2 to: aRow size		by: 2		do: 			[:index |			| cell |			cell := aRow at: index.			(cell hasEmbeddedTables: runtimeContext variableResolver)				ifTrue: [aCollection add: cell embeddedTables]				ifFalse: 					[aCollection add: (cell resolvedText: runtimeContext variableResolver)]].	^aCollection</body><body package="FitLibrary-Internals">colourRowInReport: aRow subResults: subTestResults resultsInto: aTestResults	(runtimeContext shouldExpandDefinedActions		or: [subTestResults hasProblems])			ifTrue: 				[(runtimeContext isAbandoned: aTestResults)					ifFalse: 						[subTestResults hasPassed							ifTrue: [aRow passKeywords: aTestResults]							ifFalse: 								[subTestResults hasErrors									ifTrue: 										[aRow everySecondDo: 												[:each |												each error: (FitLibraryException messageText: ' ')													resultsInto: aTestResults]]									ifFalse: 										[subTestResults hasFailed											ifTrue: [aRow everySecondDo: [:each | each fail: aTestResults]]											ifFalse: [aRow everySecondDo: [:each | each ignore: aTestResults]]]]]]			ifFalse: 				[(runtimeContext isAbandoned: aTestResults)					ifFalse: [aRow passKeywords: aTestResults]]</body><body package="FitLibrary-Internals">link: aString	^self class link: aString</body><body package="FitLibrary-Internals">lookupByClass	(runtimeContext dynamicVariableAt: 'this')		ifNotNil: 			[:objectName |			| className |			className := runtimeContext						dynamicVariableAt: objectName fitToString , '.class'.			actualArgs addFirst: objectName fitToString.			(className notNil and: [className notEmpty])				ifTrue: 					[binder := self repository								lookupByClass: className fitToString								byCamelName: methodName								argumentCount: actualArgs size - 1								runtimeContext: runtimeContext]]</body><body package="FitLibrary-Internals">processDefinedAction: aTables row: aRow resultsInto: aTestResults	| subTestResults tableEvaluator |	subTestResults := TestResults new.	tableEvaluator := runtimeContext tableEvaluator.	tableEvaluator runInnerTables: aTables resultsInto: subTestResults.	self		colourRowInReport: aRow		subResults: subTestResults		resultsInto: aTestResults.	(runtimeContext shouldExpandDefinedActions or: 			[subTestResults hasProblems or: [runtimeContext isAbandoned: aTestResults]])		ifTrue: 			[| cell |			cell := Cell withTables: aTables.			cell first				leader: (Markup label: (self link: binder pageName)) , cell first leader.			cell calls.			aRow add: cell]</body><body package="FitLibrary-Internals">repository	^TemporaryPlugBoardForRuntime definedActionsRepository</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCaller</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^'defined action ' , methodName</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCaller</class-id> <category>testing</category><body package="FitLibrary-Internals">isValid	^binder notNil</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCaller</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setObject: nameString className: classNameString setRow: aRow runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext.	methodName := aRow methodNameForCamel: runtimeContext.	actualArgs := OrderedCollection with: nameString.	self actualArgsIn: aRow into: actualArgs.	binder := self repository				lookupByClass: classNameString				byCamelName: methodName				argumentCount: actualArgs size - 1				runtimeContext: aRuntimeContext.	binder		ifNil: 			[^FitLibraryException				raiseErrorString: 'Unknown defined action for object of class '						, classNameString]</body><body package="FitLibrary-Internals">setRow: aRow runtimeContext: aRuntimeContext	runtimeContext := aRuntimeContext.	methodName := aRow methodNameForCamel: runtimeContext.	actualArgs := self actualArgsIn: aRow.	binder := self repository lookupByCamelName: methodName				argumentCount: actualArgs size.	binder ifNil: [self lookupByClass]</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCaller</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	| definedActionCallManager |	definedActionCallManager := runtimeContext definedActionCallManager.	definedActionCallManager startCall: binder.	runtimeContext pushLocalDynamicVariables.		[| oldThisValue |	oldThisValue := runtimeContext dynamicVariableAt: 'this'.	actualArgs isEmpty		ifFalse: [runtimeContext dynamicVariableAt: 'this' put: actualArgs first].	binder bindUni: actualArgs into: runtimeContext dynamicVariables.	self		processDefinedAction: binder copyOfBody		row: aRow		resultsInto: aTestResults.	runtimeContext dynamicVariableAt: 'this' put: oldThisValue]			ensure: 				[definedActionCallManager endCall: binder.				runtimeContext popLocalDynamicVariables].	(runtimeContext shouldExpandDefinedActions not and: 			[definedActionCallManager readyToShow				and: [(runtimeContext isAbandoned: aTestResults) not]])		ifTrue: 			[aRow add: (Cell						withTables: (Tables withTable: definedActionCallManager showsTable))].	^TypedObject null</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCaller class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">object: nameString className: classNameString row: aRow runtimeContext: aRuntimeContext	^self new		setObject: nameString		className: classNameString		setRow: aRow		runtimeContext: aRuntimeContext</body><body package="FitLibrary-Internals">row: aRow runtimeContext: aRuntimeContext	^self new setRow: aRow runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCaller class</class-id> <category>markup</category><body package="FitLibrary-Internals">link2: aString	^aString = DefineAction storytestBased		ifTrue: ['storytest']		ifFalse: ['&lt;a href=''' , aString , '''&gt;.' , aString , '&lt;/a&gt;:']</body><body package="FitLibrary-Internals">link: aString	^aString = DefineAction storytestBased		ifTrue: ['Defined action call:']		ifFalse: 			['Defined action call &lt;a href=''' , aString , '''&gt;.' , aString , '&lt;/a&gt;:']</body></methods><methods><class-id>FitlibraryInternals.DelegateParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	anObject ifNil: [^'null'].	^anObject fitToString</body></methods><methods><class-id>FitlibraryInternals.DelegateParser</class-id> <category>comparing</category><body package="FitLibrary-Internals">expected: expectedObject matches: actualObject	^expectedObject = actualObject</body></methods><methods><class-id>FitlibraryInternals.DelegateParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.DelegateParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">parser: anEvaluator type: aTypeAdapter	^DelegatingParser		delegateParser: self copy		evaluator: anEvaluator		type: aTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.AbstractDelegateObjectParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setDelegate: anObject	delegate := anObject.	matchesMethod := (delegate class findSelector: #expected:matches:)				ifNotNil: #last.	showMethod := (delegate class findSelector: #show:) ifNotNil: #last</body></methods><methods><class-id>FitlibraryInternals.AbstractDelegateObjectParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	[showMethod ifNotNil: [^delegate performMethod: showMethod with: anObject]]		on: Error		do: [:ex | ].	^super show: anObject</body></methods><methods><class-id>FitlibraryInternals.AbstractDelegateObjectParser</class-id> <category>comparing</category><body package="FitLibrary-Internals">expected: expectedObject matches: actualObject		[matchesMethod		ifNotNil: 			[^delegate				performMethod: matchesMethod				with: expectedObject				with: actualObject]]			on: Error			do: [:ex | ].	^super expected: expectedObject matches: actualObject</body></methods><methods><class-id>FitlibraryInternals.AbstractDelegateObjectParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">delegate: anObject	^self new setDelegate: anObject</body></methods><methods><class-id>FitlibraryInternals.DelegateObjectParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^delegate performMethod: parseMethod with: aString</body></methods><methods><class-id>FitlibraryInternals.DelegateObjectParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setDelegate: anObject	super setDelegate: anObject.	parseMethod := (delegate class findSelector: #fitParse:)				ifNil: [^(Fit.Exceptions.NoSuchMethodException named: 'fitParse:') raise]				ifNotNil: #last</body></methods><methods><class-id>FitlibraryInternals.MethodClosure</class-id> <category>accessing</category><body package="FitLibrary-Internals">owningClass	^object class</body><body package="FitLibrary-Internals">parameterParsers: anEvaluator	^self parameterTypes collect: [:each | each parameterParser: anEvaluator]</body><body package="FitLibrary-Internals">parameterTypes	^signature parameterAdapters</body><body package="FitLibrary-Internals">resultParser: anEvaluator	^self resultParser: anEvaluator forType: self returnType</body><body package="FitLibrary-Internals">returnType	^signature resultAdapter</body><body package="FitLibrary-Internals">selector	^method selector</body><body package="FitLibrary-Internals">specialisedResultParserFrom: aParser result: anObject evaluator: anEvaluator	(anObject isNil or: [anObject class == self returnType type])		ifTrue: [^aParser].	^self resultParser: anEvaluator		forType: (TypeAdapter adapterFor: anObject class)</body><body package="FitLibrary-Internals">subject: anObject	object := anObject</body></methods><methods><class-id>FitlibraryInternals.MethodClosure</class-id> <category>testing</category><body package="FitLibrary-Internals">returns: aClass	^signature returns: aClass</body><body package="FitLibrary-Internals">takes: aCollection	^signature takes: aCollection</body><body package="FitLibrary-Internals">takesOne: aClass	^signature takesOne: aClass</body></methods><methods><class-id>FitlibraryInternals.MethodClosure</class-id> <category>invoking</category><body package="FitLibrary-Internals">invoke	^self invokeOnArguments: #()</body><body package="FitLibrary-Internals">invokeOnArguments: aCollection	"Return nil in the case of an implicit ^self on the invoked method to simulate a void method in Java.	Otherwise, the returned object gets added to the ScopeStack, which can cause later problems.	If a method needs to return self  for real, use ExplicitSelf instead."	| result |	result := object performMethod: method arguments: aCollection.	(result isKindOf: ExplicitSelf) ifTrue: [^result actualSelf].	result == object ifTrue: [^nil].	^result</body><body package="FitLibrary-Internals">invokeTypedOnArguments: aCollection	^TypedObject subject: (self invokeOnArguments: aCollection)		typeAdapter: signature resultAdapter</body></methods><methods><class-id>FitlibraryInternals.MethodClosure</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setMethod: aCompiledMethod object: anObject signature: aMethodSignature	object := anObject.	method := aCompiledMethod.	signature := aMethodSignature</body></methods><methods><class-id>FitlibraryInternals.MethodClosure</class-id> <category>private</category><body package="FitLibrary-Internals">resultParser: anEvaluator forType: aTypeAdapter	| resultParser |	resultParser := aTypeAdapter				ifNil: [NullParser new]				ifNotNil: [aTypeAdapter resultParser: anEvaluator].	^GetterParser parser: resultParser method: method</body></methods><methods><class-id>FitlibraryInternals.MethodClosure class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">forMethod: aCompiledMethod on: anObject	^self		forMethod: aCompiledMethod		on: anObject		signature: (MethodSignature forSelector: aCompiledMethod selector				in: anObject)</body><body package="FitLibrary-Internals">forMethod: aCompiledMethod on: anObject signature: aMethodSignature	^self new		setMethod: aCompiledMethod		object: anObject		signature: aMethodSignature</body></methods><methods><class-id>FitlibraryInternals.TemporaryPlugBoardForRuntime class</class-id> <category>accessing</category><body package="FitLibrary-Internals">definedActionsRepository	| processEnvironment |	processEnvironment := Processor activeProcess environment.	^processEnvironment at: #definedActions		ifAbsent: 			[processEnvironment at: #definedActions				put: DefinedActionsRepositoryStandard new]</body></methods><methods><class-id>FitlibraryInternals.Filter</class-id> <category>comparing</category><body package="FitLibrary-Internals">matchActual: actualString expected: expectedString	| startExpected startActual |	startExpected := expectedString findString: startLabel startingAt: 1.	startActual := actualString findString: startLabel startingAt: 1.	(startExpected isZero and: [startActual isZero])		ifTrue: [^downstream matchActual: actualString expected: expectedString].	startExpected isZero = startActual isZero ifFalse: [^false].	(downstream matchActual: (actualString copyFrom: 1 to: startActual - 1)		expected: (expectedString copyFrom: 1 to: startExpected - 1))			ifFalse: [^false].	^self matchAfterPrefixActual: (actualString				copyFrom: startActual + startLabel size				to: actualString size)		expected: (expectedString copyFrom: startExpected + startLabel size				to: expectedString size)</body></methods><methods><class-id>FitlibraryInternals.Filter</class-id> <category>private</category><body package="FitLibrary-Internals">matchAfterPrefixActual: actualString expected: expectedString	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.Filter</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setDownstream: aFilter startLabel: aString	downstream := aFilter.	startLabel := aString</body></methods><methods><class-id>FitlibraryInternals.Filter class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">downstream: aFilter startLabel: aString	^self new setDownstream: aFilter startLabel: aString</body></methods><methods><class-id>FitlibraryInternals.StackTraceFilter</class-id> <category>private</category><body package="FitLibrary-Internals">matchAfterPrefixActual: actualString expected: expectedString	"Ignore the details of the stacktrace"	^true</body></methods><methods><class-id>FitlibraryInternals.StackTraceFilter class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">downstream: aFilter	^self downstream: aFilter startLabel: 'class="fit_stacktrace"&gt;'</body></methods><methods><class-id>FitlibraryInternals.Tree</class-id> <category>accessing</category><body package="FitLibrary-Internals">children	^self subclassResponsibility</body><body package="FitLibrary-Internals">rawText	^self subclassResponsibility</body><body package="FitLibrary-Internals">text	^self subclassResponsibility</body><body package="FitLibrary-Internals">title	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.Tree</class-id> <category>comparing</category><body package="FitLibrary-Internals">= anObject	self == anObject ifTrue: [^true].	(anObject isKindOf: Tree) ifFalse: [^false].	self rawText = anObject rawText ifFalse: [^false].	self children size = anObject children size ifFalse: [^false].	self children with: anObject children		do: [:tree1 :tree2 | tree1 = tree2 ifFalse: [^false]].	^true</body></methods><methods><class-id>FitlibraryInternals.Tree class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">parseTree: aTree	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.Tree class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitTypeAdapter	^TypeAdapterParserBridge type: self		parserBlock: [TreeParser forClass: self]</body></methods><methods><class-id>FitlibraryInternals.AbstractFileHandler</class-id> <category>accessing</category><body package="FitLibrary-Internals">systemUnderTest	^file</body></methods><methods><class-id>FitlibraryInternals.AbstractFileHandler</class-id> <category>private</category><body package="FitLibrary-Internals">write: aString to: aStream	[aStream nextPutAll: aString] ensure: [aStream close]</body></methods><methods><class-id>FitlibraryInternals.AbstractFileHandler</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">fileNameIs: aString	^self subclassResponsibility</body><body package="FitLibrary-Internals">setFilename: aString	self fileNameIs: aString</body></methods><methods><class-id>FitlibraryInternals.AbstractFileHandler class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">filename: aString	^self new setFilename: aString</body></methods><methods><class-id>FitlibraryInternals.FileHandler</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">fileNameIs: aString	file := aString asFilename</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>showing</category><body package="FitLibrary-Internals">showAsAfterTableTitle: titleString contents: contentsString	runtime showAsAfterTableTitle: titleString contents: contentsString</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>accessing</category><body package="FitLibrary-Internals">fitVariableAt: aString put: anObject	Fixture symbolAt: aString put: anObject</body><body package="FitLibrary-Internals">runtimeContext: aRuntimeContext	runtime := aRuntimeContext</body><body package="FitLibrary-Internals">systemUnderTest	^nil</body><body package="FitLibrary-Internals">timeoutAt: aString	^runtime timeoutAt: aString ifAbsent: [1000]</body><body package="FitLibrary-Internals">timeoutAt: aString put: anInteger	runtime timeoutAt: aString put: anInteger</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>private</category><body package="FitLibrary-Internals">actualGroups: anInteger	^anInteger = 1		ifTrue: ['is only 1']		ifFalse: ['are only ' , anInteger printString]</body><body package="FitLibrary-Internals">compareAction: aDoAction expected: anObject using: aSymbol	| actual cell |	(anObject respondsTo: aSymbol)		ifFalse: 			[^FitLibraryException				raiseErrorString: 'Expected value does not support comparisons'].	actual := aDoAction run.	actual		ifNil: [^FitLibraryException raiseErrorString: 'Actual value is null'].	(actual respondsTo: aSymbol)		ifFalse: 			[^FitLibraryException				raiseErrorString: 'Action value does not support comparisons: '						, actual class name asString].	cell := aDoAction cellAt: 2.	(actual perform: aSymbol with: anObject)		ifTrue: [cell pass]		ifFalse: [cell failWithMessage: actual fitToString]</body><body package="FitLibrary-Internals">expectedGroups: anArray	^anArray size = 1		ifTrue: ['1 bracketed group']		ifFalse: [anArray size printString , ' bracketed groups']</body><body package="FitLibrary-Internals">findStopWatch	^(self dynamicVariableAt: self class stopWatchKey)		ifNil: [^FitLibraryException raiseErrorString: 'No stopwatch started']</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>dynamic variables</category><body package="FitLibrary-Internals">clearDynamicVariables	self dynamicVariables clearAll.	^true</body><body package="FitLibrary-Internals">dynamicVariableAt: aString	^self dynamicVariables at: aString</body><body package="FitLibrary-Internals">dynamicVariableAt: aString put: anObject	self dynamicVariables at: aString put: anObject</body><body package="FitLibrary-Internals">dynamicVariables	^runtime dynamicVariables</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope class</class-id> <category>constants</category><body package="FitLibrary-Internals">stopWatchKey	^'$$STOP WATCH$$'</body></methods><methods><class-id>FitlibraryInternals.DoFlow</class-id> <category>running</category><body package="FitLibrary-Internals">runInnerTables: aTables resultsInto: aTestResults	| state |	state := scopeStack currentState.	aTables do: 			[:each |			self runTable: each resultsInto: aTestResults.			self				tearDown: state restore				row: each first				resultsInto: aTestResults]</body><body package="FitLibrary-Internals">runSingleTable: aTable resultsInto: aTestResults	| plainTextFailed |	plainTextFailed := false.	(current == self and: [aTable isPlainTextTable])		ifTrue: 			[| analyser results |			analyser := PlainTextAnalyser						definedActionsRepository: TemporaryPlugBoardForRuntime								definedActionsRepository						runtimeContext: runtime.			results := TestResults new.			analyser analyseAndReplaceRowsIn: aTable resultsInto: results.			plainTextFailed := results hasProblems.			aTestResults add: results].	domainCheck ifNotNil: [self handleDomainPhases: aTable].	plainTextFailed		ifFalse: [current runTable: aTable resultsInto: aTestResults]</body><body package="FitLibrary-Internals">runStorytest: aTables withListener: aTableListener	| testResults |	testResults := aTableListener testResults.	self resetToStartStorytest.	aTables do: 			[:each |			self runSingleTable: each resultsInto: testResults.			each == aTables last				ifTrue: [self finishLastTable: each resultsInto: testResults]				ifFalse: [self finishTable: each resultsInto: testResults].			self addAccumulatedFoldingTextTo: each.			aTableListener tableFinished: each].	aTableListener storytestFinished</body><body package="FitLibrary-Internals">runTable: aTable resultsInto: aTestResults	doFlowOnTable		runTable: aTable		withRuntime: runtime		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.DoFlow</class-id> <category>private</category><body package="FitLibrary-Internals">addAccumulatedFoldingTextTo: aTable	runtime addAccumulatedFoldingTextTo: aTable</body><body package="FitLibrary-Internals">exit	suiteFixture		ifNotNil: 			[setUpTearDown callSuiteTearDown: suiteFixture resultsInto: TestResults new]</body><body package="FitLibrary-Internals">finishLastTable: aTable resultsInto: aTestResults	self		tearDown: scopeStack poppedAtEndOfStoryTest		row: aTable first		resultsInto: aTestResults</body><body package="FitLibrary-Internals">finishTable: aTable resultsInto: aTestResults	self		tearDown: scopeStack poppedAtEndOfTable		row: aTable first		resultsInto: aTestResults</body><body package="FitLibrary-Internals">handleDomainPhases: aTable	aTable phaseBoundaryCount timesRepeat: 			[current == domainInject				ifTrue: [self setCurrentAction]				ifFalse: [current == self ifTrue: [self setCurrentCheck]]]</body><body package="FitLibrary-Internals">resetToStartStorytest	scopeStack		abandon: false;		setStopOnError: false.	scopeStack clearAllButSuite.	current := self.	domainInject := nil.	domainCheck := nil.	suiteFixture		ifNil: [runtime reset]		ifNotNil: 			[runtime := suiteFixture copyOfRuntimeContext.			scopeStack switchRuntime: runtime]</body><body package="FitLibrary-Internals">setCurrentAction	current := self</body><body package="FitLibrary-Internals">setCurrentCheck	current := domainCheck</body><body package="FitLibrary-Internals">setRuntimeContextOf: anObject	(anObject respondsTo: #runtimeContext:)		ifTrue: [anObject runtimeContext: runtime].	(anObject respondsTo: #systemUnderTest)		ifTrue: [self setRuntimeContextOf: anObject systemUnderTest]</body><body package="FitLibrary-Internals">tearDown: aCollection row: aRow resultsInto: aTestResults	aCollection do: 			[:each |			setUpTearDown				callTearDownOnSutChain: each subject				row: aRow				resultsInto: aTestResults]</body></methods><methods><class-id>FitlibraryInternals.DoFlow</class-id> <category>accessing</category><body package="FitLibrary-Internals">addObject: aTypedObject named: aString from: aRow resultsInto: aTestResults	aTypedObject injectRuntime: runtime.	setUpTearDown		callSetUpOnSutChain: aTypedObject subject		row: aRow		resultsInto: aTestResults.	scopeStack addObject: aTypedObject named: aString</body><body package="FitLibrary-Internals">domainFixture: aTypedObject	| sut subject |	sut := aTypedObject.	subject := aTypedObject subject.	(subject isKindOf: DomainFixture)		ifTrue: [sut := subject typedSystemUnderTest].	domainInject := DomainInjectionTraverse domainTraverser: self.	domainInject systemUnderTest: sut.	self setRuntimeContextOf: domainInject.	domainCheck := DomainCheckTraverse systemUnderTest: sut.	self setRuntimeContextOf: domainCheck.	current := domainInject</body><body package="FitLibrary-Internals">select: aString	scopeStack select: aString</body><body package="FitLibrary-Internals">setDomainToCheck	self setCurrentCheck</body><body package="FitLibrary-Internals">suite: aSuiteFixture	suiteFixture ifNil: [suiteFixture := aSuiteFixture]</body><body package="FitLibrary-Internals">useOldFoldingTextMarkup: aBoolean	runtime useOldFoldingTextMarkup: aBoolean</body></methods><methods><class-id>FitlibraryInternals.DoFlow</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setFlowEvaluator: aFlowEvaluator scopeStack: aScopeStack runtime: aRuntimeContext setUpTearDown: aSetUpTearDown	current := self.	scopeStack := aScopeStack.	runtime := aRuntimeContext.	setUpTearDown := aSetUpTearDown.	doFlowOnTable := DoFlowOnTable				flowEvaluator: aFlowEvaluator				scopeStack: scopeStack				setUpTearDown: setUpTearDown				doFlower: self</body></methods><methods><class-id>FitlibraryInternals.DoFlow</class-id> <category>testing</category><body package="FitLibrary-Internals">hasDomainCheck	^domainCheck notNil</body></methods><methods><class-id>FitlibraryInternals.DoFlow class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">flowEvaluator: aFlowEvaluator scopeStack: aScopeStack runtime: aRuntimeContext setUpTearDown: aSetUpTearDown	^self new		setFlowEvaluator: aFlowEvaluator		scopeStack: aScopeStack		runtime: aRuntimeContext		setUpTearDown: aSetUpTearDown</body></methods><methods><class-id>FitlibraryInternals.DoFlowWithExtraTableAddedWhenNeeded</class-id> <category>private</category><body package="FitLibrary-Internals">makeErrorTable	| errorTable |	errorTable := Table				withString: '&lt;i&gt;Error in storytest tear down: &lt;/i&gt;'.	self addAccumulatedFoldingTextTo: errorTable.	^errorTable</body><body package="FitLibrary-Internals">shouldDisplayErrorTable: aTable	aTable size &gt; 1 ifTrue: [^true].	aTable first size &gt; 1 ifTrue: [^true].	aTable first first hadError ifTrue: [^true].	^aTable trailer notEmpty</body></methods><methods><class-id>FitlibraryInternals.DoFlowWithExtraTableAddedWhenNeeded</class-id> <category>running</category><body package="FitLibrary-Internals">runStorytest: aTables withListener: aTableListener	| testResults errorTable |	testResults := aTableListener testResults.	self resetToStartStorytest.	aTables do: 			[:each |			self runSingleTable: each resultsInto: testResults.			self finishTable: each resultsInto: testResults.			self addAccumulatedFoldingTextTo: each.			aTableListener tableFinished: each].	errorTable := self makeErrorTable.	self finishLastTable: errorTable resultsInto: testResults.	(self shouldDisplayErrorTable: errorTable)		ifTrue: 			[errorTable leader: (String with: Character lf) , '&lt;br/&gt;'.			aTables add: errorTable.			aTableListener tableFinished: errorTable].	aTableListener storytestFinished</body></methods><methods><class-id>FitlibraryInternals.ActionSignature</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setMethodSpec: aMethodSpec	methodSpec := aMethodSpec</body><body package="FitLibrary-Internals">setName: aString arity: anInteger	name := aString.	arity := anInteger</body></methods><methods><class-id>FitlibraryInternals.ActionSignature</class-id> <category>accessing</category><body package="FitLibrary-Internals">methodSpec	^methodSpec</body><body package="FitLibrary-Internals">name	^methodSpec name</body></methods><methods><class-id>FitlibraryInternals.ActionSignature class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">createFrom: aRow from: fromInteger to: toInteger doStyle: aBoolean runtime: aRuntimeContext	| spec |	aBoolean		ifFalse: 			[spec := MethodSpec						baseName: (aRow resolvedTextAt: fromInteger resolver: aRuntimeContext)						numArgs: toInteger - fromInteger						runtimeContext: aRuntimeContext.			^self methodSpec: spec].	spec := MethodSpec numArgs: (toInteger - fromInteger + 1) // 2				runtimeContext: aRuntimeContext.	fromInteger to: toInteger		by: 2		do: [:i | spec addSegment: (aRow resolvedTextAt: i resolver: aRuntimeContext)].	^self methodSpec: spec</body><body package="FitLibrary-Internals">methodSpec: aMethodSpec	^self new setMethodSpec: aMethodSpec</body></methods><methods><class-id>FitlibraryInternals.FitLibraryException</class-id> <category>fitLibrary</category><body package="FitLibrary-Internals">fitLibraryExceptionMessage	^Markup formatFriendlyError: (Fixture escape: self errorString)</body></methods><methods><class-id>FitlibraryInternals.FitLibraryException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">messageText: aString	^(self basicNew)		initialize;		messageText: aString</body></methods><methods><class-id>FitlibraryInternals.CouldNotParseException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">class: aClass text: aString	^self messageText: ('Unable to parse "&lt;1s&gt;" of type: &lt;2s&gt;'				expandMacrosWith: aString				with: aClass fullName asString)</body></methods><methods><class-id>FitlibraryInternals.MethodSpec</class-id> <category>finding</category><body package="FitLibrary-Internals">findIn: anObject evaluator: anEvaluator	| methodLookup |	methodLookup := MethodLookup new.	self candidateMethods do: 			[:each |			(methodLookup findSpecificMethod: each in: anObject evaluator: anEvaluator)				ifNotNil: [:target | ^target]].	^nil</body></methods><methods><class-id>FitlibraryInternals.MethodSpec</class-id> <category>private</category><body package="FitLibrary-Internals">accessorSpecWithPrefix: aString	^self class		baseName: aString , ' ' , segments first		numArgs: numArgs		runtimeContext: runtimeContext</body><body package="FitLibrary-Internals">asExtendedCamel: aSymbol	| ws |	ws := String new writeStream.	((aSymbol asString tokensBasedOn: $:)		reject: [:each | each isEmpty or: [each = '_']])			do: [:each | ws nextPutAll: each fitUppercaseFirst].	^ws contents fitLowercaseFirst</body><body package="FitLibrary-Internals">basicCamelName	^basicCamelName		ifNil: [basicCamelName := self extendedCamel: self basicName]</body><body package="FitLibrary-Internals">basicName	| ws |	ws := String new writeStream.	segments do: [:each | ws nextPutAll: each] separatedBy: [ws space].	^ws contents</body><body package="FitLibrary-Internals">candidateMethods	| candidates |	candidates := OrderedCollection with: self.	self canBeGetter		ifTrue: 			[candidates				add: self getterMethodSpec;				add: self isMethodSpec].	self canBeSetter ifTrue: [candidates add: self setterMethodSpec].	^candidates</body><body package="FitLibrary-Internals">canonicalSegments	| result |	(numArgs = segments size or: [segments size &lt; 2]) ifTrue: [^segments].	result := segments copy.	^mergeFront		ifTrue: 			[result				addFirst: result removeFirst , ' ' , result removeFirst;				yourself]		ifFalse: 			[| last |			last := result removeLast.			result				addLast: result removeLast , ' ' , last;				yourself]</body><body package="FitLibrary-Internals">canonicalSelector	| ws |	ws := String new writeStream.	self canonicalSegments do: 			[:each |			ws				nextPutAll: (each isEmpty ifTrue: ['_'] ifFalse: [self extendedCamel: each])]		separatedBy: [ws nextPut: $:].	numArgs isZero ifFalse: [ws nextPut: $:].	^ws contents asSymbol</body><body package="FitLibrary-Internals">extendedCamel: aString	^runtimeContext extendedCamel: aString</body><body package="FitLibrary-Internals">getterMethodSpec	^self accessorSpecWithPrefix: 'get'</body><body package="FitLibrary-Internals">isMethodSpec	^self accessorSpecWithPrefix: 'is'</body><body package="FitLibrary-Internals">setterMethodSpec	^self accessorSpecWithPrefix: 'set'</body></methods><methods><class-id>FitlibraryInternals.MethodSpec</class-id> <category>accessing</category><body package="FitLibrary-Internals">matchGetter: aBoolean	matchGetter := aBoolean</body><body package="FitLibrary-Internals">matchSetter: aBoolean	matchSetter := aBoolean</body><body package="FitLibrary-Internals">mergeFront	mergeFront := true</body><body package="FitLibrary-Internals">methodSignatures	| signatures |	signatures := OrderedCollection new.	signatures add: self canonicalSelector printString.	self canBeGetter		ifTrue: [signatures add: self getterMethodSpec canonicalSelector printString].	self canBeSetter		ifTrue: [signatures add: self setterMethodSpec canonicalSelector printString].	^signatures</body></methods><methods><class-id>FitlibraryInternals.MethodSpec</class-id> <category>testing</category><body package="FitLibrary-Internals">canBeGetter	^matchGetter and: [numArgs isZero]</body><body package="FitLibrary-Internals">canBeSetter	^matchSetter and: [numArgs = 1]</body><body package="FitLibrary-Internals">matchesSelector: aSymbol	^aSymbol numArgs = numArgs		and: [(self asExtendedCamel: aSymbol) = self basicCamelName]</body></methods><methods><class-id>FitlibraryInternals.MethodSpec</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setNumArgs: anInteger runtimeContext: aRuntimeContext	matchGetter := true.	matchSetter := false.	mergeFront := false.	segments := OrderedCollection new.	numArgs := anInteger.	runtimeContext := aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.MethodSpec</class-id> <category>adding</category><body package="FitLibrary-Internals">addAllSegments: aCollection	aCollection do: [:each | self addSegment: each]</body><body package="FitLibrary-Internals">addSegment: aString	segments add: aString.	basicCamelName := nil</body></methods><methods><class-id>FitlibraryInternals.MethodSpec class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">baseName: aString numArgs: anInteger runtimeContext: aRuntimeContext	^(self numArgs: anInteger runtimeContext: aRuntimeContext)		addSegment: aString;		yourself</body><body package="FitLibrary-Internals">numArgs: anInteger runtimeContext: aRuntimeContext	^self new setNumArgs: anInteger runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.Matcher</class-id> <category>private</category><body package="FitLibrary-Internals">matchAfterPrefixActual: actualString expected: expectedString	| endExpected endActual |	endExpected := expectedString findString: endLabel startingAt: 1.	endActual := actualString findString: endLabel startingAt: 1.	(endExpected isZero or: [endActual isZero]) ifTrue: [^false].	(self matchInsideActual: (actualString copyFrom: 1 to: endActual - 1)		expected: (expectedString copyFrom: 1 to: endExpected - 1))			ifFalse: [^false].	^self matchActual: (actualString copyFrom: endActual + endLabel size				to: actualString size)		expected: (expectedString copyFrom: endExpected + endLabel size				to: expectedString size)</body><body package="FitLibrary-Internals">matchInsideActual: actualString expected: expectedString	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.Matcher</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">endLabel: aString	endLabel := aString</body></methods><methods><class-id>FitlibraryInternals.Matcher class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">downstream: aFilter startLabel: startString endLabel: endString	^(super downstream: aFilter startLabel: startString)		endLabel: endString;		yourself</body></methods><methods><class-id>FitlibraryInternals.FitLabelMatcher</class-id> <category>private</category><body package="FitLibrary-Internals">adjustForImplementationDifferences: aString	| patterns |	patterns := #('*Could not parse: *, expected type: *.' '*Could not find method: *.' 'Missing class or Missing method. Possibly:*' 'Ambiguity between: * AND *' '*Method * does not return a boolean.' 'Missing method, possibly: *' 'Either * is*A &lt;b&gt;Value Object&lt;/b&gt;. So missing parse method:*; or*An *Entity&lt;/b&gt;. So missing finder method:*' 'Class is abstract: *').	^patterns detect: [:each | each match: aString] ifNone: [aString]</body><body package="FitLibrary-Internals">matchInsideActual: actualString expected: expectedString	^(self adjustForImplementationDifferences: expectedString) , '*'		match: actualString</body></methods><methods><class-id>FitlibraryInternals.FitLabelMatcher class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">downstream: aFilter	^self		downstream: aFilter		startLabel: '&lt;span class="fit_label"&gt;'		endLabel: '&lt;/span&gt;'</body></methods><methods><class-id>FitlibraryInternals.LookupClosureStandard</class-id> <category>lookup</category><body package="FitLibrary-Internals">findMethodClosure: aMethodSpec on: anObject	anObject ifNil: [^nil].	^self findMethod: aMethodSpec on: anObject</body><body package="FitLibrary-Internals">findPublicMethodClosure: aMethodSpec taking: aCollection on: anObject	anObject ifNil: [^nil].	^	[self		findMethodNamed: aMethodSpec canonicalSelector		taking: aCollection		on: anObject]			on: Error			do: [:ex | ^nil]</body></methods><methods><class-id>FitlibraryInternals.LookupClosureStandard</class-id> <category>private</category><body package="FitLibrary-Internals">aliasFor: aMethodSpec on: anObject	(anObject respondsTo: #aliasForSelector:) ifFalse: [^nil].	^(anObject aliasForSelector: aMethodSpec canonicalSelector)		ifNotNil: [:selector | AliasMethodSpec selector: selector]</body><body package="FitLibrary-Internals">findMethod: aMethodSpec on: anObject	^self findSpecificMethod: aMethodSpec on: anObject</body><body package="FitLibrary-Internals">findMethodNamed: aSymbol taking: aCollection on: anObject	| method signature |	(anObject respondsTo: aSymbol) ifFalse: [^nil].	method := (anObject class instanceBehavior findSelector: aSymbol) last.	signature := MethodSignature forSelector: aSymbol in: anObject.	(signature takes: aCollection) ifFalse: [^nil].	^MethodClosure forMethod: method on: anObject</body><body package="FitLibrary-Internals">findSpecificMethod: aMethodSpec on: anObject	| methodSpec |	methodSpec := (self aliasFor: aMethodSpec on: anObject)				ifNil: [aMethodSpec].	FitLibrarySelectors subject: anObject		selectorsDo: 			[:each |			| match |			match := MatchOneMethodClosure						spec: methodSpec						subject: anObject						selector: each.			match matches ifTrue: [^match closure]].	^nil</body></methods><methods><class-id>FitlibraryInternals.MissingTablesException</class-id> <category>printing</category><body package="FitLibrary-Internals">description	^'Missing table'</body></methods><methods><class-id>FitlibraryInternals.StringMatcher</class-id> <category>comparing</category><body package="FitLibrary-Internals">ignoreNonBreakingWhiteSpaceActual: actualString expected: expectedString	^(actualString isEmpty and: [expectedString = '&amp;nbsp;'])		or: [expectedString isEmpty and: [actualString = '&amp;nbsp;']]</body><body package="FitLibrary-Internals">matchActual: actualString expected: expectedString	^(self ignoreNonBreakingWhiteSpaceActual: actualString		expected: expectedString) or: [actualString = expectedString]</body></methods><methods><class-id>FitlibraryInternals.DynamicVariablesMap</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	map := Dictionary new</body><body package="FitLibrary-Internals">setVariables: aDynamicVariables	map := aDynamicVariables map copy</body></methods><methods><class-id>FitlibraryInternals.DynamicVariablesMap</class-id> <category>accessing</category><body package="FitLibrary-Internals">at: aString	^map at: aString ifAbsent: [nil]</body><body package="FitLibrary-Internals">at: aString put: anObject	self basicAt: aString put: anObject</body><body package="FitLibrary-Internals">at: aString putParameter: anObject	^self subclassResponsibility</body><body package="FitLibrary-Internals">basicAt: aString put: anObject	map at: aString put: anObject</body><body package="FitLibrary-Internals">clearAll	map := Dictionary new</body><body package="FitLibrary-Internals">map	^map copy</body><body package="FitLibrary-Internals">popLocal	^self subclassResponsibility</body><body package="FitLibrary-Internals">stringAt: aString	^(self at: aString) ifNotNil: #fitToString</body><body package="FitLibrary-Internals">top	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.DynamicVariablesMap</class-id> <category>resolving</category><body package="FitLibrary-Internals">resolve: aString	| result tables index loops |	result := aString.	tables := Tables new.	index := 1.	loops := 0.		[index := result findString: '@{' startingAt: index.	index isZero]			whileFalse: 				[| end |				loops := loops + 1.				loops &gt; 10000					ifTrue: [^VariableResolution text: 'INFINITE SUBSTITUTION!' tables: tables].				end := (result							nextIndexOf: $}							from: index							to: result size) ifNil: [0].				end isZero					ifFalse: 						[(self at: (result copyFrom: index + 2 to: end - 1))							ifNil: [index := index + 2]							ifNotNil: 								[:substitute |								| replace |								replace := substitute fitLibraryResolveInto: tables.								result := (result copyFrom: 1 to: index - 1) , replace											, (result copyFrom: end + 1 to: result size).								index := 1]]].	^VariableResolution text: result tables: tables</body></methods><methods><class-id>FitlibraryInternals.DynamicVariablesMap class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body><body package="FitLibrary-Internals">variables: aDynamicVariables	^self new setVariables: aDynamicVariables</body></methods><methods><class-id>FitlibraryInternals.GlobalDynamicVariables</class-id> <category>accessing</category><body package="FitLibrary-Internals">at: aString putParameter: anObject	"Cannot put a parameter into a GlobalDynamicVariables"	^self shouldNotImplement</body><body package="FitLibrary-Internals">popLocal	"Can't popLocal when one is not pushed"	^self shouldNotImplement</body><body package="FitLibrary-Internals">top	^self</body></methods><methods><class-id>FitlibraryInternals.GlobalDynamicVariables</class-id> <category>adding</category><body package="FitLibrary-Internals">addFromPropertiesFile: aString	^false</body><body package="FitLibrary-Internals">addFromUnicodePropertiesFile: aString</body></methods><methods><class-id>FitlibraryInternals.TableReportListener</class-id> <category>events</category><body package="FitLibrary-Internals">tableFinished: aTable	server sendTableReport: aTable</body><body package="FitLibrary-Internals">tablesFinished: aTestResults	server sendTestResults: aTestResults</body></methods><methods><class-id>FitlibraryInternals.TableReportListener</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">server: aFitServerBridge	server := aFitServerBridge</body></methods><methods><class-id>FitlibraryInternals.TableReportListener class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">server: aFitServerBridge	^self new server: aFitServerBridge</body></methods><methods><class-id>FitlibraryInternals.Parser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.Parser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.Parser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.Parser</class-id> <category>testing</category><body package="FitLibrary-Internals">isShowAsHtml	^false</body></methods><methods><class-id>FitlibraryInternals.Parser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.CollectionParser</class-id> <category>private</category><body package="FitLibrary-Internals">makeTraverse: anObject	^self traverseClass systemUnderTest: nil actuals: anObject</body><body package="FitLibrary-Internals">parseString: aString resultsInto: aTestResults	^self targetClass withAll: ((aString runsFailing: [:each | each = $,])				collect: [:each | self parseStringValue: each resultsInto: aTestResults])</body><body package="FitLibrary-Internals">parseStringValue: each resultsInto: aTestResults	^valueParser parse: (Cell withString: each fitTrimSeparators)		resultsInto: aTestResults</body><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| collection setUp |	collection := self targetClass new.	setUp := CollectionSetUpTraverse				systemUnderTest: evaluator				collection: collection				embedded: true.	setUp		interpretInnerTableWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^collection</body><body package="FitLibrary-Internals">table: aTable matches: anObject resultsInto: aTestResults	| traverse |	traverse := self makeTraverse: anObject.	^traverse		doesInnerTablePass: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults</body><body package="FitLibrary-Internals">targetClass	^self subclassResponsibility</body><body package="FitLibrary-Internals">traverseClass	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.CollectionParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	| ws |	anObject ifNil: [^''].	ws := String new writeStream.	anObject do: [:each | ws nextPutAll: (showParser show: each)]		separatedBy: [ws nextPutAll: ', '].	^ws contents</body></methods><methods><class-id>FitlibraryInternals.CollectionParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self traverseClass systemUnderTest: aTypedObject		actuals: aTypedObject subject</body></methods><methods><class-id>FitlibraryInternals.CollectionParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	(aCell hasEmbeddedTables: evaluator)		ifTrue: [^self parseTable: aCell embeddedTable resultsInto: aTestResults].	^self parseString: (aCell resolvedText: evaluator)		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.CollectionParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	anObject		ifNil: 			[^(aCell hasEmbeddedTables: evaluator) not and: [aCell isBlank: evaluator]].	(aCell hasEmbeddedTables: evaluator)		ifTrue: 			[^self				table: aCell embeddedTable				matches: anObject				resultsInto: aTestResults].	^anObject = (self parse: aCell resultsInto: aTestResults)</body></methods><methods><class-id>FitlibraryInternals.CollectionParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setEvaluator: anEvaluator	anEvaluator runtimeContext		ifNil: [^FitLibraryException raiseErrorString: 'Runtime is null'].	evaluator := anEvaluator.	valueParser := (TypeAdapter adapterFor: String) resultParser: anEvaluator.	showParser := (TypeAdapter adapterFor: Object) resultParser: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.CollectionParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">evaluator: anEvaluator	^self new setEvaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.MapParser</class-id> <category>private</category><body package="FitLibrary-Internals">makeTraverse: anObject	^self traverseClass map: anObject</body><body package="FitLibrary-Internals">parseStringValue: aString resultsInto: aTestResults	| tokens |	tokens := aString fitLibrarySplit: '-&gt;'.	tokens size = 2 ifFalse: [^(InvalidMapString string: aString) raise].	^(valueParser parse: (Cell withString: tokens first)		resultsInto: aTestResults)			-&gt; (valueParser parse: (Cell withString: tokens last)					resultsInto: aTestResults)</body><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| setUp |	setUp := MapSetUpTraverse				keyType: keyTypeAdapter				valueType: valueTypeAdapter				runtimeContext: evaluator runtimeContext.	setUp		interpretInnerTableWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^setUp results</body><body package="FitLibrary-Internals">targetClass	^Dictionary</body><body package="FitLibrary-Internals">traverseClass	^MapTraverse</body></methods><methods><class-id>FitlibraryInternals.MapParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	| ws |	anObject ifNil: [^''].	ws := String new writeStream.	anObject associations do: 			[:each |			ws nextPutAll: (showParser show: each key) , '-&gt;'						, (showParser show: each value)]		separatedBy: [ws nextPutAll: ', '].	^ws contents</body></methods><methods><class-id>FitlibraryInternals.MapParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self makeTraverse: aTypedObject subject</body></methods><methods><class-id>FitlibraryInternals.MapParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setKeyType: aKeyTypeAdapter valueType: aValueTypeAdapter evaluator: anEvaluator	self setEvaluator: anEvaluator.	keyTypeAdapter := aKeyTypeAdapter.	valueTypeAdapter := aValueTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.MapParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">evaluator: anEvaluator	^self		keyType: (TypeAdapter adapterFor: String)		valueType: (TypeAdapter adapterFor: String)		evaluator: anEvaluator</body><body package="FitLibrary-Internals">keyType: keyTypeAdapter valueType: valueTypeAdapter evaluator: anEvaluator	^self new		setKeyType: keyTypeAdapter		valueType: valueTypeAdapter		evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.GenericMapParser</class-id> <category>private</category><body package="FitLibrary-Internals">makeTraverse: anObject	^self traverseClass		map: anObject		keyType: keyTypeAdapter		valueType: valueTypeAdapter		runtimeContext: evaluator runtimeContext</body></methods><methods><class-id>FitlibraryInternals.FitLibraryExceptionInHtml</class-id> <category>fitLibrary</category><body package="FitLibrary-Internals">fitLibraryExceptionMessage	^Markup formatFriendlyError: self errorString</body></methods><methods><class-id>FitlibraryInternals.MissingMethodException</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setSignatures: signaturesCollection classes: classesCollection	signatures := signaturesCollection.	classes := classesCollection</body></methods><methods><class-id>FitlibraryInternals.MissingMethodException</class-id> <category>accessing</category><body package="FitLibrary-Internals">fitLibraryAddToMissingMethodMessage: aMissingMethodMessage	aMissingMethodMessage		addAllMissingMethods: signatures;		addAllPossibleClasses: classes</body></methods><methods><class-id>FitlibraryInternals.MissingMethodException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">signatures: signatureCollection classes: classCollection	| messageText |	messageText := 'Missing method, possibly: '				, (self htmlListOfSignatures: signatureCollection) , '&lt;hr/&gt;In:'				, (self htmlListOfClassNames: classCollection).	^(self messageText: messageText)		setSignatures: signatureCollection classes: classCollection;		yourself</body></methods><methods><class-id>FitlibraryInternals.MissingMethodException class</class-id> <category>private</category><body package="FitLibrary-Internals">htmlListOfClassNames: aCollection	| ws |	ws := String new writeStream.	ws nextPutAll: '&lt;ul&gt;'.	aCollection do: 			[:each |			ws				nextPutAll: '&lt;li&gt;';				nextPutAll: each shortName;				nextPutAll: '&lt;/li&gt;'].	ws nextPutAll: '&lt;/ul&gt;'.	^ws contents</body><body package="FitLibrary-Internals">htmlListOfSignatures: aCollection	| ws |	ws := String new writeStream.	ws nextPutAll: '&lt;ul&gt;'.	aCollection do: 			[:each |			ws				nextPutAll: '&lt;li&gt;';				nextPutAll: each;				nextPutAll: '&lt;/li&gt;'].	ws nextPutAll: '&lt;/ul&gt;'.	^ws contents</body></methods><methods><class-id>FitlibraryInternals.StopWatch</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	start := Time millisecondClockValue</body></methods><methods><class-id>FitlibraryInternals.StopWatch</class-id> <category>accessing</category><body package="FitLibrary-Internals">delay	^Time millisecondClockValue - start</body></methods><methods><class-id>FitlibraryInternals.StopWatch class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.LookupMethodTargetStandard</class-id> <category>private</category><body package="FitLibrary-Internals">findFixturingMethod: aMethodSpec taking: aCollection evaluator: anEvaluator	| methodLookup |	methodLookup := MethodLookup new.	anEvaluator scope objectsForLookup do: 			[:each |			(methodLookup				findPublicMethodClosure: aMethodSpec				taking: aCollection				on: each subject) ifNotNil: [:target | ^target]].	^nil</body><body package="FitLibrary-Internals">findMethod: aMethodSpec onSutOf: anEvaluator	| sut |	sut := anEvaluator systemUnderTest.		[sut ifNil: [^NoSystemUnderTestException raise].	(aMethodSpec findIn: sut evaluator: anEvaluator)		ifNotNil: [:target | ^target].	(sut respondsTo: #systemUnderTest)		ifTrue: [sut := sut systemUnderTest]		ifFalse: 			[^(MissingMethodException signatures: aMethodSpec methodSignatures				classes: anEvaluator scope possibleClasses) raise]]			repeat</body><body package="FitLibrary-Internals">findMethodMappedTo: aMethodSpec evaluator: anEvaluator	^self findMethodOrGetter: aMethodSpec evaluator: anEvaluator</body><body package="FitLibrary-Internals">findMethodOrGetter: aMethodSpec evaluator: anEvaluator	| scope |	scope := anEvaluator scope.	scope objectsForLookup do: 			[:each |			(aMethodSpec findIn: each subject evaluator: anEvaluator)				ifNotNil: [:target | ^target]].	^(MissingMethodException signatures: aMethodSpec methodSignatures		classes: scope possibleClasses) raise</body><body package="FitLibrary-Internals">findSpecialMethodWithSegments: nameCollection taking: argumentCollection evaluator: anEvaluator	| methodSpec |	methodSpec := MethodSpec numArgs: argumentCollection size				runtimeContext: anEvaluator runtimeContext.	methodSpec addAllSegments: nameCollection.	^self		findFixturingMethod: methodSpec		taking: argumentCollection		evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.LookupMethodTargetStandard</class-id> <category>lookup</category><body package="FitLibrary-Internals">findActionSpecialMethodFrom: aCollection sequencing: aBoolean evaluator: anEvaluator	anEvaluator scope objectsForLookup do: 			[:each |			| positioned factoryBlock |			factoryBlock :=					[:method :from :to |					PositionedTarget						evaluator: anEvaluator						cells: aCollection						typedObject: each						method: method						from: from						to: to						sequencing: aBoolean						lookupTarget: PlugBoard lookupTarget].			positioned := each						findActionSpecialMethodsFrom: aCollection						factoryBlock: factoryBlock						runtimeContext: anEvaluator runtimeContext.			positioned isEmpty ifFalse: [^positioned]].	^Array new</body><body package="FitLibrary-Internals">findClassFromFactoryMethod: aString baseType: aClass evaluator: anEvaluator	| methodSpec |	methodSpec := MethodSpec				baseName: 'concreteClassOf' , aClass name				numArgs: 1				runtimeContext: anEvaluator runtimeContext.	^(self		findFixturingMethod: methodSpec		taking: (Array with: String)		evaluator: anEvaluator)			ifNil: 				[(MissingMethodException signatures: methodSpec methodSignatures					classes: anEvaluator scope possibleClasses) raise]			ifNotNil: [:method | method invokeOnArguments: (Array with: aString)]</body><body package="FitLibrary-Internals">findGetter: aString onSutOf: anEvaluator	| spec |	spec := MethodSpec				baseName: aString				numArgs: 0				runtimeContext: anEvaluator runtimeContext.	spec matchGetter: true.	^self findMethod: spec onSutOf: anEvaluator</body><body package="FitLibrary-Internals">findMethod: aMethodSpec evaluator: anEvaluator	aMethodSpec matchGetter: false.	^self findMethodOrGetter: aMethodSpec evaluator: anEvaluator</body><body package="FitLibrary-Internals">findMethodByArityIn: aRow from: fromInteger to: toInteger doStyle: aBoolean evaluator: anEvaluator	| actionSignature target |	actionSignature := ActionSignature				createFrom: aRow				from: fromInteger				to: toInteger				doStyle: aBoolean				runtime: anEvaluator runtimeContext.	target := self findMethodMappedTo: actionSignature methodSpec				evaluator: anEvaluator.	target everySecond: aBoolean.	^target</body><body package="FitLibrary-Internals">findNewInstancePluginMethod: anEvaluator	| methodSpec |	methodSpec := MethodSpec				baseName: 'newInstancePlugin'				numArgs: 1				runtimeContext: anEvaluator runtimeContext.	^self		findFixturingMethod: methodSpec		taking: (Array with: Class)		evaluator: anEvaluator</body><body package="FitLibrary-Internals">findPostfixSpecialMethodNamed: aString evaluator: anEvaluator	aString isEmpty ifTrue: [^nil].	^(self		findSpecialMethodWithSegments: (Array with: 'withResults' with: aString)		taking: (Array with: TestResults with: Row)		evaluator: anEvaluator)			ifNotNil: [:method | CalledMethodTarget closure: method evaluator: anEvaluator]</body><body package="FitLibrary-Internals">findSetter: aString onSutOf: anEvaluator	| spec |	spec := MethodSpec				baseName: aString				numArgs: 1				runtimeContext: anEvaluator runtimeContext.	spec matchSetter: true.	^self findMethod: spec onSutOf: anEvaluator</body><body package="FitLibrary-Internals">findSpecialMethodNamed: aString evaluator: anEvaluator	| method |	aString isEmpty ifTrue: [^nil].	method := (self				findSpecialMethodWithSegments: (Array with: aString with: 'resultsInto')				taking: (Array with: Row with: TestResults)				evaluator: anEvaluator)					ifNil: 						[self							findSpecialMethodWithSegments: (Array with: aString)							taking: (Array with: Row)							evaluator: anEvaluator].	^method		ifNotNil: [CalledMethodTarget closure: method evaluator: anEvaluator]</body></methods><methods><class-id>FitlibraryInternals.LookupMethodTargetStandard</class-id> <category>accessing</category><body package="FitLibrary-Internals">possibleClassesIn: aScopeStack	^aScopeStack possibleClasses</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext</class-id> <category>accessing</category><body package="FitLibrary-Internals">abandon: aBoolean	suiteWideRuntimeContext abandon: aBoolean</body><body package="FitLibrary-Internals">cellAt: anInteger	| cell |	cell := currentRow at: anInteger.	^CellProxy		onCell: cell		variableResolver: dynamicVariables		testResultsBlock: [testResults]</body><body package="FitLibrary-Internals">checkStopOnError: aTestResults	(onErrorHandler stopOnFailures: aTestResults failed		errors: aTestResults errors) ifFalse: [^self].	self scope abandon: true</body><body package="FitLibrary-Internals">configuration	^suiteWideRuntimeContext</body><body package="FitLibrary-Internals">currentRow	^RowProxy rowBlock: [currentRow]</body><body package="FitLibrary-Internals">currentRow: aRow	currentRow := aRow</body><body package="FitLibrary-Internals">currentTable: aTable	currentTable := aTable</body><body package="FitLibrary-Internals">definedActionCallManager	^definedActionCallManager</body><body package="FitLibrary-Internals">expandDefinedActions: aBoolean	self dynamicVariableAt: self class expandDefinedActions		put: aBoolean printString</body><body package="FitLibrary-Internals">extendedCamel: aString	^ExtendedCamelCase camel: aString</body><body package="FitLibrary-Internals">extendedCamel: aString hideJavaKeywordsToo: aBoolean	^ExtendedCamelCase camel: aString hideJavaKeywordToo: aBoolean</body><body package="FitLibrary-Internals">global	^suiteWideRuntimeContext global</body><body package="FitLibrary-Internals">logConfiguration	^logConfiguration</body><body package="FitLibrary-Internals">popTestResults	testResults := testResultsStack removeLast</body><body package="FitLibrary-Internals">pushTestResults: aTestResults	testResultsStack addLast: aTestResults.	testResults := aTestResults</body><body package="FitLibrary-Internals">registerOnErrorHandler: anOnError	onErrorHandler := anOnError</body><body package="FitLibrary-Internals">reset	dynamicVariables := GlobalDynamicVariables new.	suiteWideRuntimeContext reset</body><body package="FitLibrary-Internals">scope	^suiteWideRuntimeContext scope</body><body package="FitLibrary-Internals">setStopOnError: aBoolean	suiteWideRuntimeContext setStopOnError: aBoolean</body><body package="FitLibrary-Internals">tableEvaluator	^suiteWideRuntimeContext tableEvaluator</body><body package="FitLibrary-Internals">tableEvaluator: aTableEvaluator	suiteWideRuntimeContext tableEvaluator: aTableEvaluator</body><body package="FitLibrary-Internals">testResults	^testResults</body><body package="FitLibrary-Internals">timeoutAt: aString ifAbsent: aBlock	^suiteWideRuntimeContext timeoutAt: aString ifAbsent: aBlock</body><body package="FitLibrary-Internals">timeoutAt: aString put: anInteger	suiteWideRuntimeContext timeoutAt: aString put: anInteger</body><body package="FitLibrary-Internals">variableResolver	^self</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext</class-id> <category>showing</category><body package="FitLibrary-Internals">addAccumulatedFoldingTextTo: aTable	foldingTexts addAccumulatedFoldingTextTo: aTable</body><body package="FitLibrary-Internals">show: aString	(currentRow addCellWithString: aString) shown.	self definedActionCallManager addShow: currentRow</body><body package="FitLibrary-Internals">showAsAfterTableTitle: titleString contents: contentsString	foldingTexts logAsAfterTableTitle: titleString contents: contentsString</body><body package="FitLibrary-Internals">useOldFoldingTextMarkup: aBoolean	foldingTexts useOldMarkup: aBoolean</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext</class-id> <category>dynamic variables</category><body package="FitLibrary-Internals">dynamicVariableAt: aString	^dynamicVariables at: aString</body><body package="FitLibrary-Internals">dynamicVariableAt: aString put: anObject	^dynamicVariables at: aString put: anObject</body><body package="FitLibrary-Internals">dynamicVariables	^dynamicVariables</body><body package="FitLibrary-Internals">popLocalDynamicVariables	dynamicVariables := dynamicVariables popLocal</body><body package="FitLibrary-Internals">pushLocalDynamicVariables	dynamicVariables := LocalDynamicVariables outer: dynamicVariables</body><body package="FitLibrary-Internals">resolve: aString	^self dynamicVariables resolve: aString</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext</class-id> <category>testing</category><body package="FitLibrary-Internals">hasRowsAfter: aRow	(currentTable isNil or: [currentRow isNil]) ifTrue: [^false].	^currentTable hasRowsAfter: currentRow</body><body package="FitLibrary-Internals">isAbandoned: aTestResults	^suiteWideRuntimeContext isAbandoned: aTestResults</body><body package="FitLibrary-Internals">shouldExpandDefinedActions	^(self dynamicVariableAt: self class expandDefinedActions)		= true printString</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	dynamicVariables := GlobalDynamicVariables new.	definedActionCallManager := DefinedActionCallManager new.	foldingTexts := FoldingTexts new.	testResultsStack := OrderedCollection new.	onErrorHandler := NullOnErrorHandler new</body><body package="FitLibrary-Internals">setDynamicVariables: aDynamicVariables suiteWideRuntimeContext: aSuiteWideRuntimeContext logConfiguration: aLogConfiguration foldingTexts: aFoldingTexts	dynamicVariables := aDynamicVariables.	suiteWideRuntimeContext := aSuiteWideRuntimeContext.	logConfiguration := aLogConfiguration.	foldingTexts := aFoldingTexts</body><body package="FitLibrary-Internals">setScope: aScope globalActionScope: aGlobalActionScope	suiteWideRuntimeContext := SuiteWideRuntimeContext scope: aScope				globalActionScope: aGlobalActionScope.	aGlobalActionScope runtimeContext: self.	logConfiguration := LogConfiguration runtimeContext: self</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext</class-id> <category>copying</category><body package="FitLibrary-Internals">copyFromSuite	^self class		dynamicVariables: (GlobalDynamicVariables variables: dynamicVariables top)		suiteWideRuntimeContext: suiteWideRuntimeContext		logConfiguration: logConfiguration		foldingTexts: foldingTexts</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">dynamicVariables: aDynamicVariables suiteWideRuntimeContext: aSuiteWideRuntimeContext logConfiguration: aLogConfiguration foldingTexts: aFoldingTexts	^self new		setDynamicVariables: aDynamicVariables		suiteWideRuntimeContext: aSuiteWideRuntimeContext		logConfiguration: aLogConfiguration		foldingTexts: aFoldingTexts</body><body package="FitLibrary-Internals">new	^super new initialize</body><body package="FitLibrary-Internals">scope: aScope globalActionScope: aGlobalActionScope	^self new setScope: aScope globalActionScope: aGlobalActionScope</body></methods><methods><class-id>FitlibraryInternals.RuntimeContext class</class-id> <category>constants</category><body package="FitLibrary-Internals">expandDefinedActions	^'$$expandDefinedActions$$'</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>accessing</category><body package="FitLibrary-Internals">at: anIndex	^elements at: anIndex</body><body package="FitLibrary-Internals">first	^self at: 1</body><body package="FitLibrary-Internals">from: anInteger	anInteger = 1 ifTrue: [^self].	^self from: anInteger to: self size</body><body package="FitLibrary-Internals">from: firstIndex to: lastIndex	| result |	result := self newObject.	firstIndex to: lastIndex do: [:i | result add: (self at: i)].	^result</body><body package="FitLibrary-Internals">last	^self at: self size</body><body package="FitLibrary-Internals">leader	^leader</body><body package="FitLibrary-Internals">leader: aString	leader := aString</body><body package="FitLibrary-Internals">parse	^self error: 'Unable to provide a Parse.'</body><body package="FitLibrary-Internals">readStream	^elements readStream</body><body package="FitLibrary-Internals">second	^self at: 2</body><body package="FitLibrary-Internals">size	^elements size</body><body package="FitLibrary-Internals">tagLine	^tagAnnotation</body><body package="FitLibrary-Internals">tagLine: aString	tagAnnotation := aString</body><body package="FitLibrary-Internals">trailer	^trailer</body><body package="FitLibrary-Internals">trailer: aString	trailer := aString</body><body package="FitLibrary-Internals">type	^tag</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>markup</category><body package="FitLibrary-Internals">addToTag: aString	| trimmed |	trimmed := aString fitTrimSeparators.	tag isEmpty ifTrue: [self first addToTag: trimmed].	tagAnnotation isEmpty ifFalse: [tagAnnotation := tagAnnotation , ' '].	tagAnnotation := tagAnnotation , trimmed</body><body package="FitLibrary-Internals">addToTrailer: aString	trailer := trailer , aString</body><body package="FitLibrary-Internals">calls	self addToTag: self class callsMarkup</body><body package="FitLibrary-Internals">error: anError resultsInto: aTestResults	self first error: anError resultsInto: aTestResults</body><body package="FitLibrary-Internals">fail: aTestResults	self hadError ifTrue: [^self].	self addToTag: self class failMarkup.	aTestResults fail</body><body package="FitLibrary-Internals">label: aString	^self class label: aString</body><body package="FitLibrary-Internals">pass: aTestResults	self addToTag: self class passMarkup.	aTestResults pass</body><body package="FitLibrary-Internals">passOrFail: aBoolean resultsInto: aTestResults	aBoolean		ifTrue: [self pass: aTestResults]		ifFalse: [self fail: aTestResults]</body><body package="FitLibrary-Internals">shown	self addToTag: self class shownMarkup</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>printing</category><body package="FitLibrary-Internals">printElementsOn: aStream	elements do: [:each | each printHtmlOn: aStream]</body><body package="FitLibrary-Internals">printHtmlBodyOn: aStream	"do nothing by default"</body><body package="FitLibrary-Internals">printHtmlOn: aStream	| tagLine |	aStream		nextPutAll: self leader;		nextPut: $&lt;;		nextPutAll: tag.	tagLine := self tagLine.	tagLine isEmpty		ifFalse: 			[aStream				space;				nextPutAll: tagLine].	aStream nextPut: $&gt;.	self printElementsOn: aStream.	self printHtmlBodyOn: aStream.	tag isEmpty		ifFalse: 			[aStream				nextPutAll: '&lt;/';				nextPutAll: tag;				nextPut: $&gt;].	aStream nextPutAll: self trailer</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>private</category><body package="FitLibrary-Internals">elements	^elements</body><body package="FitLibrary-Internals">newObject	^self class new</body><body package="FitLibrary-Internals">tagContains: aString	^(tagAnnotation findString: aString startingAt: 1) &gt; 0</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>enumerating</category><body package="FitLibrary-Internals">collect: aBlock	^elements collect: aBlock</body><body package="FitLibrary-Internals">do: aBlock	elements do: aBlock</body><body package="FitLibrary-Internals">keysAndValuesDo: aBlock	elements keysAndValuesDo: aBlock</body><body package="FitLibrary-Internals">with: aTableElement do: aBlock	^elements with: aTableElement elements do: aBlock</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>testing</category><body package="FitLibrary-Internals">existsAt: anInteger	^anInteger between: 1 and: self size</body><body package="FitLibrary-Internals">hadError	^self tagContains: self class errorMarkup</body><body package="FitLibrary-Internals">isCell	^false</body><body package="FitLibrary-Internals">isEmpty	^elements isEmpty</body><body package="FitLibrary-Internals">notEmpty	^elements notEmpty</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>adding</category><body package="FitLibrary-Internals">add: aTableElement	^elements add: aTableElement</body><body package="FitLibrary-Internals">add: aTableElement at: anIndex	elements add: aTableElement beforeIndex: anIndex</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	leader := ''.	trailer := ''.	tagAnnotation := ''.	elements := OrderedCollection new</body><body package="FitLibrary-Internals">tag: aString	tag := aString.	self initialize</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>removing</category><body package="FitLibrary-Internals">removeElementAt: anInteger	elements removeAtIndex: anInteger</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitToString	| ws |	ws := String new writeStream.	self printHtmlOn: ws.	^ws contents</body></methods><methods><class-id>FitlibraryInternals.TableElement</class-id> <category>copying</category><body package="FitLibrary-Internals">deepCopy	| copy |	copy := self class new.	self do: [:each | copy add: each deepCopy].	copy		leader: self leader;		trailer: self trailer;		tagLine: self tagLine.	^copy</body></methods><methods><class-id>FitlibraryInternals.TableElement class</class-id> <category>constants</category><body package="FitLibrary-Internals">callsMarkup	^'bgcolor="#DADAFF"'</body><body package="FitLibrary-Internals">errorMarkup	^'class="error"'</body><body package="FitLibrary-Internals">failMarkup	^'class="fail"'</body><body package="FitLibrary-Internals">ignoreMarkup	^'class="ignore"'</body><body package="FitLibrary-Internals">passMarkup	^'class="pass"'</body><body package="FitLibrary-Internals">shownMarkup	^'bgcolor="#C0C0FF"'</body></methods><methods><class-id>FitlibraryInternals.TableElement class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">tag: aString	"Subclasses will call this from #new, so use #basicNew here to avoid infinite recursion"	^(self basicNew)		tag: aString</body></methods><methods><class-id>FitlibraryInternals.TableElement class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.TableElement class</class-id> <category>markup</category><body package="FitLibrary-Internals">label: aString	^Markup label: aString</body></methods><methods><class-id>FitlibraryInternals.Row</class-id> <category>accessing</category><body package="FitLibrary-Internals">argumentCount	^self size // 2</body><body package="FitLibrary-Internals">at: anInteger	(anInteger between: 1 and: self size)		ifFalse: 			[^(MissingCellsException details: 'at ' , anInteger printString) raise].	^super at: anInteger</body><body package="FitLibrary-Internals">beHidden	rowIsHidden := true.	self do: #beHidden</body><body package="FitLibrary-Internals">methodNameForCamel: aRuntimeContext	| ws |	ws := String new writeStream.	self everySecondDo: 			[:each |			ws				nextPutAll: (each resolvedText: aRuntimeContext);				space].	^aRuntimeContext extendedCamel: ws contents fitTrimSeparators</body><body package="FitLibrary-Internals">methodNameForPlain: aRuntimeContext	| ws result |	ws := String new writeStream.	self everySecondDo: 			[:each |			ws				nextPutAll: (each resolvedText: aRuntimeContext);				nextPut: $|].	result := ws contents.	^self size odd ifTrue: [result allButLast: 1] ifFalse: [result]</body><body package="FitLibrary-Internals">resolvedTextAt: anIndex resolver: aVariableResolver	^(self at: anIndex) resolvedText: aVariableResolver</body><body package="FitLibrary-Internals">type	^'Row'</body></methods><methods><class-id>FitlibraryInternals.Row</class-id> <category>markup</category><body package="FitLibrary-Internals">error: anException resultsInto: aTestResults	(anException isKindOf: FitLibraryShowException)		ifTrue: [^self handleShow: anException].	^super error: anException resultsInto: aTestResults</body><body package="FitLibrary-Internals">fail: aTestResults	rowIsHidden		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	^super fail: aTestResults</body><body package="FitLibrary-Internals">ignore: aTestResults	self do: [:each | each ignore: aTestResults]</body><body package="FitLibrary-Internals">missing: aTestResults	self first expectedElementMissing: aTestResults</body><body package="FitLibrary-Internals">pass: aTestResults	rowIsHidden		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	^super pass: aTestResults</body><body package="FitLibrary-Internals">passKeywords: aTestResults	self everySecondDo: [:cell | cell pass: aTestResults]</body></methods><methods><class-id>FitlibraryInternals.Row</class-id> <category>private</category><body package="FitLibrary-Internals">handleShow: aFitLibraryShowException	(self addCell)		text: aFitLibraryShowException result htmlString;		shown</body></methods><methods><class-id>FitlibraryInternals.Row</class-id> <category>adding</category><body package="FitLibrary-Internals">addCell	| cell |	cell := self class elementClass new.	self add: cell.	^cell</body><body package="FitLibrary-Internals">addCellWithString: aString	| cell |	cell := self class elementClass withString: aString.	self add: cell.	^cell</body><body package="FitLibrary-Internals">addCellWithString: aString spanning: anInteger	| cell |	cell := self class elementClass withString: aString.	cell spanColumns: anInteger.	self add: cell.	^cell</body></methods><methods><class-id>FitlibraryInternals.Row</class-id> <category>enumerating</category><body package="FitLibrary-Internals">everySecondDo: aBlock	1 to: self size		by: 2		do: [:index | aBlock value: (self at: index)]</body><body package="FitLibrary-Internals">withResults: aTestResults pairsDo: aBlock	1 to: self size		by: 2		do: 			[:index |			| cell nextCell |			cell := self at: index.			nextCell := [self at: index + 1] on: MissingCellsException						do: [:ex | ^cell error: ex resultsInto: aTestResults].			aBlock value: cell value: nextCell]</body></methods><methods><class-id>FitlibraryInternals.Row</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	rowIsHidden := false</body></methods><methods><class-id>FitlibraryInternals.Row class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self tag: 'tr'</body><body package="FitLibrary-Internals">withCell: aCell	^(self new)		add: aCell;		yourself</body><body package="FitLibrary-Internals">withString: aString	^self withCell: (self elementClass withString: aString)</body></methods><methods><class-id>FitlibraryInternals.Row class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^Cell</body></methods><methods><class-id>FitlibraryInternals.InnerTableContext</class-id> <category>accessing</category><body package="FitLibrary-Internals">evaluator	^evaluator</body><body package="FitLibrary-Internals">row	^table at: rowIndex</body><body package="FitLibrary-Internals">rowIndex	^rowIndex</body><body package="FitLibrary-Internals">runtimeContext	^runtimeContext</body><body package="FitLibrary-Internals">table	^table</body><body package="FitLibrary-Internals">typedSubject	^typedSubject</body></methods><methods><class-id>FitlibraryInternals.InnerTableContext</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTypedSubject: aTypedObject table: aTable row: anInteger evaluator: anEvaluator runtimeContext: aRuntimeContext	typedSubject := aTypedObject.	table := aTable.	rowIndex := anInteger.	evaluator := anEvaluator.	runtimeContext := aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.InnerTableContext class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">forTypedSubject: aTypedObject table: aTable row: anInteger evaluator: anEvaluator runtimeContext: aRuntimeContext	^self new		setTypedSubject: aTypedObject		table: aTable		row: anInteger		evaluator: anEvaluator		runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.NotRejectedException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self messageText: 'Was not rejected'</body></methods><methods><class-id>FitlibraryInternals.SuiteWideRuntimeContext</class-id> <category>accessing</category><body package="FitLibrary-Internals">abandon: aBoolean	scope abandon: aBoolean</body><body package="FitLibrary-Internals">global	^global</body><body package="FitLibrary-Internals">reset	timeouts := Dictionary new</body><body package="FitLibrary-Internals">scope	scope ifNil: [^self error: 'No scope in runtime'].	^scope</body><body package="FitLibrary-Internals">setStopOnError: aBoolean	scope setStopOnError: aBoolean</body><body package="FitLibrary-Internals">tableEvaluator	^tableEvaluator</body><body package="FitLibrary-Internals">tableEvaluator: aTableEvaluator	tableEvaluator := aTableEvaluator</body><body package="FitLibrary-Internals">timeoutAt: aString ifAbsent: aBlock	^timeouts at: aString ifAbsent: aBlock</body><body package="FitLibrary-Internals">timeoutAt: aString put: anInteger	timeouts at: aString put: anInteger</body></methods><methods><class-id>FitlibraryInternals.SuiteWideRuntimeContext</class-id> <category>testing</category><body package="FitLibrary-Internals">isAbandoned: aTestResults	scope isAbandon ifTrue: [^true].	(scope isStopOnError and: [aTestResults hasProblems]) ifTrue: [^true].	aTestResults errors &gt;= maxErrorsBeforeStopping ifTrue: [^true].	aTestResults failed &gt;= maxFailsBeforeStopping ifTrue: [^true].	^false</body><body package="FitLibrary-Internals">isAddTimings	^addTimings</body></methods><methods><class-id>FitlibraryInternals.SuiteWideRuntimeContext</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setScope: aScope globalActionScope: aGlobalActionScope	timeouts := Dictionary new.	addTimings := false.	maxErrorsBeforeStopping := SmallInteger maxVal.	maxFailsBeforeStopping := SmallInteger maxVal.	scope := aScope.	global := aGlobalActionScope</body></methods><methods><class-id>FitlibraryInternals.SuiteWideRuntimeContext class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">scope: aScope globalActionScope: aGlobalActionScope	^self new setScope: aScope globalActionScope: aGlobalActionScope</body></methods><methods><class-id>FitlibraryInternals.PlugBoard class</class-id> <category>accessing</category><body package="FitLibrary-Internals">exceptionHandling	^ExceptionHandlingStandard new</body><body package="FitLibrary-Internals">lookupClosure	^LookupClosureStandard new</body><body package="FitLibrary-Internals">lookupTarget	^LookupMethodTargetStandard new</body><body package="FitLibrary-Internals">stringDifferencing	^StringDifferencingStandard new</body></methods><methods><class-id>FitlibraryInternals.InvalidMapString class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">string: aString	^self messageText: 'Invalid String for mapping: ' , aString</body></methods><methods><class-id>FitlibraryInternals.DoFlowOnTable</class-id> <category>private</category><body package="FitLibrary-Internals">addTimeTextTo: aRow startTime: anInteger	| endTime elapsedTime tooltip |	runtime configuration isAddTimings ifFalse: [^self].	endTime := Time millisecondClockValue.	elapsedTime := endTime - anInteger.	elapsedTime &gt; 0 ifFalse: [^self].	tooltip := (self formatTime: anInteger) , (String with: Character lf)				, (self formatTime: endTime).	aRow		addCellWithString: '&lt;span class="note" title="' , tooltip , '"&gt;&lt;i&gt;'				, elapsedTime printString , '&lt;/i&gt; ms&lt;/span&gt;'</body><body package="FitLibrary-Internals">callSetUpSutChain: anObject row: aRow resultsInto: aTestResults	setUpTearDown		callSetUpOnSutChain: anObject		row: aRow		resultsInto: aTestResults</body><body package="FitLibrary-Internals">formatTime: aMilliseconds	| ws |	ws := String new writeStream.	TimestampPrintPolicy		print: (TimeZone default				universalToLocal: (Timestamp fromMilliseconds: aMilliseconds))		on: ws		using: 'yyyymmdd hh:mm:ss.fff'.	^ws contents</body><body package="FitLibrary-Internals">mapOddballsIn: aRow variableResolver: aVariableResolver	"|add|class|as|name| =&gt; |add named|name|class|"	| className |	(aRow size = 4 and: 			[(aRow resolvedTextAt: 1 resolver: aVariableResolver) = 'add'				and: [(aRow resolvedTextAt: 3 resolver: aVariableResolver) = 'as']])		ifFalse: [^aRow].	className := aRow resolvedTextAt: 2 resolver: aVariableResolver.	aRow first text: 'add named'.	(aRow at: 2) text: (aRow resolvedTextAt: 4 resolver: aVariableResolver).	(aRow at: 3) text: className.	aRow removeElementAt: 4.	^aRow</body><body package="FitLibrary-Internals">pushOnScope: aTypedObject row: aRow resultsInto: aTestResults	scopeStack push: aTypedObject.	self		callSetUpSutChain: aTypedObject subject		row: aRow		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.DoFlowOnTable</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setFlowEvaluator: aFlowEvaluator scopeStack: aScopeStack setUpTearDown: aSetUpTearDown doFlower: aDoFlower	flowEvaluator := aFlowEvaluator.	scopeStack := aScopeStack.	setUpTearDown := aSetUpTearDown.	doFlower := aDoFlower</body></methods><methods><class-id>FitlibraryInternals.DoFlowOnTable</class-id> <category>running</category><body package="FitLibrary-Internals">handleActualDoFixture: aDoEvaluator row: aRow resultsInto: aTestResults	aDoEvaluator typedSystemUnderTest		ifNotNil: 			[:sut |			self pushOnScope: sut row: aRow resultsInto: aTestResults.			sut injectRuntime: runtime]</body><body package="FitLibrary-Internals">handleDomainFixture: aTypedObject row: aRow resultsInto: aTestResults	self pushOnScope: aTypedObject row: aRow resultsInto: aTestResults.	doFlower domainFixture: aTypedObject</body><body package="FitLibrary-Internals">handleSuiteFixture: aSuiteFixture typed: aTypedObject row: aRow resultsInto: aTestResults	doFlower suite: aSuiteFixture.	setUpTearDown		callSuiteSetUp: aSuiteFixture		row: aRow		resultsInto: aTestResults.	self pushOnScope: aTypedObject row: aRow resultsInto: aTestResults</body><body package="FitLibrary-Internals">runEvaluator: anEvaluator typedResult: aTypedObject onTable: aTable fromRow: anInteger resultsInto: aTestResults	| restOfTable row startTime rest |	restOfTable := aTable from: anInteger.	rest := restOfTable size.	row := aTable at: anInteger.	aTypedObject injectRuntime: runtime.	startTime := Time millisecondClockValue.	(anEvaluator isKindOf: DefineAction)		ifTrue: 			[self callSetUpSutChain: anEvaluator row: row resultsInto: aTestResults]		ifFalse: [self pushOnScope: aTypedObject row: row resultsInto: aTestResults].	anEvaluator interpretAfterFirstRow: restOfTable resultsInto: aTestResults.	self addTimeTextTo: row startTime: startTime.	(anEvaluator isKindOf: DefineAction)		ifTrue: 			[setUpTearDown				callTearDownOnSutChain: anEvaluator				row: row				resultsInto: aTestResults].	(restOfTable ~= aTable and: [restOfTable size &gt; rest])		ifTrue: [restOfTable do: [:each | aTable add: each]]</body><body package="FitLibrary-Internals">runTable: aTable resultsInto: aTestResults	| context startTime |	aTable keysAndValuesDo: 			[:rowIndex :eachRow |			| typedResult row |			row := eachRow.			(runtime isAbandoned: aTestResults)				ifTrue: [row ignore: aTestResults]				ifFalse: 					[(doFlower hasDomainCheck and: 							[row size = 1								and: [(row resolvedTextAt: 1 resolver: flowEvaluator) = 'checks']])						ifTrue: [doFlower setDomainToCheck]						ifFalse: 							[							[| cell |							cell := row first.							(cell hasEmbeddedTables: runtime variableResolver)								ifTrue: 									[doFlower runInnerTables: cell embeddedTables resultsInto: aTestResults]								ifFalse: 									[| subject |									row := self mapOddballsIn: row variableResolver: flowEvaluator.									runtime currentRow: row.									startTime := Time millisecondClockValue.									typedResult := flowEvaluator interpretRow: row resultsInto: aTestResults.									self addTimeTextTo: row startTime: startTime.									subject := typedResult subject.									typedResult injectRuntime: runtime.									context := InnerTableContext												forTypedSubject: typedResult												table: aTable												row: rowIndex												evaluator: flowEvaluator												runtimeContext: runtime.									(subject										fitLibraryRunTableFromContext: context										for: self										resultsInto: aTestResults) ifTrue: [^self]]]									on: Error									do: [:ex | row error: ex resultsInto: aTestResults].							aTestResults hasProblems ifTrue: [runtime checkStopOnError: aTestResults]]]]</body><body package="FitLibrary-Internals">runTable: aTable withRuntime: aRuntimeContext resultsInto: aTestResults	runtime := aRuntimeContext.	runtime currentTable: aTable.	runtime pushTestResults: aTestResults.	[self runTable: aTable resultsInto: aTestResults]		ensure: [runtime popTestResults]</body></methods><methods><class-id>FitlibraryInternals.DoFlowOnTable class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">flowEvaluator: aFlowEvaluator scopeStack: aScopeStack setUpTearDown: aSetUpTearDown doFlower: aDoFlower	^self new		setFlowEvaluator: aFlowEvaluator		scopeStack: aScopeStack		setUpTearDown: aSetUpTearDown		doFlower: aDoFlower</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCallManager</class-id> <category>private</category><body package="FitLibrary-Internals">clearShowsIfNoCallsInProgress	self hasNoOutstandingCalls ifFalse: [^self].	shows := Table new</body><body package="FitLibrary-Internals">ensureNotInfinite: aParameterBinder	(callsInProgress includes: aParameterBinder)		ifTrue: 			[^FitLibraryException				raiseErrorString: 'Infinite calling of defined actions']</body><body package="FitLibrary-Internals">hasNoOutstandingCalls	^callsInProgress isEmpty</body><body package="FitLibrary-Internals">hasShows	^shows notEmpty</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCallManager</class-id> <category>call tracking</category><body package="FitLibrary-Internals">endCall: aParameterBinder	| top |	top := callsInProgress removeLast.	top == aParameterBinder ifFalse: [self error: 'Unstack-like behavior']</body><body package="FitLibrary-Internals">startCall: aParameterBinder	self clearShowsIfNoCallsInProgress.	self ensureNotInfinite: aParameterBinder.	callsInProgress addLast: aParameterBinder</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCallManager</class-id> <category>showing</category><body package="FitLibrary-Internals">addShow: aRow	self hasNoOutstandingCalls ifTrue: [^self].	shows add: aRow deepCopy</body><body package="FitLibrary-Internals">showsTable	^shows</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCallManager</class-id> <category>testing</category><body package="FitLibrary-Internals">readyToShow	^self hasNoOutstandingCalls and: [self hasShows]</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCallManager</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	callsInProgress := OrderedCollection new.	shows := Table new</body></methods><methods><class-id>FitlibraryInternals.DefinedActionCallManager class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.SelfConstructorParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setParseMethod: aMethod receiver: aClass	parseMethod := aMethod.	receiver := aClass</body></methods><methods><class-id>FitlibraryInternals.SelfConstructorParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^receiver performMethod: parseMethod with: aString</body></methods><methods><class-id>FitlibraryInternals.SelfConstructorParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">findSelfConstructorParser: aClass	^(self findConstructor: aClass)		ifNotNil: [:constructor | ^self parseMethod: constructor receiver: aClass]</body><body package="FitLibrary-Internals">parseMethod: aMethod receiver: aClass	^self new setParseMethod: aMethod receiver: aClass</body></methods><methods><class-id>FitlibraryInternals.SelfConstructorParser class</class-id> <category>private</category><body package="FitLibrary-Internals">findConstructor: aClass	| currentClass |	currentClass := aClass class.	[currentClass isNil] whileFalse: 			[currentClass selectorsAndMethodsDo: 					[:eachSelector :eachMethod |					(self isConstructor: eachMethod forClass: aClass) ifTrue: [^eachMethod]].			currentClass := currentClass superclass].	^nil</body><body package="FitLibrary-Internals">isConstructor: aCompiledMethod forClass: aClass	| signature |	signature := (MethodSignature forMethod: aCompiledMethod in: aClass)				ifNil: [^false].	^(signature takes: (Array with: String)) and: [signature returns: aClass]</body></methods><methods><class-id>FitlibraryInternals.DelegatingParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	^delegateParser show: anObject</body></methods><methods><class-id>FitlibraryInternals.DelegatingParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	(aCell hasEmbeddedTables: evaluator)		ifTrue: [^self parseTable: aCell embeddedTable resultsInto: aTestResults].	^delegateParser parse: (aCell resolvedText: evaluator)</body></methods><methods><class-id>FitlibraryInternals.DelegatingParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setDelegateParser: aDelegateParser evaluator: anEvaluator type: aTypeAdapter	delegateParser := aDelegateParser.	evaluator := anEvaluator.	typeAdapter := aTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.DelegatingParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	(aCell hasEmbeddedTables: evaluator)		ifTrue: 			[^self				table: aCell embeddedTable				matches: anObject				resultsInto: aTestResults].	^delegateParser expected: (self parse: aCell resultsInto: aTestResults)		matches: anObject</body></methods><methods><class-id>FitlibraryInternals.DelegatingParser</class-id> <category>private</category><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| newInstance setUp |	newInstance := nil.	[newInstance := typeAdapter newInstance] on: Error		do: 			[:ex |			(PlugBoard lookupTarget findNewInstancePluginMethod: evaluator)				ifNil: [^(NoNullaryConstructor forClass: typeAdapter type) raise]				ifNotNil: 					[:fixturingMethod |					newInstance := fixturingMethod								invokeOnArguments: (Array with: typeAdapter type)]].	setUp := DomainObjectSetUpTraverse systemUnderTest: newInstance.	setUp		runtimeContext: evaluator runtimeContext;		interpretInnerTableWithinScope: aTable			runtimeContext: evaluator runtimeContext			resultsInto: aTestResults.	^newInstance</body><body package="FitLibrary-Internals">table: aTable matches: anObject resultsInto: aTestResults	| traverse |	traverse := DomainObjectCheckTraverse systemUnderTest: anObject				type: typeAdapter.	^traverse		doesInnerTablePass: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.DelegatingParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self error: 'No Traverse available'</body></methods><methods><class-id>FitlibraryInternals.DelegatingParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">delegateParser: aDelegateParser evaluator: anEvaluator type: aTypeAdapter	^self new		setDelegateParser: aDelegateParser		evaluator: anEvaluator		type: aTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.DispatchRowInFlow</class-id> <category>private</category><body package="FitLibrary-Internals">checkForAmbiguity: aCollection	| and ws valids locallyAmbiguous |	and := ' AND '.	ws := String new writeStream.	valids := 0.	locallyAmbiguous := false.	aCollection do: 			[:each |			each isValid				ifTrue: 					[valids := valids + 1.					ws						nextPutAll: and;						nextPutAll: each ambiguityErrorMessage]				ifFalse: 					[each isAmbiguous						ifTrue: 							[locallyAmbiguous := true.							ws								nextPutAll: and;								nextPutAll: each ambiguityErrorMessage]]].	(locallyAmbiguous or: [valids &gt; 1])		ifTrue: 			[| message |			message := ws contents.			(AmbiguousActionException				messageText: (message copyFrom: and size + 1 to: message size)) raise]</body><body package="FitLibrary-Internals">doCallersForRow: aRow sequencing: aBoolean	^(OrderedCollection new)		add: (DefinedActionCaller row: aRow runtimeContext: evaluator runtimeContext);		add: (MultiDefinedActionCaller row: aRow					runtimeContext: evaluator runtimeContext);		add: (SpecialCaller					row: aRow					evaluator: evaluator					lookupTarget: PlugBoard lookupTarget);		add: (PostFixSpecialCaller					row: aRow					evaluator: evaluator					sequencing: aBoolean);		add: (CreateFromClassNameCaller row: aRow evaluator: evaluator);		add: (DoActionCaller					row: aRow					evaluator: evaluator					sequencing: aBoolean					lookupTarget: PlugBoard lookupTarget);		add: (ActionSpecial					row: aRow					evaluator: evaluator					sequencing: aBoolean					lookupTarget: PlugBoard lookupTarget);		yourself</body><body package="FitLibrary-Internals">methodsAreMissing: aCollection possibleSequenceCall: aString	| messageBuilder |	messageBuilder := MissingMethodMessage new.	(aCollection select: #isProblem)		do: [:each | each problem fitLibraryAddToMissingMethodMessage: messageBuilder].	aString isEmpty ifFalse: [messageBuilder addSequenceCall: aString].	FitLibraryExceptionInHtml		raiseErrorString: messageBuilder message fitTrimSeparators</body><body package="FitLibrary-Internals">pickFrom: aCollection andRunValidOnRow: aRow resultsInto: aTestResults	| validAction result |	validAction := aCollection detect: #isValid ifNone: [^nil].	result := validAction run: aRow resultsInto: aTestResults.	((evaluator runtimeContext isAbandoned: aTestResults)		and: [aTestResults hasProblems not]) ifTrue: [aRow ignore: aTestResults].	^result</body><body package="FitLibrary-Internals">pickPartialErrorFrom: aCollection	aCollection		do: [:each | each isPartiallyValid ifTrue: [^each partialErrorMessage]].	^nil</body><body package="FitLibrary-Internals">possibleSequenceCallFrom: aRow	| ws |	aRow size &lt; 3 ifTrue: [^''].	ws := String new writeStream.	ws		nextPut: $#;		nextPutAll: (evaluator runtimeContext					extendedCamel: (aRow resolvedTextAt: 1 resolver: evaluator));		nextPut: $:.	aRow size - 2 timesRepeat: [ws nextPutAll: '_:'].	^ws contents</body><body package="FitLibrary-Internals">withDynamicSequencing: aBlock	dynamicSequencing := true.	^aBlock ensure: [dynamicSequencing := false]</body></methods><methods><class-id>FitlibraryInternals.DispatchRowInFlow</class-id> <category>testing</category><body package="FitLibrary-Internals">isDynamicSequencing	^dynamicSequencing</body></methods><methods><class-id>FitlibraryInternals.DispatchRowInFlow</class-id> <category>running</category><body package="FitLibrary-Internals">interpretRow: aRow resultsInto: aTestResults	| doCallers |	doCallers := self doCallersForRow: aRow sequencing: false.		[self checkForAmbiguity: doCallers.		[(self pickFrom: doCallers andRunValidOnRow: aRow resultsInto: aTestResults)		ifNotNil: [:result | ^result].	(aRow size &gt; 2 and: [sequencing not])		ifTrue: 			[self withDynamicSequencing: 					[| sequencingDoCallers |					sequencingDoCallers := self doCallersForRow: aRow sequencing: true.					self checkForAmbiguity: sequencingDoCallers.					(self						pickFrom: sequencingDoCallers						andRunValidOnRow: aRow						resultsInto: aTestResults) ifNotNil: [:result | ^result]]].	(self pickPartialErrorFrom: doCallers)		ifNotNil: [:partialError | (FitLibraryExceptionInHtml messageText: partialError) raise].	self methodsAreMissing: doCallers		possibleSequenceCall: (self possibleSequenceCallFrom: aRow)]			on: IgnoredException			do: 				[:ex |				"already dealt with"				]]			on: Error			do: [:ex | aRow error: ex resultsInto: aTestResults].	^TypedObject null</body></methods><methods><class-id>FitlibraryInternals.DispatchRowInFlow</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setEvaluator: anEvaluator sequencing: aBoolean	evaluator := anEvaluator.	sequencing := aBoolean.	dynamicSequencing := sequencing</body></methods><methods><class-id>FitlibraryInternals.DispatchRowInFlow class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">evaluator: anEvaluator sequencing: aBoolean	^self new setEvaluator: anEvaluator sequencing: aBoolean</body></methods><methods><class-id>FitlibraryInternals.CalledMethodTarget</class-id> <category>testing</category><body package="FitLibrary-Internals">exceptionIsExpected: aCell	^exceptionString = (aCell resolvedText: runtimeContext)</body><body package="FitLibrary-Internals">matches: aCell resultsInto: aTestResults	^	[resultParser		expectedCell: aCell		matches: self invoke		resultsInto: aTestResults]			on: Error			do: [:ex | false]</body><body package="FitLibrary-Internals">returns: aClass	^closure returns: aClass</body><body package="FitLibrary-Internals">returnsBoolean	^self returns: Boolean</body><body package="FitLibrary-Internals">returnsVoid	^self returns: Void</body></methods><methods><class-id>FitlibraryInternals.CalledMethodTarget</class-id> <category>private</category><body package="FitLibrary-Internals">collectCell: aCell argumentNumber: anInteger text: aString resultsInto: aTestResults catchParseError: aBoolean	aString = repeatString ifTrue: [^self].		[arguments at: anInteger		put: ((parameterParsers at: anInteger) parse: aCell				resultsInto: aTestResults)]			on: Error			do: 				[:ex |				aBoolean					ifTrue: 						[aCell error: ex resultsInto: aTestResults.						IgnoredException raise].				ex pass]</body><body package="FitLibrary-Internals">collectCellsFrom: aRow every: anInteger resultsInto: aTestResults catchParseError: aBoolean	1 to: arguments size		do: 			[:i |			| cell |			cell := aRow at: (i - 1) * anInteger + 1.			self				collectCell: cell				argumentNumber: i				text: (cell resolvedText: runtimeContext)				resultsInto: aTestResults				catchParseError: aBoolean]</body><body package="FitLibrary-Internals">invoke	^closure invoke</body><body package="FitLibrary-Internals">invokeOnArguments: aCollection	^closure invokeOnArguments: aCollection</body><body package="FitLibrary-Internals">invokeTypedOnArguments: aCollection	^closure invokeTypedOnArguments: aCollection</body></methods><methods><class-id>FitlibraryInternals.CalledMethodTarget</class-id> <category>accessing</category><body package="FitLibrary-Internals">everySecond: aBoolean	everySecond := aBoolean</body><body package="FitLibrary-Internals">owningClass	^closure owningClass</body><body package="FitLibrary-Internals">parameterParsers	^parameterParsers</body><body package="FitLibrary-Internals">parameterTypes	^closure parameterTypes</body><body package="FitLibrary-Internals">repeatString: aRepeatString exceptionString: anExceptionString	repeatString := aRepeatString.	exceptionString := anExceptionString</body><body package="FitLibrary-Internals">result	^resultParser show: self invoke</body><body package="FitLibrary-Internals">resultParser	^resultParser</body><body package="FitLibrary-Internals">resultStringFor: anObject	(self returns: String) ifTrue: [^anObject].	^resultParser show: anObject</body><body package="FitLibrary-Internals">selector	^closure selector</body><body package="FitLibrary-Internals">subject: anObject	closure subject: anObject</body></methods><methods><class-id>FitlibraryInternals.CalledMethodTarget</class-id> <category>running</category><body package="FitLibrary-Internals">checkResult: anObject expected: aCell showWrongs: showWrongsBoolean handleSubtype: handleSubtypeBoolean resultsInto: aTestResults	| valueParser |	valueParser := resultParser.	(handleSubtypeBoolean and: [closure notNil])		ifTrue: 			[valueParser := closure						specialisedResultParserFrom: resultParser						result: anObject						evaluator: evaluator].		[valueParser ifNil: [^NoValueProvidedException raise].	valueParser isShowAsHtml		ifTrue: 			[(valueParser expectedCell: aCell matches: anObject resultsInto: aTestResults)				ifTrue: 					[aCell pass: aTestResults.					^true].			aCell wrongHtml: (valueParser show: anObject) resultsInto: aTestResults.			^false].	(valueParser expectedCell: aCell matches: anObject resultsInto: aTestResults)		ifTrue: 			[aCell passIfNotEmbedded: aTestResults variableResolver: runtimeContext.			^true].	(showWrongsBoolean		and: [anObject isNil or: [(aCell hasEmbeddedTables: runtimeContext) not]])			ifTrue: 				[anObject isString					ifTrue: 						[aCell							failStringEquals: aTestResults							withMessage: (valueParser show: anObject)							variableResolver: runtimeContext]					ifFalse: 						[aCell							fail: aTestResults							withMessage: (valueParser show: anObject)							variableResolver: runtimeContext]].	^false]			on: Error			do: 				[:ex |				aCell error: ex resultsInto: aTestResults.				^false]</body><body package="FitLibrary-Internals">invokeAndCheckCell: aCell matchedAlready: aBoolean resultsInto: aTestResults	^	[self		checkResult: self invoke		expected: aCell		showWrongs: aBoolean		handleSubtype: false		resultsInto: aTestResults]			on: Error			do: 				[:ex |				aCell error: ex resultsInto: aTestResults.				^false]</body><body package="FitLibrary-Internals">invokeAndCheckForSpecial: aRow expectedCell: expectedCell fullRow: fullRow specialCell: specialCell resultsInto: aTestResults	| result exceptionExpected |	exceptionExpected := self exceptionIsExpected: expectedCell.		[	[	[result := self invokeOnRow: aRow resultsInto: aTestResults.	exceptionExpected		ifTrue: [expectedCell fail: aTestResults]		ifFalse: 			[self				checkResult: result				expected: expectedCell				showWrongs: true				handleSubtype: false				resultsInto: aTestResults]]			on: IgnoredException			do: 				[:ex |				"do nothing"				]]			on: FitLibraryShowException			do: 				[:ex |				specialCell error: aTestResults.				fullRow error: ex resultsInto: aTestResults]]			on: Error			do: [:ex | expectedCell error: ex expected: exceptionExpected resultsInto: aTestResults]</body><body package="FitLibrary-Internals">invokeAndCheckRow: aRow expectedCell: aCell handleSubtype: aBoolean resultsInto: aTestResults	| exceptionExpected |	exceptionExpected := self exceptionIsExpected: aCell.		[	[| result |	result := self invokeOnRow: aRow resultsInto: aTestResults.	exceptionExpected		ifTrue: [aCell fail: aTestResults]		ifFalse: 			[self				checkResult: result				expected: aCell				showWrongs: true				handleSubtype: aBoolean				resultsInto: aTestResults]]			on: IgnoredException			do: 				[:ex |				"do nothing"				]]			on: Error			do: [:ex | aCell error: ex expected: exceptionExpected resultsInto: aTestResults]</body><body package="FitLibrary-Internals">invokeForSpecial: aRow catchParseError: aBoolean operatorCell: aCell resultsInto: aTestResults		[self		collectCellsFrom: aRow		every: (everySecond ifTrue: [2] ifFalse: [1])		resultsInto: aTestResults		catchParseError: aBoolean]			on: Error			do: [:ex | ^(IgnoredException on: ex) raise].	[^self invokeOnArguments: arguments] on: FitLibraryShowException		do: 			[:ex |			aCell error: aTestResults.			ex pass]</body><body package="FitLibrary-Internals">invokeOnCell: aCell resultsInto: aTestResults	self		collectCell: aCell		argumentNumber: 1		text: (aCell resolvedText: runtimeContext)		resultsInto: aTestResults		catchParseError: true.	^self invokeOnArguments: arguments</body><body package="FitLibrary-Internals">invokeOnRow: aRow resultsInto: aTestResults		[self		collectCellsFrom: aRow		every: (everySecond ifTrue: [2] ifFalse: [1])		resultsInto: aTestResults		catchParseError: true]			on: Error			do: [:ex | ^(IgnoredException on: ex) raise].	^self invokeOnArguments: arguments</body><body package="FitLibrary-Internals">invokeTypedOn: aRow resultsInto: aTestResults		[self		collectCellsFrom: aRow		every: (everySecond ifTrue: [2] ifFalse: [1])		resultsInto: aTestResults		catchParseError: true]			on: Error			do: [:ex | ^(IgnoredException on: ex) raise].	^self invokeTypedOnArguments: arguments</body><body package="FitLibrary-Internals">notResult: anObject expectedIn: aCell resultsInto: aTestResults		[resultParser ifNil: [^NoValueProvidedException raise].	(resultParser		expectedCell: aCell		matches: anObject		resultsInto: aTestResults)			ifFalse: 				[aCell passIfNotEmbedded: aTestResults variableResolver: runtimeContext]			ifTrue: 				[(aCell hasEmbeddedTables: runtimeContext)					ifFalse: [aCell fail: aTestResults]]]			on: Error			do: [:ex | aCell error: ex resultsInto: aTestResults]</body></methods><methods><class-id>FitlibraryInternals.CalledMethodTarget</class-id> <category>markup</category><body package="FitLibrary-Internals">color: aRow right: aBoolean resultsInto: aTestResults	(everySecond not and: [aRow existsAt: 1])		ifTrue: [aRow first passOrFail: aBoolean resultsInto: aTestResults]		ifFalse: 			[1 to: aRow size				by: 2				do: [:i | (aRow at: i) passOrFail: aBoolean resultsInto: aTestResults]]</body></methods><methods><class-id>FitlibraryInternals.CalledMethodTarget</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setClosure: aMethodClosure evaluator: anEvaluator	everySecond := false.	closure := aMethodClosure.	evaluator := anEvaluator.	runtimeContext := anEvaluator runtimeContext.	arguments := Array new: self parameterTypes size.	parameterParsers := closure parameterParsers: anEvaluator.	resultParser := closure resultParser: anEvaluator</body><body package="FitLibrary-Internals">setEvaluator: anEvaluator	everySecond := false.	evaluator := anEvaluator.	runtimeContext := anEvaluator runtimeContext.	parameterParsers := Array new.	arguments := Array new.	closure := nil.	resultParser := nil</body></methods><methods><class-id>FitlibraryInternals.CalledMethodTarget class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">closure: aMethodClosure evaluator: anEvaluator	^self new setClosure: aMethodClosure evaluator: anEvaluator</body><body package="FitLibrary-Internals">evaluator: anEvaluator	^self new setEvaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.ConstantMethodTarget</class-id> <category>private</category><body package="FitLibrary-Internals">invoke	^value</body></methods><methods><class-id>FitlibraryInternals.ConstantMethodTarget</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setValue: anObject	value := anObject.	resultParser := GetterParser				parser: ((TypeAdapter adapterFor: value class) resultParser: evaluator)				method: nil</body></methods><methods><class-id>FitlibraryInternals.ConstantMethodTarget class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">value: anObject evaluator: anEvaluator	^(self evaluator: anEvaluator) setValue: anObject</body></methods><methods><class-id>FitlibraryInternals.MissingMethodMessage</class-id> <category>adding</category><body package="FitLibrary-Internals">addAllMissingMethods: aCollection	missingMethods addAll: aCollection</body><body package="FitLibrary-Internals">addAllPossibleClasses: aCollection	possibleClasses addAll: aCollection</body><body package="FitLibrary-Internals">addMissingMethod: aString	missingMethods add: aString</body><body package="FitLibrary-Internals">addSequenceCall: aString	missingMethods isEmpty ifTrue: [^aString].	^missingMethods add: aString</body></methods><methods><class-id>FitlibraryInternals.MissingMethodMessage</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	missingMethods := OrderedCollection new.	possibleClasses := Set new</body></methods><methods><class-id>FitlibraryInternals.MissingMethodMessage</class-id> <category>accessing</category><body package="FitLibrary-Internals">message	| ws |	ws := String new writeStream.	ws nextPutAll: 'Missing class or '.	missingMethods isEmpty		ifFalse: 			[ws				nextPutAll: 'Missing method. Possibly:';				nextPutAll: (MissingMethodException htmlListOfSignatures: missingMethods)].	possibleClasses isEmpty		ifFalse: 			[ws				nextPutAll: '&lt;hr/&gt;Possibly in class:';				nextPutAll: (MissingMethodException htmlListOfClassNames: possibleClasses)].	^ws contents fitTrimSeparators</body></methods><methods><class-id>FitlibraryInternals.MissingMethodMessage class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.ClassNotFoundException</class-id> <category>printing</category><body package="FitLibrary-Internals">description	^'Class not found: ' , parameter</body></methods><methods><class-id>FitlibraryInternals.FitLibrarySelectors class</class-id> <category>cache</category><body package="FitLibrary-Internals">cache	Cache ifNil: [self initializeCache].	^Cache</body><body package="FitLibrary-Internals">clearCache	Cache := nil</body><body package="FitLibrary-Internals">initializeCache	Cache := IdentityDictionary new.	Session when: SessionEnding send: #clearCache to: self</body></methods><methods><class-id>FitlibraryInternals.FitLibrarySelectors class</class-id> <category>utility</category><body package="FitLibrary-Internals">subject: anObject selectorsDo: aBlock	^(self selectorsFor: anObject) do: aBlock</body></methods><methods><class-id>FitlibraryInternals.FitLibrarySelectors class</class-id> <category>private</category><body package="FitLibrary-Internals">selectorsFor: anObject	^self selectorsForClass: anObject class		rejecting: [:each | (MethodSignature forSelector: each in: anObject) isNil]</body><body package="FitLibrary-Internals">selectorsForClass: aClass rejecting: aBlock	aClass ifNil: [^IdentitySet new].	^self cache at: aClass		ifAbsentPut: 			[(self selectorsForClass: aClass superclass rejecting: aBlock)				addAll: (aClass selectors reject: aBlock);				yourself]</body></methods><methods><class-id>FitlibraryInternals.FitLibraryExceptionWithHelp class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">messageText: messageString page: pageString	^self messageText: messageString</body></methods><methods><class-id>FitlibraryInternals.MissingCellsException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">details: aString	^self messageText: 'Missing table cells ' , aString		page: 'MissingCells.' , aString</body></methods><methods><class-id>FitlibraryInternals.TwoStageSpecial</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setSecondStageBlock: aBlock	secondStageBlock := aBlock</body></methods><methods><class-id>FitlibraryInternals.TwoStageSpecial</class-id> <category>running</category><body package="FitLibrary-Internals">runWithResults: aTestResults	^secondStageBlock value: aTestResults</body></methods><methods><class-id>FitlibraryInternals.TwoStageSpecial class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">secondStageBlock: aBlock	^self new setSecondStageBlock: aBlock</body></methods><methods><class-id>FitlibraryInternals.RowWrongWidthException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">expectedWidth: anInteger	^self		messageText: ('Row should be &lt;1p&gt; cells wide' expandMacrosWith: anInteger)</body></methods><methods><class-id>FitlibraryInternals.CreateFromClassNameCaller</class-id> <category>private</category><body package="FitLibrary-Internals">determineFullClass: aString	| fixtureName |	fixtureName := FixtureName fromString: aString.	(fixtureName potentialFixtureClassNames: self class packages) do: 			[:each |			(ClassNameConversion smalltalkName: each) classOrNil				ifNotNil: [:theClass | ^theClass]].	^ClassNotFoundException raiseWith: aString</body><body package="FitLibrary-Internals">isValidClassName: aString	aString isEmpty ifTrue: [^false].	(aString includes: Character space) ifTrue: [^false].	^(aString includes: $.) or: [aString first isUppercase]</body><body package="FitLibrary-Internals">passArgumentsIn: aRow to: anObject	aRow size &gt; 1 ifFalse: [^self].	(anObject respondsTo: #extractArgumentsForTable:) ifFalse: [^self].	anObject extractArgumentsForTable: (Table withRow: aRow) asParse</body><body package="FitLibrary-Internals">substituteName: aString	(#('Import' 'fit.Import' 'fit.Import') includes: aString)		ifTrue: [^'fitlibrary.DefaultPackages'].	^aString</body></methods><methods><class-id>FitlibraryInternals.CreateFromClassNameCaller</class-id> <category>testing</category><body package="FitLibrary-Internals">isValid	^object notNil or: [exceptionToThrow notNil]</body></methods><methods><class-id>FitlibraryInternals.CreateFromClassNameCaller</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	exceptionToThrow ifNotNil: [exceptionToThrow raise].	^TypedObject subject: object</body></methods><methods><class-id>FitlibraryInternals.CreateFromClassNameCaller</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^'class ' , className</body></methods><methods><class-id>FitlibraryInternals.CreateFromClassNameCaller</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRow: aRow evaluator: anEvaluator	"Maintain some backwards compatibility with Fitnesse by removing spaces from the class name.	FitLibrary2 removed this feature, but it breaks Fitnesse tests that are run with the FitLibrary2 FitServer.	Fitnesse does a full camel-casing of the name, but that introduces ambiguities when running the FitBook	and RPS examples."	| class rawClassName |	rawClassName := aRow resolvedTextAt: 1 resolver: anEvaluator.	"className := self substituteName: (ExtendedCamelCase camelClassName: rawClassName)."	className := self				substituteName: (rawClassName copyWithout: Character space).	(self isValidClassName: className) ifFalse: [^self].	class := [self determineFullClass: className] on: Error do: [:ex | ^self].		[	[object := class new.	self passArgumentsIn: aRow to: object]			on: Fit.Exceptions.ShouldNotImplement			do: [:ex | exceptionToThrow := NoNullaryConstructor className: className]]			on: Error			do: [:ex | exceptionToThrow := ex copyForReraise]</body></methods><methods><class-id>FitlibraryInternals.CreateFromClassNameCaller class</class-id> <category>default packages</category><body package="FitLibrary-Internals">addDefaultPackage: aString	"Maintain backwards compatibility with Fitnesse by passing the namespace to the Fixture loader as well.	This class is used for all normal fixture lookup in FitLibrary2, but not for ActionFixture&gt;&gt;start:, and Fitnesse	needs the default namespace lookup to be done there as well.  Java FitLibrary2 does not do this."	| namespaceName |	namespaceName := (PackageNameConversion javaName: aString) smalltalkName.	FixtureLoader current addNamespaceToPath: namespaceName.	self packages add: namespaceName</body><body package="FitLibrary-Internals">packages	| processEnvironment |	processEnvironment := Processor activeProcess environment.	^processEnvironment at: #packages		ifAbsent: [processEnvironment at: #packages put: (Set with: 'Fit')]</body></methods><methods><class-id>FitlibraryInternals.CreateFromClassNameCaller class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">row: aRow evaluator: anEvaluator	^self new setRow: aRow evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.Utility.MapElement</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setKey: keyObject value: valueObject	key := keyObject.	value := valueObject</body></methods><methods><class-id>FitlibraryInternals.Utility.MapElement class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">key: keyObject value: valueObject	^self new setKey: keyObject value: valueObject</body></methods><methods><class-id>FitlibraryInternals.HtmlParser</class-id> <category>testing</category><body package="FitLibrary-Internals">isShowAsHtml	^true</body></methods><methods><class-id>FitlibraryInternals.HtmlParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	^(self parse: aCell resultsInto: aTestResults) = anObject</body></methods><methods><class-id>FitlibraryInternals.HtmlParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTargetClass: aClass	targetClass := aClass</body></methods><methods><class-id>FitlibraryInternals.HtmlParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self error: 'No Traverse available'</body></methods><methods><class-id>FitlibraryInternals.HtmlParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">forClass: aClass	^self new setTargetClass: aClass</body></methods><methods><class-id>FitlibraryInternals.TreeParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^targetClass parseTree: (ListTree fitParse: aString)</body><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^self parse: aCell fullText</body></methods><methods><class-id>FitlibraryInternals.TreeParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	anObject ifNil: [^'null'].	^anObject fitToString</body></methods><methods><class-id>FitlibraryInternals.DoAutoWrapper</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setEvaluator: anEvaluator	evaluator := anEvaluator</body></methods><methods><class-id>FitlibraryInternals.DoAutoWrapper</class-id> <category>wrapping</category><body package="FitLibrary-Internals">wrap: aTypedObject	^aTypedObject		ifNil: [TypedObject null]		ifNotNil: [aTypedObject autoWrapped: evaluator]</body></methods><methods><class-id>FitlibraryInternals.DoAutoWrapper class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">evaluator: anEvaluator	^self new setEvaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.SelfParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^receiver performMethod: parseMethod with: aString</body></methods><methods><class-id>FitlibraryInternals.SelfParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setParseMethod: aMethod receiver: aClass	parseMethod := aMethod.	receiver := aClass</body></methods><methods><class-id>FitlibraryInternals.SelfParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">findSelfParser: aClass	^(self findParseMethod: aClass)		ifNotNil: [:parseMethod | self parseMethod: parseMethod receiver: aClass]</body><body package="FitLibrary-Internals">parseMethod: aMethod receiver: aClass	^self new setParseMethod: aMethod receiver: aClass</body></methods><methods><class-id>FitlibraryInternals.SelfParser class</class-id> <category>private</category><body package="FitLibrary-Internals">findParseMethod: aClass	^(aClass class findSelector: #fitParse:) ifNotNil: #last</body></methods><methods><class-id>FitlibraryInternals.TableListener</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setListener: aReportListener results: aTestResults	listener := aReportListener.	testResults := aTestResults</body></methods><methods><class-id>FitlibraryInternals.TableListener</class-id> <category>accessing</category><body package="FitLibrary-Internals">clearTestResults	testResults clear</body><body package="FitLibrary-Internals">testResults	^testResults</body></methods><methods><class-id>FitlibraryInternals.TableListener</class-id> <category>events</category><body package="FitLibrary-Internals">storytestFinished	listener tablesFinished: testResults</body><body package="FitLibrary-Internals">tableFinished: aTable	listener tableFinished: aTable</body></methods><methods><class-id>FitlibraryInternals.TableListener class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">listener: aReportListener	^self listener: aReportListener results: TestResults new</body><body package="FitLibrary-Internals">listener: aReportListener results: aTestResults	^self new setListener: aReportListener results: aTestResults</body><body package="FitLibrary-Internals">results: aTestResults	^self listener: EmptyFixtureListener new results: aTestResults</body></methods><methods><class-id>FitlibraryInternals.ColumnTarget</class-id> <category>acting</category><body package="FitLibrary-Internals">actOn: aCell resultsInto: aTestResults	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.ColumnTarget</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTarget: aCalledMethodTarget	target := aCalledMethodTarget</body></methods><methods><class-id>FitlibraryInternals.ColumnTarget</class-id> <category>testing</category><body package="FitLibrary-Internals">isOutput	^self subclassResponsibility</body></methods><methods><class-id>FitlibraryInternals.ColumnTarget class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">target: aCalledMethodTarget	^self new setTarget: aCalledMethodTarget</body></methods><methods><class-id>FitlibraryInternals.OutputColumnTarget</class-id> <category>testing</category><body package="FitLibrary-Internals">isOutput	^true</body></methods><methods><class-id>FitlibraryInternals.OutputColumnTarget</class-id> <category>acting</category><body package="FitLibrary-Internals">actOn: aCell resultsInto: aTestResults	target		invokeAndCheckCell: aCell		matchedAlready: true		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.ByStringParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	^anObject fitToString</body></methods><methods><class-id>FitlibraryInternals.ByStringParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expected: expectedObject matches: actualObject	"expectedObject will be a String"	expectedObject ifNil: [^actualObject isNil].	actualObject ifNil: [^false].	^expectedObject = actualObject fitToString</body><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	^self expected: (self parse: aCell resultsInto: aTestResults)		matches: anObject</body></methods><methods><class-id>FitlibraryInternals.ByStringParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setVariableResolver: aVariableResolver	variableResolver := aVariableResolver</body></methods><methods><class-id>FitlibraryInternals.ByStringParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^aCell resolvedText: variableResolver</body></methods><methods><class-id>FitlibraryInternals.ByStringParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self error: 'No Traverse available'</body></methods><methods><class-id>FitlibraryInternals.ByStringParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">variableResolver: aVariableResolver	^self new setVariableResolver: aVariableResolver</body></methods><methods><class-id>FitlibraryInternals.DefinedActionParameterTranslation class</class-id> <category>testing</category><body package="FitLibrary-Internals">needToTranslateParameters: aCollection inTables: aTables	aCollection isEmpty ifTrue: [^false].	aTables do: 			[:eachTable |			eachTable do: 					[:eachRow |					eachRow do: 							[:eachCell |							(aCollection								anySatisfy: [:eachParameter | eachCell textContains: '@{' , eachParameter , '}'])									ifTrue: [^false]]]].	^true</body></methods><methods><class-id>FitlibraryInternals.DefinedActionParameterTranslation class</class-id> <category>utility</category><body package="FitLibrary-Internals">translateParameters: aCollection inTables: aTables	| sorted newNames |	sorted := aCollection sorted: [:a :b | a size &gt; b size].	newNames := aCollection copy.	aTables do: 			[:eachTable |			eachTable do: 					[:eachRow |					eachRow do: 							[:eachCell |							sorted keysAndValuesDo: 									[:index :eachParameter |									| newParameter atParameter fullText |									fullText := eachCell fullText.									newParameter := 'paRameTer__' , index printString.									atParameter := '@{' , newParameter , '}'.									(eachCell textContains: atParameter)										ifFalse: 											[| replaced |											replaced := fullText copyReplaceAll: eachParameter with: atParameter.											replaced = fullText												ifFalse: 													[eachCell text: replaced.													newNames at: (aCollection indexOf: eachParameter) put: newParameter]]]]]].	^newNames</body></methods><methods><class-id>FitlibraryInternals.BooleanMethodException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">methodName: aString	^self messageText: 'Method ' , aString , ' does not return a boolean.'		page: 'BooleanConstraintMethod'</body></methods><methods><class-id>FitlibraryInternals.EmptyFixtureListener</class-id> <category>events</category><body package="FitLibrary-Internals">tableFinished: aTable	"do nothing"</body><body package="FitLibrary-Internals">tablesFinished: aTestResults	"do nothing"</body></methods><methods><class-id>FitlibraryInternals.DefinedMultiAction</class-id> <category>comparing</category><body package="FitLibrary-Internals">= anObject	(anObject isKindOf: self class) ifFalse: [^false].	^name = anObject name</body><body package="FitLibrary-Internals">hash	^name hash</body></methods><methods><class-id>FitlibraryInternals.DefinedMultiAction</class-id> <category>accessing</category><body package="FitLibrary-Internals">name	^name</body></methods><methods><class-id>FitlibraryInternals.DefinedMultiAction</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setName: aString	name := aString</body></methods><methods><class-id>FitlibraryInternals.DefinedMultiAction</class-id> <category>printing</category><body package="FitLibrary-Internals">printOn: aStream	aStream		nextPutAll: 'DefinedMultiAction[';		nextPutAll: name;		nextPut: $]</body></methods><methods><class-id>FitlibraryInternals.DefinedMultiAction class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">named: aString	^self new setName: aString</body></methods><methods><class-id>FitlibraryInternals.DefinedAction</class-id> <category>printing</category><body package="FitLibrary-Internals">printOn: aStream	aStream		nextPutAll: 'DefinedAction[';		nextPutAll: name;		nextPut: $/;		print: argumentCount;		nextPut: $]</body></methods><methods><class-id>FitlibraryInternals.DefinedAction</class-id> <category>accessing</category><body package="FitLibrary-Internals">argumentCount	^argumentCount</body></methods><methods><class-id>FitlibraryInternals.DefinedAction</class-id> <category>comparing</category><body package="FitLibrary-Internals">= aDefinedAction	^super = aDefinedAction		and: [argumentCount = aDefinedAction argumentCount]</body><body package="FitLibrary-Internals">hash	^super hash hashMultiply bitXor: argumentCount hash</body></methods><methods><class-id>FitlibraryInternals.DefinedAction</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setArgumentCount: anInteger	argumentCount := anInteger</body></methods><methods><class-id>FitlibraryInternals.DefinedAction</class-id> <category>lookup</category><body package="FitLibrary-Internals">findCall: aString resultsInto: aCollection	ValidCall parseDefinedAction: aString named: name resultsInto: aCollection</body></methods><methods><class-id>FitlibraryInternals.DefinedAction class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">named: aString argumentCount: anInteger	^(self named: aString) setArgumentCount: anInteger</body></methods><methods><class-id>FitlibraryInternals.MatchOneMethodClosure</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setSpec: aMethodSpec subject: anObject selector: aSymbol	methodSpec := aMethodSpec.	subject := anObject.	selector := aSymbol</body></methods><methods><class-id>FitlibraryInternals.MatchOneMethodClosure</class-id> <category>private</category><body package="FitLibrary-Internals">aliasMatches	^(subject respondsTo: #aliasForSelector:)		and: [(subject aliasForSelector: methodSpec canonicalSelector) == selector]</body><body package="FitLibrary-Internals">hasSignature	signature := MethodSignature forSelector: selector in: subject.	^signature notNil</body><body package="FitLibrary-Internals">isDoAction	^signature takesOne: DoAction</body><body package="FitLibrary-Internals">isSpecialMethod	^(signature takes: (Array with: Row with: TestResults))		or: [signature takes: (Array with: TestResults with: Row)]</body><body package="FitLibrary-Internals">isSystemClass: aClass	(self nonSystemClasses includes: aClass) ifTrue: [^false].	^self systemNamespaces includes: aClass environment</body><body package="FitLibrary-Internals">isSystemMethod	| classAndMethod implementingClass |	classAndMethod := subject class findSelector: selector.	implementingClass := classAndMethod first.	compiledMethod := classAndMethod last.	((self isSystemClass: implementingClass) or: [self isSpecialMethod])		ifFalse: [^false].	(subject class respondsTo: #methodsThatAreVisible) ifFalse: [^true].	^(subject class methodsThatAreVisible includes: selector) not</body><body package="FitLibrary-Internals">methodSpecMatches	^methodSpec matchesSelector: selector</body><body package="FitLibrary-Internals">nonSystemClasses	^(OrderedCollection new)		add: GlobalActionScope;		add: CompareFilesFixture;		add: CompareFilesTraverse;		add: SuiteWideRuntimeContext;		add: AbstractFileHandler;		yourself</body><body package="FitLibrary-Internals">systemNamespaces	^(OrderedCollection new)		add: Fit;		add: Fitlibrary;		add: FitlibraryInternals;		add: Fitlibrary.Traverse;		add: Fitlibrary.Traverse.Workflow;		yourself</body></methods><methods><class-id>FitlibraryInternals.MatchOneMethodClosure</class-id> <category>accessing</category><body package="FitLibrary-Internals">closure	^MethodClosure forMethod: compiledMethod on: subject signature: signature</body></methods><methods><class-id>FitlibraryInternals.MatchOneMethodClosure</class-id> <category>testing</category><body package="FitLibrary-Internals">matches	self hasSignature ifFalse: [^false].	self methodSpecMatches ifFalse: [^false].	self isDoAction ifTrue: [^false].	self isSystemMethod ifTrue: [^false].	^true</body></methods><methods><class-id>FitlibraryInternals.MatchOneMethodClosure class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">spec: aMethodSpec subject: anObject selector: aSymbol	^self new setSpec: aMethodSpec subject: anObject selector: aSymbol</body></methods><methods><class-id>FitlibraryInternals.NoSuchPropertyException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">name: propertyNameString classNames: classNameString	^self		messageText: 'Could not find property ' , propertyNameString , ' in '				, classNameString</body></methods><methods><class-id>FitlibraryInternals.NoValueProvidedException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self messageText: 'No value provided'</body></methods><methods><class-id>FitlibraryInternals.ParameterBinder</class-id> <category>accessing</category><body package="FitLibrary-Internals">copyOfBody	^tables deepCopy</body><body package="FitLibrary-Internals">pageName	^pageName</body></methods><methods><class-id>FitlibraryInternals.ParameterBinder</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setFormalParameters: aCollection tables: aTables pageName: aString	formalParameters := aCollection.	tables := aTables.	pageName := aString</body></methods><methods><class-id>FitlibraryInternals.ParameterBinder</class-id> <category>binding</category><body package="FitLibrary-Internals">bindMultiParameters: parameterRow call: callRow into: aDynamicVariablesMap	callRow size = formalParameters size		ifFalse: 			[^FitLibraryException				raiseErrorString: ('Expected &lt;1p&gt; parameters but there were &lt;2p&gt;'						expandMacrosWith: formalParameters size						with: callRow size)].	callRow with: parameterRow		do: 			[:callCell :parameterCell |			| parameter |			parameter := parameterCell resolvedText: aDynamicVariablesMap.			aDynamicVariablesMap at: parameter				putParameter: ((callCell hasEmbeddedTables: aDynamicVariablesMap)						ifTrue: [callCell embeddedTables]						ifFalse: [callCell resolvedText: aDynamicVariablesMap])]</body><body package="FitLibrary-Internals">bindUni: aCollection into: aDynamicVariablesMap	aCollection size = formalParameters size		ifFalse: 			[^FitLibraryException				raiseErrorString: ('Expected &lt;1p&gt; parameters but there were &lt;2p&gt;'						expandMacrosWith: formalParameters size						with: aCollection size)].	formalParameters with: aCollection		do: [:formal :actual | aDynamicVariablesMap at: formal putParameter: actual]</body></methods><methods><class-id>FitlibraryInternals.ParameterBinder</class-id> <category>verifying</category><body package="FitLibrary-Internals">verifyHeader: aRow againstFormalParamtersUsingResolver: aVariableResolver	| seen |	aRow size = formalParameters size		ifFalse: 			[^FitLibraryException				raiseErrorString: ('Expected &lt;1p&gt; parameters but there were &lt;2p&gt;'						expandMacrosWith: formalParameters size						with: aRow size)].	seen := Set new.	aRow do: 			[:each |			| headerName |			headerName := each resolvedText: aVariableResolver.			(formalParameters includes: headerName)				ifFalse: 					[^FitLibraryException						raiseErrorString: 'Unknown parameter: ''' , headerName , ''''].			(seen includes: headerName)				ifTrue: 					[^FitLibraryException raiseErrorString: ('Duplicate parameter: ''&lt;1s&gt;'''								expandMacrosWith: headerName)].			seen add: headerName]</body></methods><methods><class-id>FitlibraryInternals.ParameterBinder class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">formalParameters: aCollection tables: aTables pageName: aString	^self new setFormalParameters: aCollection tables: aTables pageName: aString</body></methods><methods><class-id>FitlibraryInternals.Log.LogConfiguration</class-id> <category>logging</category><body package="FitLibrary-Internals">log: aString	appender append: aString</body></methods><methods><class-id>FitlibraryInternals.Log.LogConfiguration</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	appender := FitlibraryInternals.ShowAfterTableAppender new</body><body package="FitLibrary-Internals">setRuntimeContext: aRuntimeContext	appender := FitlibraryInternals.ShowAfterTableAppender runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.Log.LogConfiguration class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">runtimeContext: aRuntimeContext	^self new setRuntimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.ClassIsAbstract class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">forClass: aClass	^self messageText: 'Class is abstract: ' , aClass shortName</body></methods><methods><class-id>FitlibraryInternals.StringDifferencingStandard</class-id> <category>private</category><body package="FitLibrary-Internals">makeEndSpacesVisibleIn: aString	| result |	result := aString.	result first = Character space		ifTrue: [result := self visibleSpace , (result copyFrom: 2 to: result size)].	result last = Character space		ifTrue: 			[result := (result copyFrom: 1 to: result size - 1) , self visibleSpace].	^result</body><body package="FitLibrary-Internals">makeNestedSpacesVisibleIn: aString	((aString findString: '  ' startingAt: 1) &gt; 0		or: [(aString findString: '&amp;nbsp' startingAt: 1) &gt; 0])			ifTrue: 				[^aString copyReplaceAll: '  ' with: self visibleSpace , self visibleSpace].	^aString</body><body package="FitLibrary-Internals">markupDeletion: aString on: aWriteStream	^aWriteStream		nextPutAll: '&lt;strike&gt;' , (self makeEndSpacesVisibleIn: aString) , '&lt;/strike&gt;'</body><body package="FitLibrary-Internals">markupDifference: aSubsequenceDifference on: aWriteStream matchStatsInto: aStringMatchStats	| text |	text := String withAll: aSubsequenceDifference.	aSubsequenceDifference isDelete		ifTrue: [^self markupDeletion: text on: aWriteStream].	aSubsequenceDifference isInsert		ifTrue: [^self markupInsertion: text on: aWriteStream].	self markupMatch: text on: aWriteStream.	aStringMatchStats noteMatchOfSize: aSubsequenceDifference size</body><body package="FitLibrary-Internals">markupInsertion: aString on: aWriteStream	^aWriteStream		nextPutAll: '&lt;b&gt;' , (self makeEndSpacesVisibleIn: aString) , '&lt;/b&gt;'</body><body package="FitLibrary-Internals">markupMatch: aString on: aWriteStream	"divv is probably a typo here, but is in the original Java, so I kept it here; there's a spec test that depends on it"	aWriteStream		nextPutAll: '&lt;divv style=''color:white''&gt;' , aString , '&lt;/divv&gt;'</body><body package="FitLibrary-Internals">visibleSpace	^'&amp;Delta;'</body></methods><methods><class-id>FitlibraryInternals.StringDifferencingStandard</class-id> <category>comparing</category><body package="FitLibrary-Internals">differencesActual: actualString expected: expectedString	| diffs ws matchStats result |	(actualString size &lt; 6 or: [expectedString size &lt; 6]) ifTrue: [^''].	diffs := actualString differences: expectedString.	ws := String new writeStream.	ws nextPutAll: '&lt;hr&gt;'.	matchStats := diffs inject: StringMatchStats new				into: 					[:stats :each |					self markupDifference: each on: ws matchStatsInto: stats.					stats].	result := self makeNestedSpacesVisibleIn: ws contents.	matchStats isLowQualityMatch ifTrue: [^String new].	^result , (TableElement label: 'diff')</body></methods><methods><class-id>FitlibraryInternals.LocalFile</class-id> <category>constants</category><body package="FitLibrary-Internals">fitnesseFilesLocation	^'FitNesseRoot' , self localFiles</body><body package="FitLibrary-Internals">localFiles	^'/files'</body></methods><methods><class-id>FitlibraryInternals.LocalFile</class-id> <category>comparing</category><body package="FitLibrary-Internals">= aLocalFile	^filename = aLocalFile filename</body><body package="FitLibrary-Internals">hash	^filename hash</body></methods><methods><class-id>FitlibraryInternals.LocalFile</class-id> <category>accessing</category><body package="FitLibrary-Internals">filename	^filename</body><body package="FitLibrary-Internals">htmlImageLink	^'%&lt;img src="&lt;1s&gt;/&lt;2s&gt;"&gt;' expandMacrosWith: self localFiles with: filename</body><body package="FitLibrary-Internals">htmlLink	| name |	name := filename asFilename tail.	^'%&lt;a href="&lt;1s&gt;/&lt;2s&gt;"&gt;&lt;3s&gt;%&lt;/a&gt;'		expandMacrosWith: self localFiles		with: filename		with: name</body></methods><methods><class-id>FitlibraryInternals.LocalFile</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setFilename: aString	| prefix |	prefix := self localFiles copyWith: $/.	filename := (aString beginsWith: prefix)				ifTrue: [aString copyFrom: prefix size + 1 to: aString size]				ifFalse: [aString]</body></methods><methods><class-id>FitlibraryInternals.LocalFile</class-id> <category>converting</category><body package="FitLibrary-Internals">asFilename	((filename beginsWith: '/')		or: [filename size &gt;= 2 and: [(filename at: 2) = $:]])			ifTrue: [^filename asFilename].	^self fitnesseFilesLocation asFilename / filename</body></methods><methods><class-id>FitlibraryInternals.LocalFile class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">filename: aFilename	^self named: (aFilename asString copyReplaceAll: $\ with: $/)</body><body package="FitLibrary-Internals">named: aString	^self new setFilename: aString</body></methods><methods><class-id>FitlibraryInternals.Tables</class-id> <category>accessing</category><body package="FitLibrary-Internals">actualEmbeddedTables	^self</body><body package="FitLibrary-Internals">from: anIndex	^self from: anIndex to: self size</body><body package="FitLibrary-Internals">type	^tag</body></methods><methods><class-id>FitlibraryInternals.Tables</class-id> <category>printing</category><body package="FitLibrary-Internals">print: aString</body></methods><methods><class-id>FitlibraryInternals.Tables</class-id> <category>adding</category><body package="FitLibrary-Internals">addTables: aTables	aTables do: [:each | self add: each]</body></methods><methods><class-id>FitlibraryInternals.Tables</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryResolveInto: aTables	aTables addTables: self.	^''</body></methods><methods><class-id>FitlibraryInternals.Tables class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^Table</body></methods><methods><class-id>FitlibraryInternals.Tables class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">fromString: aString	^(TablesOnParse parse: (Parse input: aString)) asTablesOnList</body><body package="FitLibrary-Internals">new	^self tag: ''</body><body package="FitLibrary-Internals">withTable: aTable	^(self new)		add: aTable;		yourself</body></methods><methods><class-id>FitlibraryInternals.Tables class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitTypeAdapter	^TypeAdapterParserBridge type: self parserBlock: [TablesParser new]</body></methods><methods><class-id>FitlibraryInternals.SetParser</class-id> <category>private</category><body package="FitLibrary-Internals">targetClass	^Set</body><body package="FitLibrary-Internals">traverseClass	^SetTraverse</body></methods><methods><class-id>FitlibraryInternals.GenericSetParser</class-id> <category>private</category><body package="FitLibrary-Internals">makeTraverse: anObject	^(super makeTraverse: anObject)		componentType: componentType type;		yourself</body><body package="FitLibrary-Internals">parseNested: aTable resultsInto: aTestResults	| nestedSetUp |	nestedSetUp := NestingListSetUpTraverse componentAdapter: componentType.	nestedSetUp		interpretWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^Set withAll: nestedSetUp results</body><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| setUp |	(componentType isGeneric or: [componentType isForArray])		ifTrue: [^self parseNested: aTable resultsInto: aTestResults].	(CollectionSetUpTraverse hasObjectFactoryMethodFor: aTable		evaluator: evaluator)			ifTrue: [^super parseTable: aTable resultsInto: aTestResults].	setUp := GenericListSetUpTraverse forClass: componentType type.	setUp		interpretWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^Set withAll: setUp results</body><body package="FitLibrary-Internals">table: aTable matches: anObject resultsInto: aTestResults	componentType isGeneric		ifTrue: 			[| nestingList |			nestingList := NestingSetTraverse set: anObject type: componentType.			^nestingList				doesTablePass: aTable				runtimeContext: evaluator runtimeContext				resultsInto: aTestResults].	^super table: aTable matches: anObject resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.GenericSetParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setComponentType: aTypeAdapter	componentType := aTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.GenericSetParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">componentType: aTypeAdapter evaluator: anEvaluator	^(self evaluator: anEvaluator)		setComponentType: aTypeAdapter;		yourself</body></methods><methods><class-id>FitlibraryInternals.PrefixSpecialAction</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setActionContext: aSpecialActionContext	actionContext := aSpecialActionContext</body></methods><methods><class-id>FitlibraryInternals.PrefixSpecialAction</class-id> <category>private</category><body package="FitLibrary-Internals">basicTargetFrom: aRow	(aRow resolvedTextAt: 3 resolver: actionContext) = '='		ifTrue: 			[aRow size &lt; 4 ifTrue: [^(MissingCellsException details: 'Do') raise].			aRow size &gt; 4 ifTrue: [^(ExtraCellsException details: '') raise].			^nil].	^actionContext findMethodFromRow: aRow from: 3 extraCellsAtEnd: 0</body><body package="FitLibrary-Internals">targetFrom: aRow	(aRow size = 4 and: 			[(aRow resolvedTextAt: 3 resolver: actionContext) = 'to'				and: [(aRow at: 4) hasEmbeddedTables: actionContext]])		ifTrue: [^nil].	^self basicTargetFrom: aRow</body></methods><methods><class-id>FitlibraryInternals.PrefixSpecialAction</class-id> <category>actions</category><body package="FitLibrary-Internals">check: aRow	| target |	aRow size &lt;= 2 ifTrue: [^(MissingCellsException details: 'Do') raise].	target := actionContext findMethodFromRow: aRow from: 2 extraCellsAtEnd: 1.	^TwoStageSpecial secondStageBlock: 			[:testResults |			target				invokeAndCheckForSpecial: (aRow from: 3)				expectedCell: aRow last				fullRow: aRow				specialCell: aRow first				resultsInto: testResults]</body><body package="FitLibrary-Internals">set: aRow	| target |	aRow size &lt;= 2 ifTrue: [^(MissingCellsException details: 'Do') raise].	target := self targetFrom: aRow.	^TwoStageSpecial secondStageBlock: 			[:testResults |						[			[| variableName |			variableName := aRow resolvedTextAt: 2 resolver: actionContext.			target				ifNil: 					[((aRow at: 4) hasEmbeddedTables: actionContext)						ifTrue: 							[actionContext dynamicVariableAt: variableName								put: (aRow at: 4) embeddedTables]						ifFalse: 							[^FitLibraryException								raiseErrorString: 'OGNL not supported in Smalltalk FitLibrary']]				ifNotNil: 					[| result |					result := target								invokeForSpecial: (aRow from: 4)								catchParseError: true								operatorCell: aRow first								resultsInto: testResults.					actionContext dynamicVariableAt: variableName put: result]]					on: IgnoredException					do: 						[:ex |						"No result, so ignore"						]]					on: Error					do: [:ex | aRow error: ex resultsInto: testResults]			"target				invokeAndCheckForSpecial: (aRow from: 3)				expectedCell: aRow last				fullRow: aRow				specialCell: aRow first				resultsInto: testResults"]</body><body package="FitLibrary-Internals">setSymbolNamed: aRow	| target |	aRow size &lt;= 2 ifTrue: [^(MissingCellsException details: 'Do') raise].	target := self targetFrom: aRow.	^TwoStageSpecial secondStageBlock: 			[:testResults |						[			[| variableName |			variableName := aRow resolvedTextAt: 2 resolver: actionContext.			target				ifNil: 					[^FitLibraryException						raiseErrorString: 'OGNL not supported in Smalltalk FitLibrary']				ifNotNil: 					[| result |					result := target								invokeForSpecial: (aRow from: 4)								catchParseError: true								operatorCell: aRow first								resultsInto: testResults.					actionContext fitVariableAt: variableName put: result]]					on: IgnoredException					do: 						[:ex |						"No result, so ignore"						]]					on: Error					do: [:ex | aRow error: ex resultsInto: testResults]]</body></methods><methods><class-id>FitlibraryInternals.PrefixSpecialAction class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">actionContext: aSpecialActionContext	^self new setActionContext: aSpecialActionContext</body></methods><methods><class-id>FitlibraryInternals.GraphicParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anImageNameGraphic	anImageNameGraphic ifNil: [^'null'].	^anImageNameGraphic toGraphic htmlImageLink</body></methods><methods><class-id>FitlibraryInternals.GraphicParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^ImageNameGraphic parseGraphic: (self imageFileName: aString)</body><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^self parse: aCell fullText</body></methods><methods><class-id>FitlibraryInternals.GraphicParser</class-id> <category>private</category><body package="FitLibrary-Internals">imageFileName: aString	| match srcPos start end |	match := 'src="'.	srcPos := aString findString: match startingAt: 1.	srcPos isZero		ifTrue: [^self error: 'Not a valid graphic link: "' , aString , '"'].	start := srcPos + match size.	end := (aString				nextIndexOf: $"				from: start				to: aString size) ifNil: [0].	^LocalFile named: (aString copyFrom: start to: end - 1)</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPageSlowly</class-id> <category>private</category><body package="FitLibrary-Internals">createDefineActionTable: aTables	^(Table new)		add: (Row withString: 'DefineAction');		add: (Row withCell: (Cell withTables: aTables));		yourself</body><body package="FitLibrary-Internals">defineAction: aTables className: classNameString pageName: pageNameString	| defineAction |	defineAction := DefineAction wikiClassName: classNameString				pageName: pageNameString.	defineAction runtimeContext: runtimeContext.	defineAction define: (self createDefineActionTable: aTables)		resultsInto: TestResults new</body><body package="FitLibrary-Internals">determineClassNameFromPrefix: prefixString pageName: pageNameString	| fullPageName classPos |	fullPageName := pageNameString isEmpty				ifTrue: [prefixString]				ifFalse: [prefixString , '.' , pageNameString].	classPos := fullPageName findPreviousString: '.Class'				startingAt: fullPageName size.	classPos isZero		ifFalse: 			[| nextDotPos |			nextDotPos := (fullPageName						nextIndexOf: $.						from: classPos + 1						to: fullPageName size) ifNil: [0].			nextDotPos isZero				ifFalse: [^fullPageName copyFrom: classPos + 6 to: nextDotPos - 1]].	^''</body><body package="FitLibrary-Internals">parseDefinitions: aTables className: classNameString pageName: pageNameString	DefinedActionBodyCollector new definitionsIn: aTables		do: 			[:each |			self defineAction: each className: classNameString pageName: pageNameString]</body><body package="FitLibrary-Internals">processPages: aString</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPageSlowly</class-id> <category>accessing</category><body package="FitLibrary-Internals">fitnesseDirectory	^self class fitnesseDirectory</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPageSlowly</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTopPageName: aString runtimeContext: aRuntimeContext	topPageName := aString.	runtimeContext := aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPageSlowly</class-id> <category>processing</category><body package="FitLibrary-Internals">process	self processPages: (topPageName copyFrom: 2 to: topPageName size)</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPageSlowly class</class-id> <category>accessing</category><body package="FitLibrary-Internals">fitnesseDirectory	FitnesseDirectory ifNil: [self fitnesseDirectory: '.' asFilename].	^FitnesseDirectory</body><body package="FitLibrary-Internals">fitnesseDirectory: aFilenameOrString	FitnesseDirectory := aFilenameOrString asFilename.	Session		when: SessionEnding		do: [FitnesseDirectory := nil]		for: self</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPageSlowly class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">page: aString runtimeContext: aRuntimeContext	^self new setTopPageName: aString runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.FitServerBridge</class-id> <category>private</category><body package="FitLibrary-Internals">doTablesInHtml: aString	^self subclassResponsibility</body><body package="FitLibrary-Internals">exception: anError	| table |	table := Table withString: 'Exception occurred: '.	table first first error: anError resultsInto: suiteTestResults.	reportListener		tableFinished: table;		tablesFinished: suiteTestResults</body><body package="FitLibrary-Internals">processDocument: aString	| storyTestResults |	storyTestResults := self doTablesInHtml: aString.	suiteTestResults add: storyTestResults</body><body package="FitLibrary-Internals">readTable: aTable	| ws |	ws := String new writeStream.	aTable printHtmlOn: ws.	^ws contents asByteArrayEncoding: #'UTF-8'</body></methods><methods><class-id>FitlibraryInternals.FitServerBridge</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	reportListener := TableReportListener server: self.	suiteTestResults := TestResults new</body></methods><methods><class-id>FitlibraryInternals.FitServerBridge</class-id> <category>callbacks</category><body package="FitLibrary-Internals">sendTableReport: aTable	self sendTable: aTable</body><body package="FitLibrary-Internals">sendTestResults: aTestResults	self writeCounts: aTestResults counts</body></methods><methods><class-id>FitlibraryInternals.FitServerBridge</class-id> <category>accessing</category><body package="FitLibrary-Internals">exitCode	^suiteTestResults hasProblems ifTrue: [1] ifFalse: [0]</body></methods><methods><class-id>FitlibraryInternals.TestResults</class-id> <category>adding</category><body package="FitLibrary-Internals">add: aTestResults	counts tally: aTestResults counts</body><body package="FitLibrary-Internals">addRights: anInteger	counts right: counts right + anInteger</body><body package="FitLibrary-Internals">exception	counts incrementExceptions</body><body package="FitLibrary-Internals">fail	counts incrementWrong</body><body package="FitLibrary-Internals">ignore	counts incrementIgnores</body><body package="FitLibrary-Internals">pass	counts incrementRight</body></methods><methods><class-id>FitlibraryInternals.TestResults</class-id> <category>accessing</category><body package="FitLibrary-Internals">clear	counts clear</body><body package="FitLibrary-Internals">counts	^counts</body><body package="FitLibrary-Internals">errors	^counts exceptions</body><body package="FitLibrary-Internals">failed	^counts wrong</body><body package="FitLibrary-Internals">right	^counts right</body></methods><methods><class-id>FitlibraryInternals.TestResults</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">counts: aCounts	counts := aCounts</body><body package="FitLibrary-Internals">initialize	super initialize.	counts := Counts new</body></methods><methods><class-id>FitlibraryInternals.TestResults</class-id> <category>comparing</category><body package="FitLibrary-Internals">matchesRight: rightString wrong: wrongString ignores: ignoresString errors: errorsString	| values |	values := (Array				with: rightString				with: wrongString				with: ignoresString				with: errorsString) collect: [:each | Integer fitParse: each].	^counts = (Counts from: values)</body></methods><methods><class-id>FitlibraryInternals.TestResults</class-id> <category>printing</category><body package="FitLibrary-Internals">printOn: aStream	^counts printOn: aStream</body></methods><methods><class-id>FitlibraryInternals.TestResults</class-id> <category>testing</category><body package="FitLibrary-Internals">hasErrors	^self errors &gt; 0</body><body package="FitLibrary-Internals">hasFailed	^self failed &gt; 0</body><body package="FitLibrary-Internals">hasPassed	^self right &gt; 0 and: [self hasProblems not]</body><body package="FitLibrary-Internals">hasProblems	^self hasFailed or: [self hasErrors]</body></methods><methods><class-id>FitlibraryInternals.TestResults class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.SimpleWikiTranslator class</class-id> <category>private</category><body package="FitLibrary-Internals">clearWikiJunk: aString	| bold italics |	bold := String new: 3 withAll: $'.	italics := String new: 2 withAll: $'.	^(Array		with: bold		with: italics		with: '!-'		with: '-!') inject: aString			into: [:result :each | result copyReplaceAll: each with: '']</body><body package="FitLibrary-Internals">processTable: aString lines: aReadStream into: aWriteStream	| line |	aString ifNil: [^nil].	line := aString.	aWriteStream		nextPutAll: '&lt;table border="1" cellspacing="0"&gt;';		cr.	[line notNil and: [line beginsWith: '|']] whileTrue: 			[aWriteStream nextPutAll: '&lt;tr&gt;'.			(self splitCells: line) do: 					[:each |					aWriteStream						nextPutAll: '&lt;td&gt;';						nextPutAll: (self clearWikiJunk: each);						nextPutAll: '&lt;/td&gt;'].			aWriteStream				nextPutAll: '&lt;/tr&gt;';				cr.			line := aReadStream next].	aWriteStream		nextPutAll: '&lt;/table&gt;';		cr;		nextPutAll: '&lt;br/&gt;'.	^line</body><body package="FitLibrary-Internals">processText: aString lines: aReadStream into: aWriteStream	| line |	line := aString.	[line isNil] whileFalse: 			[(line beginsWith: '!') ifTrue: [line := line copyFrom: 2 to: line size].			(line beginsWith: '#')				ifTrue: 					["ignore it"					]				ifFalse: 					[(line beginsWith: '|!contents|')						ifTrue: 							[aWriteStream								nextPutAll: '&lt;br/&gt;';								cr]						ifFalse: 							[(line beginsWith: '|')								ifTrue: [^line]								ifFalse: 									[(line beginsWith: '----')										ifTrue: 											[aWriteStream												nextPutAll: '&lt;hr/&gt;';												cr]										ifFalse: 											[aWriteStream												nextPutAll: (self clearWikiJunk: line);												nextPutAll: '&lt;br/&gt;';												cr]]]].			line := aReadStream next].	^line</body><body package="FitLibrary-Internals">splitCells: aString	| result lastBar |	result := OrderedCollection new.	lastBar := 2.		[| bar |	bar := aString findString: '|' startingAt: lastBar.	bar isZero ifTrue: [^result].	result add: (bar = lastBar				ifTrue: ['']				ifFalse: [(aString copyFrom: lastBar to: bar - 1) fitTrimSeparators]).	lastBar := bar + 1]			repeat.	^result</body><body package="FitLibrary-Internals">translateLines: aReadStream into: aWriteStream	| result line |	result := String new writeStream.	result		nextPutAll: '&lt;html&gt;';		cr;		nextPutAll: '&lt;br/&gt;'.	line := aReadStream next.	[line isNil] whileFalse: 			[line := self processText: line lines: aReadStream into: result.			line := self processTable: line lines: aReadStream into: result].	result nextPutAll: '&lt;/html&gt;'.	aWriteStream nextPutAll: result contents</body></methods><methods><class-id>FitlibraryInternals.SimpleWikiTranslator class</class-id> <category>translating</category><body package="FitLibrary-Internals">translate: aString	| ws |	ws := String new writeStream.	self translateLines: (aString tokensBasedOn: Character cr) readStream		into: ws.	^ws contents replaceAll: Character cr with: Character lf</body></methods><methods><class-id>FitlibraryInternals.MethodLookup</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	lookupClosure := PlugBoard lookupClosure</body></methods><methods><class-id>FitlibraryInternals.MethodLookup</class-id> <category>lookup</category><body package="FitLibrary-Internals">findMethodClosure: aMethodSpec on: anObject	^lookupClosure findMethodClosure: aMethodSpec on: anObject</body><body package="FitLibrary-Internals">findPublicMethodClosure: aMethodSpec taking: aCollection on: anObject	^lookupClosure		findPublicMethodClosure: aMethodSpec		taking: aCollection		on: anObject</body><body package="FitLibrary-Internals">findSpecificMethod: aMethodSpec in: anObject evaluator: anEvaluator	^(self findMethodClosure: aMethodSpec on: anObject)		ifNotNil: [:methodClosure | CalledMethodTarget closure: methodClosure evaluator: anEvaluator]</body></methods><methods><class-id>FitlibraryInternals.MethodLookup class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.DefinedActionBodyCollector</class-id> <category>private</category><body package="FitLibrary-Internals">isHR: aString	aString ifNil: [^false].	^#('&lt;hr&gt;' '&lt;hr/&gt;')		anySatisfy: [:each | (aString findString: each startingAt: 1) &gt; 0]</body></methods><methods><class-id>FitlibraryInternals.DefinedActionBodyCollector</class-id> <category>parsing</category><body package="FitLibrary-Internals">definitionsIn: aTables do: aBlock	| defineTables |	defineTables := Tables new.	aTables do: 			[:each |			((self isHR: each leader) and: [defineTables isEmpty not])				ifTrue: 					[aBlock value: defineTables.					defineTables := Tables new].			(self isHR: each trailer)				ifTrue: 					[defineTables add: each.					aBlock value: defineTables.					defineTables := Tables new]				ifFalse: [defineTables add: each]].	defineTables isEmpty ifFalse: [aBlock value: defineTables]</body></methods><methods><class-id>FitlibraryInternals.SingleNestedTableException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self messageText: 'Single nested table expected'</body></methods><methods><class-id>FitlibraryInternals.ValidCall</class-id> <category>accessing</category><body package="FitLibrary-Internals">asPossibilityInto: aGlobalActionScope	| ws |	ws := String new writeStream.	ws nextPutAll: '&lt;table border="1" cellspacing="0"&gt;&lt;tr&gt;'.	self list do: 			[:each |			ws				nextPutAll: '&lt;td&gt;';				nextPutAll: each;				nextPutAll: '&lt;/td&gt;'].	ws nextPutAll: '&lt;/tr&gt;&lt;/table&gt;'.	aGlobalActionScope showAsAfterTableTitle: 'plain text'		contents: ws contents</body><body package="FitLibrary-Internals">list	^tableCall</body></methods><methods><class-id>FitlibraryInternals.ValidCall</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTableCall: aCollection	tableCall := aCollection</body></methods><methods><class-id>FitlibraryInternals.ValidCall class</class-id> <category>parsing</category><body package="FitLibrary-Internals">parseDefinedAction: callString named: nameString resultsInto: aCollection	| tableCall keys firstKey call method |	tableCall := OrderedCollection new.	keys := nameString tokensBasedOn: $|.	keys last isEmpty ifTrue: [keys removeLast].	firstKey := true.	call := keys inject: callString				into: 					[:rest :each |					| newRest |					newRest := rest.					firstKey						ifFalse: 							[| index |							index := newRest findString: each startingAt: 1.							index isZero ifTrue: [^self].							tableCall add: (newRest first: index - 1) fitTrimSeparators.							newRest := newRest allButFirst: index - 1].					firstKey := false.					(newRest beginsWith: each) ifFalse: [^self].					tableCall add: (self keyword: each).					newRest allButFirst: each size].	method := nameString.	[method last = $|] whileTrue: 			[tableCall add: call fitTrimSeparators.			method := method allButLast: 1.			call := ''].	call isEmpty ifFalse: [^self].	aCollection add: (self tableCall: tableCall)</body></methods><methods><class-id>FitlibraryInternals.ValidCall class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">tableCall: aCollection	^self new setTableCall: aCollection</body></methods><methods><class-id>FitlibraryInternals.ValidCall class</class-id> <category>private</category><body package="FitLibrary-Internals">keyword: aString	| trimmed |	trimmed := aString fitTrimSeparators.	trimmed isEmpty ifTrue: [^trimmed].	^'&lt;i&gt;' , trimmed , '&lt;/i&gt;'</body></methods><methods><class-id>FitlibraryInternals.NullParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	^false</body></methods><methods><class-id>FitlibraryInternals.NullParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	^''</body></methods><methods><class-id>FitlibraryInternals.FitHandler</class-id> <category>running</category><body package="FitLibrary-Internals">doTable: aTable fixture: aFixture evaluator: anEvaluator resultsInto: aTestResults	"Maintain backwards compatibility with Fitnesse by adding the fixture class' namespace to the list of default packages.      FitLibrary2 removed this feature, but it breaks Fitnesse tests that are run with the FitLibrary2 FitServer."	CreateFromClassNameCaller		addDefaultPackage: aFixture class environment fullName.	aFixture counts: aTestResults counts.	self substituteDynamicVariablesFrom: anEvaluator into: aTable.	aFixture doTable: aTable asParse</body><body package="FitLibrary-Internals">substituteDynamicVariablesFrom: anEvaluator into: aTable	aTable do: 			[:eachRow |			eachRow do: 					[:eachCell |					| resolvedText |					resolvedText := eachCell resolvedText: anEvaluator.					resolvedText = eachCell text ifFalse: [eachCell text: resolvedText]]]</body></methods><methods><class-id>FitlibraryInternals.ListParser</class-id> <category>private</category><body package="FitLibrary-Internals">targetClass	^OrderedCollection</body><body package="FitLibrary-Internals">traverseClass	^ListTraverse</body></methods><methods><class-id>FitlibraryInternals.GenericListParser</class-id> <category>private</category><body package="FitLibrary-Internals">makeTraverse: anObject	^(super makeTraverse: anObject)		componentType: componentType type;		yourself</body><body package="FitLibrary-Internals">parseNested: aTable resultsInto: aTestResults	| nestedSetUp |	nestedSetUp := NestingListSetUpTraverse componentAdapter: componentType.	nestedSetUp		interpretWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^nestedSetUp results</body><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| setUp |	componentType isGeneric		ifTrue: [^self parseNested: aTable resultsInto: aTestResults].	componentType isForPrimitiveType		ifTrue: 			[| setUpTraverse |			setUpTraverse := ArraySetUpTraverse						valueParser: (componentType parameterParser: evaluator).			setUpTraverse runtimeContext: evaluator runtimeContext.			setUpTraverse interpretAfterFirstRow: aTable resultsInto: aTestResults.			^setUpTraverse results asOrderedCollection].	(CollectionSetUpTraverse hasObjectFactoryMethodFor: aTable		evaluator: evaluator)			ifTrue: [^super parseTable: aTable resultsInto: aTestResults].	setUp := GenericListSetUpTraverse forClass: componentType type.	setUp		interpretWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^setUp results</body><body package="FitLibrary-Internals">table: aTable matches: anObject resultsInto: aTestResults	componentType isGeneric		ifTrue: 			[| nestingList |			nestingList := NestingListTraverse list: anObject type: componentType.			^nestingList				doesTablePass: aTable				runtimeContext: evaluator runtimeContext				resultsInto: aTestResults].	componentType isForPrimitiveType		ifTrue: 			[| arrayTraverse |			arrayTraverse := ArrayTraverse array: anObject asArray						componentType: componentType.			^arrayTraverse				doesInnerTablePass: aTable				runtimeContext: evaluator runtimeContext				resultsInto: aTestResults].	^super table: aTable matches: anObject resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.GenericListParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setComponentType: aTypeAdapter	componentType := aTypeAdapter.	componentType isGeneric		ifFalse: 			[valueParser := aTypeAdapter resultParser: evaluator.			showParser := valueParser]</body></methods><methods><class-id>FitlibraryInternals.GenericListParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">componentType: aTypeAdapter evaluator: anEvaluator	^(self evaluator: anEvaluator)		setComponentType: aTypeAdapter;		yourself</body></methods><methods><class-id>FitlibraryInternals.VariableResolution</class-id> <category>accessing</category><body package="FitLibrary-Internals">tables	^tables</body><body package="FitLibrary-Internals">text	^text</body></methods><methods><class-id>FitlibraryInternals.VariableResolution</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setText: aString tables: aTables	text := aString.	tables := aTables</body></methods><methods><class-id>FitlibraryInternals.VariableResolution class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">text: aString tables: aTables	^self new setText: aString tables: aTables</body></methods><methods><class-id>FitlibraryInternals.ExceptionHandlingStandard</class-id> <category>accessing</category><body package="FitLibrary-Internals">exceptionMessageFor: anError	^anError fitLibraryExceptionMessage</body></methods><methods><class-id>FitlibraryInternals.BadNumberException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self messageText: 'Invalid Number'</body></methods><methods><class-id>FitlibraryInternals.PlainTextAnalyser</class-id> <category>analysing</category><body package="FitLibrary-Internals">analyseAndReplaceRowsIn: aTable resultsInto: aTestResults	aTable keysAndValuesDo: 			[:index :each |			| newRow |			newRow := self analyseRow: each resultsInto: aTestResults.			aTable replaceAt: index with: newRow]</body></methods><methods><class-id>FitlibraryInternals.PlainTextAnalyser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setDefinedActionsRepository: aDefinedActionsRepository runtimeContext: aRuntimeContext	definedActionsRepository := aDefinedActionsRepository.	runtimeContext := aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.PlainTextAnalyser</class-id> <category>private</category><body package="FitLibrary-Internals">analyseRow: aRow resultsInto: aTestResults	| textCall results newRow |	textCall := aRow first fullText.	results := OrderedCollection new.	definedActionsRepository findPlainTextCall: textCall resultsInto: results.	results isEmpty		ifTrue: 			[aRow first errorMessage: 'Unknown action' resultsInto: aTestResults.			^aRow].	self removeShorterMatchesIn: results.	results size &gt; 1		ifTrue: 			[aRow first				errorMessage: 'Ambiguous action (see details in logs after table)'				resultsInto: aTestResults.			runtimeContext showAsAfterTableTitle: 'plain text'				contents: 'Possible action tables:&lt;br/&gt;'.			results do: [:each | each asPossibilityInto: runtimeContext global].			^aRow].	newRow := Row new.	results first list do: [:each | newRow addCellWithString: each].	^newRow</body><body package="FitLibrary-Internals">removeShorterMatchesIn: aCollection	| longest |	longest := aCollection inject: 0				into: [:max :each | max max: each list size].	aCollection		removeAll: (aCollection select: [:each | each list size &lt; longest])</body></methods><methods><class-id>FitlibraryInternals.PlainTextAnalyser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">definedActionsRepository: aDefinedActionsRepository runtimeContext: aRuntimeContext	^self new setDefinedActionsRepository: aDefinedActionsRepository		runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.NullFromClassFactoryMethod class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">forClass: aString	^self messageText: 'Unexpected null from method for type ' , aString</body></methods><methods><class-id>FitlibraryInternals.InputColumnTarget</class-id> <category>acting</category><body package="FitLibrary-Internals">actOn: aCell resultsInto: aTestResults	target invokeOnCell: aCell resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.InputColumnTarget</class-id> <category>testing</category><body package="FitLibrary-Internals">isOutput	^false</body></methods><methods><class-id>FitlibraryInternals.DoAction</class-id> <category>private</category><body package="FitLibrary-Internals">offsetArgumentCellAt: anInteger	| index |	index := sequencing				ifTrue: [innerFrom + anInteger]				ifFalse: [innerFrom + ((anInteger - 1) * 2) + 1].	^row at: index</body><body package="FitLibrary-Internals">runMarkingErrors: aBoolean	| parameterParsers testResults args |	parameterParsers := target parameterParsers.	testResults := runtime testResults.	args := Array new: parameterParsers size.	parameterParsers keysAndValuesDo: 			[:index :each |						[args at: index				put: (each parse: (self offsetArgumentCellAt: index)						resultsInto: testResults)]					on: Error					do: 						[:ex |						aBoolean							ifTrue: [(self offsetArgumentCellAt: index) error: ex resultsInto: testResults].						(IgnoredException on: ex) raise]].	^target invokeOnArguments: args</body></methods><methods><class-id>FitlibraryInternals.DoAction</class-id> <category>running</category><body package="FitLibrary-Internals">run	^self runMarkingErrors: true</body><body package="FitLibrary-Internals">runWithNoColoring	^self runMarkingErrors: false</body></methods><methods><class-id>FitlibraryInternals.DoAction</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTarget: aCalledMethodTarget row: aRow from: fromInteger to: toInteger sequencing: aBoolean runtimeContext: aRuntimeContext	target := aCalledMethodTarget.	row := aRow.	innerFrom := fromInteger.	sequencing := aBoolean.	runtime := aRuntimeContext.	innerFrom = 1		ifTrue: 			[from := toInteger + 1.			to := aRow size]		ifFalse: 			[from := 1.			to := innerFrom - 1]</body></methods><methods><class-id>FitlibraryInternals.DoAction</class-id> <category>markup</category><body package="FitLibrary-Internals">show: aStringOfHtml	runtime show: aStringOfHtml</body><body package="FitLibrary-Internals">showAfter: anObject	self showAfter: anObject as: 'Logs'</body><body package="FitLibrary-Internals">showAfter: anObject as: aString	runtime showAsAfterTableTitle: aString		contents: (target resultStringFor: anObject)</body><body package="FitLibrary-Internals">showResult: anObject	runtime show: (target resultStringFor: anObject)</body></methods><methods><class-id>FitlibraryInternals.DoAction</class-id> <category>accessing</category><body package="FitLibrary-Internals">cellAt: anInteger	| cell |	(anInteger between: 1 and: to - from + 1)		ifFalse: 			[^FitLibraryException				raiseErrorString: 'No special cell at ' , anInteger printString].	cell := row at: from + anInteger - 1.	^CellProxy		onCell: cell		variableResolver: runtime variableResolver		testResultsBlock: [runtime testResults]</body></methods><methods><class-id>FitlibraryInternals.DoAction class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">target: aCalledMethodTarget row: aRow from: fromInteger to: toInteger sequencing: aBoolean runtimeContext: aRuntimeContext	^self new		setTarget: aCalledMethodTarget		row: aRow		from: fromInteger		to: toInteger		sequencing: aBoolean		runtimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.GenericFinder</class-id> <category>finding</category><body package="FitLibrary-Internals">callFindStringMethod: aString	findStringMethod		ifNotNil: [^findStringMethod invokeOnArguments: (Array with: aString)].	aString isEmpty ifTrue: [^nil].	FitLibraryExceptionInHtml raiseErrorString: findExceptionMessage</body><body package="FitLibrary-Internals">find: aString	^self callFindStringMethod: aString</body></methods><methods><class-id>FitlibraryInternals.GenericFinder</class-id> <category>testing</category><body package="FitLibrary-Internals">hasFinderMethod	^findStringMethod notNil</body></methods><methods><class-id>FitlibraryInternals.GenericFinder</class-id> <category>private</category><body package="FitLibrary-Internals">buildFindExceptionMessage: anEvaluator	| ws |	ws := String new writeStream.	ws		nextPutAll: 'Either ';		nextPutAll: self shortClassName;		nextPutAll: ' is &lt;ul&gt;&lt;li&gt;A &lt;b&gt;Value Object&lt;/b&gt;. So missing parse method: ';		nextPutAll: typeAdapter type shortName;		nextPutAll: ' class&gt;&gt;fitParse:; or&lt;/li&gt;&lt;li&gt;An &lt;b&gt;Entity&lt;/b&gt;. So missing finder method: #find';		nextPutAll: self shortClassName;		nextPutAll: ':, possibly in classes:';		nextPutAll: (self names: (self potentialClasses: anEvaluator));		nextPutAll: '&lt;/li&gt;&lt;/ul&gt;'.	^ws contents</body><body package="FitLibrary-Internals">findMethodWithPrefix: aString taking: aCollection evaluator: anEvaluator	| methodSpec |	methodSpec := MethodSpec				baseName: aString , ' ' , self shortClassName				numArgs: 1				runtimeContext: anEvaluator runtimeContext.	^PlugBoard lookupTarget		findFixturingMethod: methodSpec		taking: aCollection		evaluator: anEvaluator</body><body package="FitLibrary-Internals">names: aCollection	^MissingMethodException htmlListOfClassNames: aCollection</body><body package="FitLibrary-Internals">potentialClasses: anEvaluator	^PlugBoard lookupTarget possibleClassesIn: anEvaluator scope</body><body package="FitLibrary-Internals">shortClassName	^typeAdapter type name asString</body></methods><methods><class-id>FitlibraryInternals.GenericFinder</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	showMethod		ifNotNil: [^showMethod invokeOnArguments: (Array with: anObject)].	anObject ifNil: [^''].	^anObject fitToString</body></methods><methods><class-id>FitlibraryInternals.GenericFinder</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setAdapter: aTypeAdapter evaluator: anEvaluator	typeAdapter := aTypeAdapter.	findExceptionMessage := self buildFindExceptionMessage: anEvaluator.	findStringMethod := self				findMethodWithPrefix: 'find'				taking: (Array with: String)				evaluator: anEvaluator.	showMethod := self				findMethodWithPrefix: 'show'				taking: (Array with: typeAdapter type)				evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.GenericFinder class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">for: aTypeAdapter evaluator: anEvaluator	^self new setAdapter: aTypeAdapter evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.AliasMethodSpec</class-id> <category>testing</category><body package="FitLibrary-Internals">matchesSelector: aSelector	^aSelector == selector</body></methods><methods><class-id>FitlibraryInternals.AliasMethodSpec</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setSelector: aSymbol	selector := aSymbol</body></methods><methods><class-id>FitlibraryInternals.AliasMethodSpec class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">selector: aSymbol	^self new setSelector: aSymbol</body></methods><methods><class-id>FitlibraryInternals.TablesOnParse</class-id> <category>enumeration</category><body package="FitLibrary-Internals">do: aBlock	self iterating: parse do: aBlock</body></methods><methods><class-id>FitlibraryInternals.TablesOnParse</class-id> <category>converting</category><body package="FitLibrary-Internals">asTablesOnList	^TableConversion convertTables: self to: Tables</body></methods><methods><class-id>FitlibraryInternals.TablesOnParse</class-id> <category>adding</category><body package="FitLibrary-Internals">add: aTable	parse ifNil: [parse := aTable parse].	parse last more: aTable parse.	^self</body><body package="FitLibrary-Internals">addTables: aTables	aTables do: [:each | self add: each]</body></methods><methods><class-id>FitlibraryInternals.TablesOnParse class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^TableOnParse</body></methods><methods><class-id>FitlibraryInternals.TablesOnParse class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">withTable: aTable	^self parse: aTable parse</body></methods><methods><class-id>FitlibraryInternals.CellOnParse</class-id> <category>accessing</category><body package="FitLibrary-Internals">embeddedTables	^TablesOnParse parse: parse parts</body><body package="FitLibrary-Internals">fullText	^parse body</body><body package="FitLibrary-Internals">resolvedText: aVariableResolver	| resolution |	parse body ifNil: [^''].	resolution := aVariableResolver resolve: parse body.	parse body = resolution text ifFalse: [parse body: resolution text].	self addTables: resolution tables.	^self text</body><body package="FitLibrary-Internals">text	parse body ifNil: [^''].	^parse text</body></methods><methods><class-id>FitlibraryInternals.CellOnParse</class-id> <category>enumeration</category><body package="FitLibrary-Internals">do: aBlock	self embeddedTables do: aBlock</body></methods><methods><class-id>FitlibraryInternals.CellOnParse</class-id> <category>adding</category><body package="FitLibrary-Internals">add: aTable	parse parts		ifNil: [parse parts: (TablesOnParse withTable: aTable) parse]		ifNotNil: [self embeddedTables add: aTable].	^self</body></methods><methods><class-id>FitlibraryInternals.CellOnParse class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">withString: aString	^self parse: (Parse tag: 'td' body: aString)</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTypeAdapter: aTypeAdapter editor: aPropertyEditor evaluator: anEvaluator	typeAdapter := aTypeAdapter.	editor := aPropertyEditor.	evaluator := anEvaluator</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser</class-id> <category>private</category><body package="FitLibrary-Internals">parse: aString	editor setAsText: aString.	^editor value</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^self parse: (aCell resolvedText: evaluator)</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	editor value: anObject.	^editor getAsText</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	^(self parse: aCell resultsInto: aTestResults) = anObject</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser class</class-id> <category>private</category><body package="FitLibrary-Internals">findPropertyEditor: aClass	^PropertyEditor forClass: aClass</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser class</class-id> <category>finding</category><body package="FitLibrary-Internals">findParserForType: aTypeAdapter evaluator: anEvaluator	| editor |	editor := (self findPropertyEditor: aTypeAdapter type) ifNil: [^nil].	^self for: aTypeAdapter editor: editor evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.PropertyEditorBasedParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">for: aTypeAdapter editor: aPropertyEditor evaluator: anEvaluator	^self new		setTypeAdapter: aTypeAdapter		editor: aPropertyEditor		evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.ScopeStack</class-id> <category>private</category><body package="FitLibrary-Internals">addClassOf: anObject to: aCollection	anObject ifNil: [^self].	((self toBeVisible: anObject)		and: [(aCollection includes: anObject class) not])			ifTrue: [aCollection add: anObject class].	(anObject respondsTo: #systemUnderTest)		ifTrue: [self addClassOf: anObject systemUnderTest to: aCollection]</body><body package="FitLibrary-Internals">addObject: aTypedObject to: aCollection	aTypedObject ifNil: [^self].	aTypedObject isNull ifTrue: [^self].	(aCollection includes: aTypedObject) ifTrue: [^self].	aCollection add: aTypedObject.	aTypedObject hasTypedSystemUnderTest		ifTrue: [self addObject: aTypedObject typedSystemUnderTest to: aCollection]</body><body package="FitLibrary-Internals">toBeVisible: anObject	| namespace |	namespace := anObject class environment name.	(namespace beginsWith: 'Fitlibrary') ifFalse: [^true].	^namespace beginsWith: 'Fitlibrary.Specify'</body></methods><methods><class-id>FitlibraryInternals.ScopeStack</class-id> <category>adding-removing</category><body package="FitLibrary-Internals">addGlobal: aTypedObject	globals add: aTypedObject</body><body package="FitLibrary-Internals">addObject: aTypedObject named: aString	selectObjects add: aTypedObject.	selectNames at: aString put: aTypedObject</body><body package="FitLibrary-Internals">clearAllButSuite	stack removeAll</body><body package="FitLibrary-Internals">poppedAtEndOfStoryTest	| result |	result := (self poppedAtEndOfTable)				addAll: selectObjects;				yourself.	selectObjects removeAll.	^result</body><body package="FitLibrary-Internals">poppedAtEndOfTable	| result |	result := stack reverse.	stack removeAll.	^result</body><body package="FitLibrary-Internals">push: aTypedObject	(suite isNil and: [aTypedObject subject isKindOf: SuiteFixture])		ifTrue: [^suite := aTypedObject].	(stack isEmpty and: [selectObjects isEmpty])		ifTrue: [selectObjects add: aTypedObject]		ifFalse: [stack addLast: aTypedObject]</body><body package="FitLibrary-Internals">removeTemporary: anEvaluator	stack removeLast subject == anEvaluator		ifFalse: [self error: 'Whoops, temporary was not on the top of the stack!']</body><body package="FitLibrary-Internals">temporarilyAdd: anEvaluator	stack addLast: (TypedObject subject: anEvaluator)</body></methods><methods><class-id>FitlibraryInternals.ScopeStack</class-id> <category>accessing</category><body package="FitLibrary-Internals">abandon: aBoolean	abandon := aBoolean</body><body package="FitLibrary-Internals">currentState	| originalSize |	originalSize := stack size.	^ScopeState restoreBlock: 			[| results |			results := OrderedCollection new.			[stack size &gt; originalSize] whileTrue: [results add: stack removeLast].			results]</body><body package="FitLibrary-Internals">objectsForLookup	| results |	results := OrderedCollection new.	stack reverseDo: [:each | self addObject: each to: results].	selectObjects do: [:each | self addObject: each to: results].	suite ifNotNil: [self addObject: suite to: results].	globals do: [:each | self addObject: each to: results].	self addObject: flowEvaluator to: results.	^results</body><body package="FitLibrary-Internals">possibleClasses	| results |	results := OrderedCollection new.	stack reverseDo: [:each | self addClassOf: each subject to: results].	selectObjects do: [:each | self addClassOf: each subject to: results].	suite ifNotNil: [self addClassOf: suite subject to: results].	globals		do: [:each | each == global ifFalse: [self addClassOf: each subject to: results]].	^results</body><body package="FitLibrary-Internals">select: aString	| typedObject |	typedObject := selectNames at: aString				ifAbsent: [^FitLibraryException raiseErrorString: 'Unknown name'].	selectObjects remove: typedObject.	selectObjects addFirst: typedObject</body><body package="FitLibrary-Internals">setRuntimeContextOf: anObject to: aRuntimeContext	(anObject respondsTo: #runtimeContext:)		ifTrue: [anObject runtimeContext: aRuntimeContext].	(anObject respondsTo: #systemUnderTest)		ifTrue: 			[self setRuntimeContextOf: anObject systemUnderTest to: aRuntimeContext]</body><body package="FitLibrary-Internals">setStopOnError: aBoolean	stopOnError := aBoolean</body><body package="FitLibrary-Internals">switchRuntime: aRuntimeContext	self setRuntimeContextOf: flowEvaluator subject to: aRuntimeContext.	globals		do: [:each | self setRuntimeContextOf: each subject to: aRuntimeContext]</body></methods><methods><class-id>FitlibraryInternals.ScopeStack</class-id> <category>testing</category><body package="FitLibrary-Internals">isAbandon	^abandon</body><body package="FitLibrary-Internals">isStopOnError	^stopOnError</body></methods><methods><class-id>FitlibraryInternals.ScopeStack</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setFlowEvaluator: aTraverse global: aTypedObject	stack := OrderedCollection new.	selectObjects := OrderedCollection new.	globals := OrderedCollection new.	selectNames := Dictionary new.	abandon := false.	stopOnError := false.	flowEvaluator := TypedObject subject: aTraverse.	global := aTypedObject.	globals add: global</body></methods><methods><class-id>FitlibraryInternals.ScopeStack class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">flowEvaluator: aTraverse global: anObject	^self new setFlowEvaluator: aTraverse global: anObject</body></methods><methods><class-id>FitlibraryInternals.SpecialCaller</class-id> <category>testing</category><body package="FitLibrary-Internals">isValid	^specialMethod notNil</body></methods><methods><class-id>FitlibraryInternals.SpecialCaller</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	twoStageSpecial		ifNotNil: 			[twoStageSpecial runWithResults: aTestResults.			^TypedObject null].	^specialMethod		invokeTypedOnArguments: (Array with: aRow with: aTestResults)</body></methods><methods><class-id>FitlibraryInternals.SpecialCaller</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^'Special #' , methodName , ':resultsInto: in '		, specialMethod owningClass fullName</body></methods><methods><class-id>FitlibraryInternals.SpecialCaller</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRow: aRow evaluator: anEvaluator lookupTarget: aLookupMethodTarget	methodName := aRow resolvedTextAt: 1 resolver: anEvaluator.	specialMethod := aLookupMethodTarget findSpecialMethodNamed: methodName				evaluator: anEvaluator.	specialMethod ifNil: [^self].	(specialMethod returns: TwoStageSpecial) ifFalse: [^self].		[[twoStageSpecial := specialMethod invokeOnArguments: (Array with: aRow)]		on: MissingMethodException		do: 			[:ex |			specialMethod := nil.			self problem: ex]]			on: Error			do: [:ex | specialMethod := nil]</body></methods><methods><class-id>FitlibraryInternals.SpecialCaller class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">row: aRow evaluator: anEvaluator lookupTarget: aLookupMethodTarget	^self new		setRow: aRow		evaluator: anEvaluator		lookupTarget: aLookupMethodTarget</body></methods><methods><class-id>FitlibraryInternals.ScopeState</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRestoreBlock: aBlock	restoreBlock := aBlock</body></methods><methods><class-id>FitlibraryInternals.ScopeState</class-id> <category>restoring</category><body package="FitLibrary-Internals">restore	^restoreBlock value</body></methods><methods><class-id>FitlibraryInternals.ScopeState class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">restoreBlock: aBlock	^self new setRestoreBlock: aBlock</body></methods><methods><class-id>FitlibraryInternals.ListTree</class-id> <category>adding</category><body package="FitLibrary-Internals">addChild: aListTree	children add: aListTree</body></methods><methods><class-id>FitlibraryInternals.ListTree</class-id> <category>private</category><body package="FitLibrary-Internals">removeTagsFrom: aString	| ws index |	ws := String new writeStream.	(aString tokensBasedOn: $&lt;) do: 			[:each |			index := each indexOf: $&gt;.			ws nextPutAll: (each copyFrom: index + 1 to: each size)].	^ws contents</body></methods><methods><class-id>FitlibraryInternals.ListTree</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitToString	| ws |	children isEmpty ifTrue: [^title].	ws := String new writeStream.	ws		nextPutAll: title;		nextPutAll: '&lt;ul&gt;'.	children do: 			[:each |			ws				nextPutAll: '&lt;li&gt;';				nextPutAll: each fitToString;				nextPutAll: '&lt;/li&gt;'].	ws nextPutAll: '&lt;/ul&gt;'.	^ws contents</body></methods><methods><class-id>FitlibraryInternals.ListTree</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setText: aString	text := (self removeTagsFrom: aString) fitTrimSeparators</body><body package="FitLibrary-Internals">setTitle: aString	title := aString.	self setText: title</body><body package="FitLibrary-Internals">setTitle: aString children: aCollection	self setTitle: aString.	children := aCollection</body></methods><methods><class-id>FitlibraryInternals.ListTree</class-id> <category>testing</category><body package="FitLibrary-Internals">isError	^false</body></methods><methods><class-id>FitlibraryInternals.ListTree</class-id> <category>accessing</category><body package="FitLibrary-Internals">clearChildren	children := OrderedCollection new</body><body package="FitLibrary-Internals">rawText	^text</body><body package="FitLibrary-Internals">text	| ws |	children isEmpty ifTrue: [^text].	ws := String new writeStream.	ws		nextPutAll: text;		nextPutAll: '&lt;ul&gt;'.	children do: 			[:each |			ws				nextPutAll: '&lt;li&gt;';				nextPutAll: each text;				nextPutAll: '&lt;/li&gt;'].	ws nextPutAll: '&lt;/ul&gt;'.	^ws contents</body></methods><methods><class-id>FitlibraryInternals.ListTree class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">children: anOrderedCollection	^self title: '' children: anOrderedCollection</body><body package="FitLibrary-Internals">fitParse: aString	| index tokens |	index := aString indexOfSubCollection: '&lt;ul&gt;' startingAt: 1.	index isZero ifTrue: [^self title: aString].	tokens := aString tokensBasedOn: $&lt;.	^index = 1		ifTrue: [self parse: '' tokens: tokens]		ifFalse: 			[| token |			token := tokens removeFirst.			self parse: token tokens: tokens]</body><body package="FitLibrary-Internals">parseTree: aTree	^aTree</body><body package="FitLibrary-Internals">title: aString	^self title: aString children: OrderedCollection new</body><body package="FitLibrary-Internals">title: aString children: aCollection	^self new setTitle: aString children: aCollection</body><body package="FitLibrary-Internals">title: aString tree: aListTree	^self title: aString children: (Array with: aListTree)</body></methods><methods><class-id>FitlibraryInternals.ListTree class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">parse: aString tokens: aCollection	| children nextToken title |	title := aString.	children := OrderedCollection new.	nextToken := aCollection removeFirst.		[aCollection isEmpty		or: [(nextToken beginsWith: 'ul&gt;') or: [nextToken beginsWith: '/li&gt;']]]			whileFalse: 				[title := title , '&lt;' , nextToken.				nextToken := aCollection removeFirst].	(nextToken beginsWith: 'ul&gt;')		ifTrue: [self parseItemsFrom: aCollection into: children]		ifFalse: 			[(nextToken beginsWith: '/li&gt;')				ifFalse: [Error raiseErrorString: 'Bad list starting from ' , nextToken]].	^self title: title children: children</body></methods><methods><class-id>FitlibraryInternals.ListTree class</class-id> <category>private</category><body package="FitLibrary-Internals">parseItemsFrom: tokenCollection into: childCollection	[tokenCollection isEmpty] whileFalse: 			[| token |			token := tokenCollection removeFirst.			(token beginsWith: '/ul&gt;') ifTrue: [^self].			(token beginsWith: 'li&gt;')				ifTrue: 					[| subTitle subTree |					subTitle := token copyFrom: 'li&gt;' size + 1 to: token size.					subTree := self parse: subTitle tokens: tokenCollection.					childCollection add: subTree]]</body></methods><methods><class-id>FitlibraryInternals.DefinedActionsRepositoryStandard</class-id> <category>lookup</category><body package="FitLibrary-Internals">findPlainTextCall: aString resultsInto: aCollection	definedActionMapForPlainText		keysDo: [:each | each findCall: aString resultsInto: aCollection]</body><body package="FitLibrary-Internals">lookupByCamelName: aString argumentCount: anInteger	^definedActionMapForCamel		at: (DefinedAction named: aString argumentCount: anInteger)		ifAbsent: [nil]</body><body package="FitLibrary-Internals">lookupByClass: classNameString byCamelName: actionNameString argumentCount: anInteger runtimeContext: aRuntimeContext	| macro superClass |	macro := DefinedAction named: actionNameString argumentCount: anInteger.	classMapForCamel at: classNameString		ifPresent: [:map | map at: macro ifPresent: [:substitution | ^substitution]].	superClass := aRuntimeContext dynamicVariables				stringAt: classNameString , '.super'.	(superClass notNil and: [superClass notEmpty])		ifTrue: 			[^self				lookupByClass: superClass				byCamelName: actionNameString				argumentCount: anInteger				runtimeContext: aRuntimeContext].	^definedActionMapForCamel at: macro ifAbsent: [nil]</body><body package="FitLibrary-Internals">lookupMulti: aString	^definedMultiActionMap at: (DefinedMultiAction named: aString)		ifAbsent: [nil]</body></methods><methods><class-id>FitlibraryInternals.DefinedActionsRepositoryStandard</class-id> <category>private</category><body package="FitLibrary-Internals">classMapForCamel: aString	| currentMap |	currentMap := definedActionMapForCamel.	(self wikiClassBased: aString)		ifTrue: 			[currentMap := classMapForCamel at: aString ifAbsentPut: [Dictionary new]].	^currentMap</body><body package="FitLibrary-Internals">classMapForPlain: aString	| currentMap |	currentMap := definedActionMapForPlainText.	(self wikiClassBased: aString)		ifTrue: 			[currentMap := classMapForCamel at: aString ifAbsentPut: [Dictionary new]].	^currentMap</body><body package="FitLibrary-Internals">wikiClassBased: aString	^aString notEmpty</body></methods><methods><class-id>FitlibraryInternals.DefinedActionsRepositoryStandard</class-id> <category>defining</category><body package="FitLibrary-Internals">defineCamelFromRow: aRow wikiClassName: classNameString binder: aParameterBinder runtimeContext: aRuntimeContext absoluteFileName: fileNameString	| name definedAction map |	name := aRow methodNameForCamel: aRuntimeContext.	definedAction := DefinedAction named: name				argumentCount: aRow argumentCount.	map := self classMapForCamel: classNameString.	map at: definedAction		ifPresent: 			[:binder |			^FitLibraryException				raiseErrorString: ('Duplicate defined action: &lt;1s&gt;/&lt;2p&gt; defined in &lt;3s&gt; but already defined in &lt;4s&gt;'						expandMacrosWith: name						with: aRow argumentCount						with: fileNameString						with: binder pageName)].	map at: definedAction put: aParameterBinder</body><body package="FitLibrary-Internals">defineFromRow: aRow wikiClassName: classNameString binder: aParameterBinder runtimeContext: aRuntimeContext absoluteFileName: fileNameString	self		defineCamelFromRow: aRow			wikiClassName: classNameString			binder: aParameterBinder			runtimeContext: aRuntimeContext			absoluteFileName: fileNameString;		definePlainFromRow: aRow			wikiClassName: classNameString			binder: aParameterBinder			runtimeContext: aRuntimeContext			absoluteFileName: fileNameString</body><body package="FitLibrary-Internals">defineMultiDefinedActionNamed: aString binder: aParameterBinder	definedMultiActionMap at: (DefinedMultiAction named: aString)		put: aParameterBinder</body><body package="FitLibrary-Internals">definePlainFromRow: aRow wikiClassName: classNameString binder: aParameterBinder runtimeContext: aRuntimeContext absoluteFileName: fileNameString	| name definedAction map |	name := aRow methodNameForPlain: aRuntimeContext.	definedAction := DefinedAction named: name				argumentCount: aRow argumentCount.	map := self classMapForPlain: classNameString.	map at: definedAction		ifPresent: 			[:binder |			^FitLibraryException				raiseErrorString: ('Duplicate defined action: &lt;1s&gt; defined in &lt;2s&gt; but already defined in &lt;3s&gt;'						expandMacrosWith: name						with: fileNameString						with: binder pageName)].	map at: definedAction put: aParameterBinder</body></methods><methods><class-id>FitlibraryInternals.DefinedActionsRepositoryStandard</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	self clear</body></methods><methods><class-id>FitlibraryInternals.DefinedActionsRepositoryStandard</class-id> <category>removing</category><body package="FitLibrary-Internals">clear	definedActionMapForPlainText := Dictionary new.	classMapForPlainText := Dictionary new.	definedActionMapForCamel := Dictionary new.	classMapForCamel := Dictionary new.	definedMultiActionMap := Dictionary new</body></methods><methods><class-id>FitlibraryInternals.DefinedActionsRepositoryStandard class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.ImageNameGraphic</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setExpectedFile: aLocalFile	expectedFile := aLocalFile</body></methods><methods><class-id>FitlibraryInternals.ImageNameGraphic</class-id> <category>comparing</category><body package="FitLibrary-Internals">= anImageNameGraphic	^expectedFile = anImageNameGraphic expectedFile</body></methods><methods><class-id>FitlibraryInternals.ImageNameGraphic</class-id> <category>accessing</category><body package="FitLibrary-Internals">expectedFile	^expectedFile</body></methods><methods><class-id>FitlibraryInternals.ImageNameGraphic</class-id> <category>converting</category><body package="FitLibrary-Internals">toGraphic	^expectedFile</body></methods><methods><class-id>FitlibraryInternals.ImageNameGraphic class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">expectedFile: aLocalFile	^self new setExpectedFile: aLocalFile</body><body package="FitLibrary-Internals">expectedFilename: aString	^self expectedFile: (LocalFile named: aString)</body><body package="FitLibrary-Internals">parseGraphic: aLocalFile	^self expectedFile: aLocalFile</body></methods><methods><class-id>FitlibraryInternals.ImageNameGraphic class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitTypeAdapter	^TypeAdapterParserBridge type: self		parserBlock: [GraphicParser forClass: self]</body></methods><methods><class-id>FitlibraryInternals.MissingRowException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">details: aString	^self messageText: 'Missing row' page: 'MissingRow.' , aString</body></methods><methods><class-id>FitlibraryInternals.RowProxy</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRowBlock: aBlock	rowBlock := aBlock</body></methods><methods><class-id>FitlibraryInternals.RowProxy</class-id> <category>showing</category><body package="FitLibrary-Internals">addShow: aString	(rowBlock value addCellWithString: aString) shown</body></methods><methods><class-id>FitlibraryInternals.RowProxy class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">rowBlock: aBlock	^self new setRowBlock: aBlock</body></methods><methods><class-id>FitlibraryInternals.DomainAdapter.StringAdapter</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setSubject: aString	subject := aString</body></methods><methods><class-id>FitlibraryInternals.DomainAdapter.StringAdapter</class-id> <category>accessing</category><body package="FitLibrary-Internals">systemUnderTest	^subject</body></methods><methods><class-id>FitlibraryInternals.DomainAdapter.StringAdapter class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">on: aString	^self new setSubject: aString</body></methods><methods><class-id>FitlibraryInternals.RowOnParse</class-id> <category>adding</category><body package="FitLibrary-Internals">add: aCell	parse parts		ifNil: [parse parts: aCell parse]		ifNotNil: [parse parts last more: aCell parse]</body></methods><methods><class-id>FitlibraryInternals.RowOnParse class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^CellOnParse</body></methods><methods><class-id>FitlibraryInternals.RowOnParse class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self parse: (Parse tag: 'tr' body: '')</body></methods><methods><class-id>FitlibraryInternals.LocalDynamicVariables</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setOuter: aDynamicVariablesMap	outer := aDynamicVariablesMap</body></methods><methods><class-id>FitlibraryInternals.LocalDynamicVariables</class-id> <category>accessing</category><body package="FitLibrary-Internals">at: aString	| result |	result := super at: aString.	(result isNil or: 			[(result fitToString findString: '@{' , aString , '}' startingAt: 1) isZero				not])		ifTrue: [^outer at: aString].	^result</body><body package="FitLibrary-Internals">at: aString put: anObject	(super at: aString)		ifNil: [outer at: aString put: anObject]		ifNotNil: [self at: aString putParameter: anObject]</body><body package="FitLibrary-Internals">at: aString putParameter: anObject	self basicAt: aString put: anObject</body><body package="FitLibrary-Internals">clearAll	outer clearAll</body><body package="FitLibrary-Internals">map	^outer map</body><body package="FitLibrary-Internals">popLocal	^outer</body><body package="FitLibrary-Internals">top	^outer top</body></methods><methods><class-id>FitlibraryInternals.LocalDynamicVariables class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">outer: aDynamicVariablesMap	^self new setOuter: aDynamicVariablesMap</body></methods><methods><class-id>FitlibraryInternals.ParseDelegation class</class-id> <category>registering</category><body package="FitLibrary-Internals">registerParseDelegateClass: delegateClass forClass: aClass	(SelfParser findSelfParser: delegateClass)		ifNil: 			[self error: 'Parse delegate class ' , delegateClass name						, ' does not have a suitable #fitParse: method.']		ifNotNil: [:delegate | self parseDelegates at: aClass put: delegate]</body><body package="FitLibrary-Internals">registerParseDelegateObject: anObject forClass: aClass		[self parseDelegates at: aClass		put: (DelegateObjectParser delegate: anObject)]			on: Error			do: 				[:ex |				^self error: 'Parse delegate object of class ' , anObject class name							, ' does not have a suitable #fitParse: method.']</body><body package="FitLibrary-Internals">registerSuperParseDelegate: anObject forClass: aClass		[self superParseDelegates at: aClass		put: (DelegateObjectSuperParser delegate: anObject)]			on: Error			do: 				[:ex |				^self error: 'Super parse delegate object of class ' , anObject class name							, ' does not have a suitable #fitParse: method.']</body></methods><methods><class-id>FitlibraryInternals.ParseDelegation class</class-id> <category>clearing</category><body package="FitLibrary-Internals">clearDelegatesForNextStorytest	ParseDelegates := Dictionary new.	SuperParseDelegates := Dictionary new</body></methods><methods><class-id>FitlibraryInternals.ParseDelegation class</class-id> <category>lookup</category><body package="FitLibrary-Internals">delegateForClass: aClass	self parseDelegates at: aClass ifPresent: [:delegate | ^delegate].	self superParseDelegates		keysAndValuesDo: [:class :delegate | (aClass includesBehavior: class) ifTrue: [^delegate]].	^nil</body></methods><methods><class-id>FitlibraryInternals.ParseDelegation class</class-id> <category>private</category><body package="FitLibrary-Internals">parseDelegates	^ParseDelegates ifNil: [ParseDelegates := Dictionary new]</body><body package="FitLibrary-Internals">superParseDelegates	^SuperParseDelegates ifNil: [SuperParseDelegates := Dictionary new]</body></methods><methods><class-id>FitlibraryInternals.ParseDelegation class</class-id> <category>testing</category><body package="FitLibrary-Internals">hasParseMethod: aClass	^(SelfParser findParseMethod: aClass) notNil</body></methods><methods><class-id>FitlibraryInternals.FoldFilter</class-id> <category>private</category><body package="FitLibrary-Internals">ignoreFold: aString	| s |	s := aString.		[| include endDiv |	include := s findString: '&lt;div class="included"&gt;' startingAt: 1.	include isZero ifTrue: [^s].	endDiv := s findString: '&lt;/div&gt;&lt;/div&gt;' startingAt: include.	endDiv isZero ifTrue: [^s].	s := (s copyFrom: 1 to: include - 1)				, (s copyFrom: endDiv + '&lt;/div&gt;&lt;/div&gt;' size to: s size)]			repeat</body></methods><methods><class-id>FitlibraryInternals.FoldFilter</class-id> <category>comparing</category><body package="FitLibrary-Internals">matchActual: actualString expected: expectedString	^downstream matchActual: (self ignoreFold: actualString)		expected: (self ignoreFold: expectedString)</body></methods><methods><class-id>FitlibraryInternals.FoldFilter</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setDownstream: aFilter	downstream := aFilter</body></methods><methods><class-id>FitlibraryInternals.FoldFilter class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">downstream: aFilter	^self new setDownstream: aFilter</body></methods><methods><class-id>FitlibraryInternals.GetterParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	^parser expectedCell: aCell matches: anObject resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.GetterParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	anObject ifNil: [^''].	^parser show: anObject</body></methods><methods><class-id>FitlibraryInternals.GetterParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setParser: aParser method: aMethodClosure	parser := aParser</body></methods><methods><class-id>FitlibraryInternals.GetterParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^parser parse: aCell resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.GetterParser</class-id> <category>testing</category><body package="FitLibrary-Internals">isShowAsHtml	^parser isShowAsHtml</body></methods><methods><class-id>FitlibraryInternals.GetterParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^parser traverseFor: aTypedObject</body></methods><methods><class-id>FitlibraryInternals.GetterParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">parser: aParser method: aMethodClosure	^self new setParser: aParser method: aMethodClosure</body></methods><methods><class-id>FitlibraryInternals.TablesCompare</class-id> <category>private</category><body package="FitLibrary-Internals">canonical: aString	| ignores |	ignores := (OrderedCollection new)				add: (String with: Character tab);				add: (String with: Character cr);				add: (String with: Character lf);				addAll: #('&lt;hr&gt;' '&lt;hr/&gt;' '&amp;nbsp;' '&lt;br&gt;' '&lt;br/&gt;' '&lt;br /&gt;');				yourself.	^(ignores inject: aString		into: [:result :each | result copyReplaceAll: each with: ''])			fitTrimSeparators</body><body package="FitLibrary-Internals">leader: actualString equalTo: expectedString path: pathString	(self text: actualString equalTo: expectedString orDefault: '&lt;html&gt;')		ifTrue: [^true].	errorReport		leaderWrongActual: actualString		expected: expectedString		path: pathString.	^false</body><body package="FitLibrary-Internals">size: actualInteger equalTo: expectedInteger path: aString	actualInteger = expectedInteger ifTrue: [^true].	errorReport		sizeWrongActual: actualInteger		expected: expectedInteger		path: aString.	^false</body><body package="FitLibrary-Internals">tagLine: actualString equalTo: expectedString path: pathString	(self		text: actualString		equalTo: expectedString		orDefault: 'border="1" cellspacing="0"') ifTrue: [^true].	errorReport		tagLineWrongActual: actualString		expected: expectedString		path: pathString.	^false</body><body package="FitLibrary-Internals">text: actualString equalTo: expectedString	| expected |	expected := self canonical: expectedString.	expected = 'IGNORE' ifTrue: [^true].	^matcherPipeline matchActual: (self canonical: actualString)		expected: expected</body><body package="FitLibrary-Internals">text: actualString equalTo: expectedString orDefault: defaultString	(expectedString isEmpty and: [actualString = defaultString])		ifTrue: [^true].	(actualString isEmpty and: [expectedString = defaultString])		ifTrue: [^true].	^self text: actualString equalTo: expectedString</body><body package="FitLibrary-Internals">trailer: actualString equalTo: expectedString path: pathString	(self text: actualString equalTo: expectedString orDefault: '&lt;/html&gt;')		ifTrue: [^true].	errorReport		trailerWrongActual: actualString		expected: expectedString		path: pathString.	^false</body></methods><methods><class-id>FitlibraryInternals.TablesCompare</class-id> <category>comparing</category><body package="FitLibrary-Internals">tables: actualTableElement equalTo: expectedTableElement	^self tables: actualTableElement equalTo: expectedTableElement path: ''</body><body package="FitLibrary-Internals">tables: actualTableElement equalTo: expectedTableElement path: aString	| actual expected count elementName furtherPath actualContainsHtmlDueToShow actualTables actualStream expectedStream |	actual := actualTableElement.	expected := expectedTableElement.	actualContainsHtmlDueToShow := false.	actual isCell		ifTrue: 			[((expected hasEmbeddedTables: variableResolver)				and: [actual fullText notEmpty and: [expected fullText isEmpty]])					ifTrue: 						[expected text: expected last trailer.						expected last trailer: ''].			(self text: actual fullText equalTo: expected fullText)				ifFalse: 					[((actual hasEmbeddedTables: variableResolver) not						and: [expected hasEmbeddedTables: variableResolver])							ifTrue: 								[								[actualTables := (TablesOnParse parse: (Parse input: actual fullText))											asTablesOnList.								(self									tables: actualTables									equalTo: expected embeddedTables									path: aString) ifFalse: [^false].								actualContainsHtmlDueToShow := true]										on: ParseException										do: 											[:ex |											errorReport												cellTextWrongActual: actual fullText												expected: expected fullText												path: aString.											^false]]							ifFalse: 								[errorReport									cellTextWrongActual: actual fullText									expected: expected fullText									path: aString.								^false]].			actual := actual embeddedTables.			expected := expected embeddedTables].	actualContainsHtmlDueToShow		ifFalse: 			[(self				leader: actual leader				equalTo: expected leader				path: aString) ifFalse: [^false].			(self				trailer: actual trailer				equalTo: expected trailer				path: aString) ifFalse: [^false].			(self				tagLine: actual tagLine				equalTo: expected tagLine				path: aString) ifFalse: [^false].			(self				size: actual size				equalTo: expected size				path: aString) ifFalse: [^false]].	count := 1.	actualStream := actual readStream.	expectedStream := expected readStream.	[actualStream atEnd] whileFalse: 			[| eachActual |			eachActual := actualStream next.			elementName := '&lt;1s&gt;[&lt;2p&gt;]' expandMacrosWith: eachActual type with: count.			furtherPath := aString isEmpty						ifTrue: [elementName]						ifFalse: [aString , '.' , elementName].			(self				tables: eachActual				equalTo: expectedStream next				path: furtherPath) ifFalse: [^false].			count := count + 1].	^true</body></methods><methods><class-id>FitlibraryInternals.TablesCompare</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initializeMatcherPipeline	matcherPipeline := FoldFilter downstream: (StackTraceFilter						downstream: (FitLabelMatcher downstream: StringMatcher new))</body><body package="FitLibrary-Internals">setErrorReport: aSpecifyErrorReport variableResolver: aVariableResolver	errorReport := aSpecifyErrorReport.	variableResolver := aVariableResolver.	self initializeMatcherPipeline</body></methods><methods><class-id>FitlibraryInternals.TablesCompare class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">errorReport: aSpecifyErrorReport variableResolver: aVariableResolver	^self new setErrorReport: aSpecifyErrorReport		variableResolver: aVariableResolver</body></methods><methods><class-id>FitlibraryInternals.Table</class-id> <category>replacing</category><body package="FitLibrary-Internals">replaceAt: anInteger with: aRow	anInteger &gt; self size ifFalse: [self removeElementAt: anInteger].	self add: aRow at: anInteger</body></methods><methods><class-id>FitlibraryInternals.Table</class-id> <category>markup</category><body package="FitLibrary-Internals">addFoldingText: aString	self addToTrailer: aString</body><body package="FitLibrary-Internals">ignore: aTestResults	self first ignore: aTestResults</body><body package="FitLibrary-Internals">pass: aTestResults	self first pass: aTestResults</body></methods><methods><class-id>FitlibraryInternals.Table</class-id> <category>converting</category><body package="FitLibrary-Internals">asParse	^self asTableOnParse asParse</body><body package="FitLibrary-Internals">asTableOnParse	^TableConversion convertTable: self to: TableOnParse</body></methods><methods><class-id>FitlibraryInternals.Table</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	self addToTag: ' border="1" cellspacing="0"'</body></methods><methods><class-id>FitlibraryInternals.Table</class-id> <category>accessing</category><body package="FitLibrary-Internals">at: anInteger	(self existsAt: anInteger)		ifFalse: [(MissingRowException details: '') raise].	^super at: anInteger</body><body package="FitLibrary-Internals">phaseBoundaryCount	| count |	count := (self leader fitLibrarySplit: '&lt;hr&gt;') size - 1.	count isZero ifFalse: [^count].	^(self leader fitLibrarySplit: '&lt;hr/&gt;') size - 1</body><body package="FitLibrary-Internals">type	^'Table'</body></methods><methods><class-id>FitlibraryInternals.Table</class-id> <category>adding</category><body package="FitLibrary-Internals">newRow	| row |	row := self class elementClass new.	self add: row.	^row</body></methods><methods><class-id>FitlibraryInternals.Table</class-id> <category>testing</category><body package="FitLibrary-Internals">hasRowsAfter: aRow	self do: [:each | each == aRow ifTrue: [^aRow ~~ self last]].	^false</body><body package="FitLibrary-Internals">isPlainTextTable	^self tagContains: 'plain_text_table'</body></methods><methods><class-id>FitlibraryInternals.Table class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self tag: 'table'</body><body package="FitLibrary-Internals">withRow: aRow	^(self new)		add: aRow;		yourself</body><body package="FitLibrary-Internals">withString: aString	^self withRow: (self elementClass withString: aString)</body></methods><methods><class-id>FitlibraryInternals.Table class</class-id> <category>accessing</category><body package="FitLibrary-Internals">elementClass	^Row</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDown</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	referenceCounter := SetUpTearDownReferenceCounter new</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDown</class-id> <category>private</category><body package="FitLibrary-Internals">send: aSelector to: anObject row: aRow resultsInto: aTestResults	[(anObject respondsTo: aSelector) ifTrue: [^anObject perform: aSelector]]		on: Error		do: [:ex | aRow error: ex resultsInto: aTestResults].	^nil</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDown</class-id> <category>accessing</category><body package="FitLibrary-Internals">callSetUpOnSutChain: anObject row: aRow resultsInto: aTestResults	| sut |	sut := (anObject isKindOf: TypedObject)				ifTrue: [anObject subject]				ifFalse: [anObject].	referenceCounter callSetUpOnNewReferences: sut		caller: (SetUpTearDownCaller				setUpTearDown: self				row: aRow				resultsInto: aTestResults)</body><body package="FitLibrary-Internals">callSuiteSetUp: aSuiteFixture row: aRow resultsInto: aTestResults	self		send: #suiteSetUp		to: aSuiteFixture		row: aRow		resultsInto: aTestResults</body><body package="FitLibrary-Internals">callSuiteTearDown: aSuiteFixture resultsInto: aTestResults	self		send: #suiteTearDown		to: aSuiteFixture		row: (Row withString: 'a')		resultsInto: aTestResults</body><body package="FitLibrary-Internals">callTearDownOnSutChain: anObject row: aRow resultsInto: aTestResults	referenceCounter callTearDownOnExpiredReferences: anObject		caller: (SetUpTearDownCaller				setUpTearDown: self				row: aRow				resultsInto: aTestResults)</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDown class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.SimpleParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	^adapter toString: anObject</body></methods><methods><class-id>FitlibraryInternals.SimpleParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setAdapter: aTypeAdapter evaluator: anEvaluator	adapter := aTypeAdapter.	evaluator := anEvaluator</body></methods><methods><class-id>FitlibraryInternals.SimpleParser</class-id> <category>private</category><body package="FitLibrary-Internals">basicParse: aString	| result |	(aString isEmpty and: [adapter allowNil]) ifTrue: [^nil].	result := adapter parse: aString.	^result</body><body package="FitLibrary-Internals">expectedTable: aTable matches: anObject resultsInto: aTestResults	| traverse |	traverse := DomainObjectCheckTraverse systemUnderTest: anObject				type: adapter.	^traverse		doesInnerTablePass: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults</body><body package="FitLibrary-Internals">parse: aString	^	[[self basicParse: aString] on: ArithmeticError		do: [:ex | BadNumberException raise]]			on: Fit.Exceptions.CouldNotParseException			do: [:ex | (CouldNotParseException class: adapter type text: aString) raise]</body><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| newInstance setUp |	newInstance := adapter newInstance.	setUp := DomainObjectSetUpTraverse systemUnderTest: newInstance				type: adapter.	setUp runtimeContext: evaluator runtimeContext.	setUp		interpretInnerTableWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^newInstance</body></methods><methods><class-id>FitlibraryInternals.SimpleParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	(aCell hasEmbeddedTables: evaluator)		ifTrue: 			[^self				expectedTable: aCell embeddedTable				matches: anObject				resultsInto: aTestResults].	^(self parse: aCell resultsInto: aTestResults) = anObject</body></methods><methods><class-id>FitlibraryInternals.SimpleParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	(aCell hasEmbeddedTables: evaluator)		ifTrue: [^self parseTable: aCell embeddedTable resultsInto: aTestResults].	(adapter allowNil and: [aCell isBlank: evaluator]) ifTrue: [^nil].	^self parse: (aCell resolvedText: evaluator)</body></methods><methods><class-id>FitlibraryInternals.SimpleParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self error: 'No Traverse available'</body></methods><methods><class-id>FitlibraryInternals.SimpleParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">for: aTypeAdapter evaluator: anEvaluator	^self new setAdapter: aTypeAdapter evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.DoActionCaller</class-id> <category>testing</category><body package="FitLibrary-Internals">isValid	^target notNil</body></methods><methods><class-id>FitlibraryInternals.DoActionCaller</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRow: aRow evaluator: anEvaluator sequencing: aBoolean lookupTarget: aLookupMethodTarget	methodName := aRow methodNameForCamel: anEvaluator runtimeContext.		[target := aLookupMethodTarget				findMethodByArityIn: aRow				from: 1				to: aRow size				doStyle: aBoolean not				evaluator: anEvaluator]			on: Error			do: [:ex | self problem: ex]</body></methods><methods><class-id>FitlibraryInternals.DoActionCaller</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^methodName , ' in ' , target owningClass name</body></methods><methods><class-id>FitlibraryInternals.DoActionCaller</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	| typedResult result |		[typedResult := target invokeTypedOn: (aRow from: 2)				resultsInto: aTestResults.	result := typedResult ifNotNil: #subject.	(result isKindOf: Boolean)		ifTrue: [target color: aRow right: result resultsInto: aTestResults].	^typedResult]			on: FitLibraryShowException			do: 				[:ex |				aRow first error: aTestResults.				ex pass]</body></methods><methods><class-id>FitlibraryInternals.DoActionCaller class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">row: aRow evaluator: anEvaluator sequencing: aBoolean lookupTarget: aLookupMethodTarget	^self new		setRow: aRow		evaluator: anEvaluator		sequencing: aBoolean		lookupTarget: aLookupMethodTarget</body></methods><methods><class-id>FitlibraryInternals.PositionedTarget</class-id> <category>testing</category><body package="FitLibrary-Internals">isFound	^specialTarget notNil and: [innerTarget notNil]</body><body package="FitLibrary-Internals">isPartiallyValid	^specialTarget notNil</body></methods><methods><class-id>FitlibraryInternals.PositionedTarget</class-id> <category>private</category><body package="FitLibrary-Internals">createArguments: aDoAction row: aRow resultsInto: aTestResults	innerFrom = 1		ifTrue: 			[^self createPostArguments: aDoAction row: aRow resultsInto: aTestResults].	^self createPreArguments: aDoAction row: aRow resultsInto: aTestResults</body><body package="FitLibrary-Internals">createPostArguments: aDoAction row: aRow resultsInto: aTestResults	| parameterParsers args parameterTypes |	parameterParsers := specialTarget parameterParsers.	parameterTypes := specialTarget parameterTypes.	args := Array new: parameterParsers size.	args at: 1 put: aDoAction.	2 to: parameterParsers size		do: 			[:index |			| parser |			parser := ((parameterTypes at: index) isForClass: Object)						ifTrue: [innerTarget resultParser]						ifFalse: [parameterParsers at: index].			args at: index				put: (parser parse: (aRow at: innerTo + ((index - 1) * 2))						resultsInto: aTestResults)].	^args</body><body package="FitLibrary-Internals">createPreArguments: aDoAction row: aRow resultsInto: aTestResults	| parameterParsers args parameterTypes |	parameterParsers := specialTarget parameterParsers.	parameterTypes := specialTarget parameterTypes.	args := Array new: parameterParsers size.	1 to: parameterParsers size - 1		do: 			[:index |			| parser |			parser := ((parameterTypes at: index) isForClass: Object)						ifTrue: [innerTarget resultParser]						ifFalse: [parameterParsers at: index].			args at: index				put: (parser parse: (aRow at: (index - 1) * 2 + 2) resultsInto: aTestResults)].	args at: args size put: aDoAction.	^args</body><body package="FitLibrary-Internals">determineInnerSignature: aCollection runtimeContext: aRuntimeContext	| spec |	sequencing		ifTrue: 			[^MethodSpec				baseName: (aCollection at: innerFrom)				numArgs: innerTo - innerFrom				runtimeContext: aRuntimeContext].	spec := MethodSpec numArgs: (innerTo - innerFrom + 1) // 2				runtimeContext: aRuntimeContext.	innerFrom to: innerTo		by: 2		do: [:index | spec addSegment: (aCollection at: index)].	^spec</body><body package="FitLibrary-Internals">operatorCell	^innerFrom = 1 ifTrue: [innerTo + 1] ifFalse: [1]</body></methods><methods><class-id>FitlibraryInternals.PositionedTarget</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^'Special #' , specialName , ' + #' , innerName , ' (in '		, specialTarget owningClass fullName , ' + '		, innerTarget owningClass fullName , ')'</body><body package="FitLibrary-Internals">partialErrorMessage	^innerTargetMissingMessage</body></methods><methods><class-id>FitlibraryInternals.PositionedTarget</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setEvaluator: anEvaluator cells: aCollection typedObject: aTypedObject method: aCompiledMethod from: fromInteger to: toInteger sequencing: aBoolean lookupTarget: aLookupMethodTarget	innerFrom := fromInteger.	innerTo := toInteger.	sequencing := aBoolean.	specialName := aCompiledMethod selector.	specialTarget := CalledMethodTarget				closure: (MethodClosure forMethod: aCompiledMethod on: aTypedObject subject)				evaluator: anEvaluator.	methodSpec := self determineInnerSignature: aCollection				runtimeContext: anEvaluator runtimeContext.	innerName := methodSpec canonicalSelector.		[innerTarget := aLookupMethodTarget findMethodMappedTo: methodSpec				evaluator: anEvaluator]			on: Error			do: [:ex | innerTargetMissingMessage := ex errorString]</body></methods><methods><class-id>FitlibraryInternals.PositionedTarget</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow runtimeContext: aRuntimeContext resultsInto: aTestResults	| args result |		[	[args := self				createArguments: (DoAction						target: innerTarget						row: aRow						from: innerFrom						to: innerTo						sequencing: sequencing						runtimeContext: aRuntimeContext)				row: aRow				resultsInto: aTestResults.	result := specialTarget invokeOnArguments: args.	(result isKindOf: Boolean)		ifTrue: [aRow first passOrFail: result resultsInto: aTestResults].	^TypedObject subject: result]			on: FitLibraryShowException			do: 				[:ex |				(aRow at: self operatorCell) error: aTestResults.				ex pass]]			on: Error			do: [:ex | aRow error: ex resultsInto: aTestResults].	^TypedObject null</body></methods><methods><class-id>FitlibraryInternals.PositionedTarget class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">evaluator: anEvaluator cells: aCollection typedObject: aTypedObject method: aCompiledMethod from: fromInteger to: toInteger sequencing: aBoolean lookupTarget: aLookupMethodTarget	^self new		setEvaluator: anEvaluator		cells: aCollection		typedObject: aTypedObject		method: aCompiledMethod		from: fromInteger		to: toInteger		sequencing: aBoolean		lookupTarget: aLookupMethodTarget</body></methods><methods><class-id>FitlibraryInternals.ListTreeError</class-id> <category>testing</category><body package="FitLibrary-Internals">isError	^true</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts</class-id> <category>logging</category><body package="FitLibrary-Internals">logAsAfterTableTitle: titleString contents: contentsString	| br existing |	br := (self isForLogging: titleString) ifTrue: [''] ifFalse: ['&lt;br/&gt;'].	existing := folds at: titleString ifAbsent: [''].	folds at: titleString put: existing , contentsString , br</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts</class-id> <category>showing</category><body package="FitLibrary-Internals">addAccumulatedFoldingTextTo: aTable	folds keysDo: [:each | self addAccumulatedFoldingTextAt: each to: aTable]</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts</class-id> <category>private</category><body package="FitLibrary-Internals">addAccumulatedFoldingTextAt: aString to: aTable	| text ws |	text := folds at: aString.	folds at: aString put: String new.	(text isNil or: [text fitTrimSeparators isEmpty]) ifTrue: [^self].	ws := (String new: 200) writeStream.	self writeCollapsibleSectionTitle: aString text: text to: ws.	aTable addFoldingText: ws contents</body><body package="FitLibrary-Internals">currentWriteCollapsibleSectionTitle: titleString text: textString to: aStream	"This version is for Fitnesse versions starting with 20121220."	| lf |	lf := Character lf.	aStream		nextPutAll: '&lt;div class="collapsible closed"&gt;';		nextPutAll: '&lt;ul&gt;';		nextPutAll: '&lt;li&gt;&lt;a href="#" class="expandall"&gt;Expand All&lt;/a&gt;&lt;/li&gt;';		nextPutAll: '&lt;li&gt;&lt;a href="#" class="collapseall"&gt;Collapse All&lt;/a&gt;&lt;/li&gt;';		nextPutAll: '&lt;/ul&gt;';		nextPut: lf;		nextPutAll: '&lt;p class="title"&gt;';		nextPutAll: titleString;		nextPutAll: '&lt;/p&gt;';		nextPut: lf;		nextPutAll: '&lt;div&gt;';		nextPut: lf;		nextPutAll: (self tabledText: textString title: titleString);		nextPut: lf;		nextPutAll: '&lt;/div&gt;&lt;/div&gt;';		nextPut: lf</body><body package="FitLibrary-Internals">isForLogging: titleString	^titleString = 'Logging'</body><body package="FitLibrary-Internals">originalWriteCollapsibleSectionTitle: titleString text: textString to: aStream	"This version is for Fitnesse versions &lt; 20121220."	| lf id |	lf := Character lf.	id := self class nextId.	aStream		nextPutAll: '&lt;div class="included"&gt;';		nextPut: lf;		nextPutAll: '&lt;div style="float: right;" class="meta"&gt;';		nextPut: lf;		nextPutAll: '&lt;a href="javascript:expandAll()"&gt;Expand All&lt;/a&gt; |';		nextPut: lf;		nextPutAll: '&lt;a href="javascript:collapseAll();"&gt;Collapse All&lt;/a&gt;&lt;/div&gt;';		nextPut: lf;		nextPutAll: '&lt;a href="javascript:toggleCollapsable(''';		print: id;		nextPutAll: ''');"&gt;';		nextPut: lf;		nextPutAll: '&lt;img src="/files/images/collapsableClosed.gif" class="left" id="img';		print: id;		nextPutAll: '"/&gt;&lt;/a&gt;';		nextPut: lf;		nextPutAll: '&amp;nbsp;&lt;span class="meta"&gt;';		nextPutAll: titleString;		nextPutAll: '&lt;/span&gt;&lt;div class="hidden" id="';		print: id;		nextPutAll: '"&gt;';		nextPut: lf;		nextPutAll: (self tabledText: textString title: titleString);		nextPut: lf;		nextPutAll: '&lt;/div&gt;&lt;/div&gt;';		nextPut: lf</body><body package="FitLibrary-Internals">tabledText: contentsString title: titleString	^(self isForLogging: titleString)		ifTrue: ['&lt;table border="1" cellspacing="0"&gt;' , contentsString , '&lt;/table&gt;']		ifFalse: ['&lt;pre&gt;' , contentsString , '&lt;/pre&gt;']</body><body package="FitLibrary-Internals">writeCollapsibleSectionTitle: titleString text: textString to: aStream	useOldMarkup		ifTrue: 			[self				originalWriteCollapsibleSectionTitle: titleString				text: textString				to: aStream]		ifFalse: 			[self				currentWriteCollapsibleSectionTitle: titleString				text: textString				to: aStream]</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts</class-id> <category>accessing</category><body package="FitLibrary-Internals">useOldMarkup: aBoolean	useOldMarkup := aBoolean</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	folds := Dictionary new.	useOldMarkup := UseOldMarkup</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts class</class-id> <category>ids</category><body package="FitLibrary-Internals">initializeNextId	NextId := 12345.	self resetNextIdAtSessionEnd</body><body package="FitLibrary-Internals">nextId	| result |	NextId ifNil: [self initializeNextId].	result := NextId.	NextId := NextId + 1.	^result</body><body package="FitLibrary-Internals">resetNextIdAtSessionEnd	Session		when: SessionEnding		do: [NextId := nil]		for: self</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.FoldingTexts class</class-id> <category>options</category><body package="FitLibrary-Internals">useOldMarkupByDefault: aBoolean	UseOldMarkup := aBoolean</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>testing</category><body package="FitLibrary-Internals">hasEmbeddedTables: aVariableResolver	self resolvedText: aVariableResolver.	^self notEmpty</body><body package="FitLibrary-Internals">isCell	^true</body><body package="FitLibrary-Internals">matchesTextInLowerCase: aString variableResolver: aVariableResolver	^(self resolvedTextLower: aVariableResolver) = aString asLowercase</body><body package="FitLibrary-Internals">textContains: aString	^(self fullText findString: aString startingAt: 1) &gt; 0</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>accessing</category><body package="FitLibrary-Internals">beHidden	cellIsInHiddenRow := true</body><body package="FitLibrary-Internals">embeddedTable	| tables |	tables := self embeddedTables.	tables size = 1 ifFalse: [^SingleNestedTableException raise].	^tables first</body><body package="FitLibrary-Internals">embeddedTables	^self from: 1</body><body package="FitLibrary-Internals">fullText	^fullText</body><body package="FitLibrary-Internals">isBlank: aVariableResolver	^(self resolvedText: aVariableResolver) isEmpty</body><body package="FitLibrary-Internals">resolvedText: aVariableResolver	| resolution |	resolution := aVariableResolver resolve: fullText.	self addTables: resolution tables.	fullText = resolution text ifFalse: [fullText := resolution text].	^self text</body><body package="FitLibrary-Internals">resolvedTextLower: aVariableResolver	^(self resolvedText: aVariableResolver) asLowercase</body><body package="FitLibrary-Internals">spanColumns: anInteger	anInteger &lt; 1 ifTrue: [^self].	self addToTag: (self columnSpanHtml: anInteger)</body><body package="FitLibrary-Internals">text	^(Parse unescape: (Parse removeNonBreakTags: fullText)) fitTrimSeparators</body><body package="FitLibrary-Internals">text: aString	fullText := aString</body><body package="FitLibrary-Internals">type	^'Cell'</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>markup</category><body package="FitLibrary-Internals">actualElementMissing: aTestResults	self fail: aTestResults.	self addToBody: (self label: 'surplus')</body><body package="FitLibrary-Internals">actualElementMissing: aString resultsInto: aTestResults	self fail: aTestResults.	fullText := Markup info: (Fixture escape: aString).	self addToBody: (self label: 'surplus')</body><body package="FitLibrary-Internals">addToBody: aString	fullText := fullText , aString</body><body package="FitLibrary-Internals">error: anError expected: aBoolean resultsInto: aTestResults	aBoolean		ifTrue: [self pass: aTestResults]		ifFalse: [self error: anError resultsInto: aTestResults]</body><body package="FitLibrary-Internals">error: anError resultsInto: aTestResults	cellIsInHiddenRow		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	self addToBody: (PlugBoard exceptionHandling exceptionMessageFor: anError).	self addToTag: self class errorMarkup.	aTestResults exception</body><body package="FitLibrary-Internals">errorMessage: aString resultsInto: aTestResults	cellIsInHiddenRow		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	self addToBody: '&lt;hr/&gt;' , (self class label: aString).	self addToTag: self class errorMarkup.	aTestResults exception</body><body package="FitLibrary-Internals">expectedElementMissing: aTestResults	self fail: aTestResults.	self addToBody: (self label: 'missing')</body><body package="FitLibrary-Internals">fail: aTestResults	cellIsInHiddenRow		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	^super fail: aTestResults</body><body package="FitLibrary-Internals">fail: aTestResults html: aString	self fail: aTestResults.	self addToBody: aString</body><body package="FitLibrary-Internals">fail: aTestResults withMessage: aString variableResolver: aVariableResolver	| resolvedText resolved |	self fail: aTestResults.	resolvedText := self resolvedText: aVariableResolver.	resolved := ''.	self text = resolvedText ifFalse: [resolved := ' = ' , resolvedText].	self		addToBody: resolved , (self label: 'expected') , '&lt;hr&gt;'				, (Fixture escape: aString) , (self label: 'actual')</body><body package="FitLibrary-Internals">failStringEquals: aTestResults withMessage: aString variableResolver: aVariableResolver	"Actual and expected strings are actually backwards here, but this is copied from the Java source"	| resolvedText resolved |	(fullText isEmpty and: [(self hasEmbeddedTables: aVariableResolver) not])		ifTrue: [^self fail: aTestResults html: aString].	self fail: aTestResults.	resolvedText := self resolvedText: aVariableResolver.	resolved := ''.	self text = resolvedText ifFalse: [resolved := ' = ' , resolvedText].	self		addToBody: resolved , (self label: 'expected') , '&lt;hr&gt;'				, (Fixture escape: aString) , (self label: 'actual')				, (self differencesActual: (Fixture escape: resolvedText)						expected: (Fixture escape: aString))</body><body package="FitLibrary-Internals">ignore: aTestResults	(tagAnnotation findString: self class callsMarkup startingAt: 1) &gt; 0		ifTrue: [^self].	cellIsInHiddenRow		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	(tagAnnotation findString: 'class' startingAt: 1) isZero		ifFalse: 			[^self				error: 'Duplicate cell class in tag. Tag is already ' , tagAnnotation].	self addToTag: self class ignoreMarkup.	aTestResults ignore</body><body package="FitLibrary-Internals">pass: aTestResults	cellIsInHiddenRow		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	^super pass: aTestResults</body><body package="FitLibrary-Internals">passIfNotEmbedded: aTestResults variableResolver: aVariableResolver	(self hasEmbeddedTables: aVariableResolver)		ifTrue: 			["already colored"			^self].	self pass: aTestResults</body><body package="FitLibrary-Internals">passOrFailIfBlank: aTestResults variableResolver: aVariableResolver	(self isBlank: aVariableResolver)		ifTrue: [self pass: aTestResults]		ifFalse: 			[self fail: aTestResults withMessage: '' variableResolver: aVariableResolver]</body><body package="FitLibrary-Internals">unvisitedEscapedText: aString	self unvisitedText: (Fixture escape: aString)</body><body package="FitLibrary-Internals">unvisitedText: aString	self text: (Markup info: aString)</body><body package="FitLibrary-Internals">wrongHtml: aString resultsInto: aTestResults	self fail: aTestResults.	self addToBody: (self label: 'expected') , '&lt;hr&gt;' , aString				, (self label: 'actual')</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>private</category><body package="FitLibrary-Internals">columnSpanHtml: anInteger	^' colspan="&lt;1p&gt;"' expandMacrosWith: anInteger</body><body package="FitLibrary-Internals">differencesActual: actualString expected: expectedString	^PlugBoard stringDifferencing differencesActual: actualString		expected: expectedString</body><body package="FitLibrary-Internals">newObject	^Tables new</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>printing</category><body package="FitLibrary-Internals">printHtmlBodyOn: aStream	aStream nextPutAll: fullText</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	fullText := String new.	cellIsInHiddenRow := false</body><body package="FitLibrary-Internals">setFullText: aString	fullText := aString</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>copying</category><body package="FitLibrary-Internals">deepCopy	^(super deepCopy)		setFullText: fullText;		yourself</body></methods><methods><class-id>FitlibraryInternals.Cell</class-id> <category>error handling</category><body package="FitLibrary-Internals">error: aTestResults	cellIsInHiddenRow		ifTrue: [Transcript show: 'Bug: Coloring a cell in a hidden table'].	self addToTag: self class errorMarkup.	aTestResults exception</body></methods><methods><class-id>FitlibraryInternals.Cell class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self tag: 'td'</body><body package="FitLibrary-Internals">withString: aString	^(self new)		setFullText: aString;		yourself</body><body package="FitLibrary-Internals">withTables: aTables	^(self new)		addTables: aTables;		yourself</body></methods><methods><class-id>FitlibraryInternals.TablesParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^aCell</body></methods><methods><class-id>FitlibraryInternals.TablesParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: aTables	^aTables fitToString</body></methods><methods><class-id>FitlibraryInternals.TablesParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^self error: 'No Traverse available'</body></methods><methods><class-id>FitlibraryInternals.TablesParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	^aCell = anObject</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownCaller</class-id> <category>setUp-tearDown</category><body package="FitLibrary-Internals">setUp: anObject	self send: #setUp to: anObject</body><body package="FitLibrary-Internals">tearDown: anObject	testResults hasProblems		ifTrue: 			[(self send: #onFailure to: anObject)				ifNotNil: [:result | (row addCellWithString: result fitToString) shown]].	self send: #tearDown to: anObject</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownCaller</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setSetUpTearDown: aSetUpTearDown row: aRow testResults: aTestResults	setUpTearDown := aSetUpTearDown.	row := aRow.	testResults := aTestResults</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownCaller</class-id> <category>private</category><body package="FitLibrary-Internals">send: aSelector to: anObject	^setUpTearDown		send: aSelector		to: anObject		row: row		resultsInto: testResults</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownCaller class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">setUpTearDown: aSetUpTearDown row: aRow resultsInto: aTestResults	^self new		setSetUpTearDown: aSetUpTearDown		row: aRow		testResults: aTestResults</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	anObject		ifNil: 			[^(aCell hasEmbeddedTables: evaluator) not and: [aCell isBlank: evaluator]].	(aCell hasEmbeddedTables: evaluator)		ifTrue: 			[^self				table: aCell embeddedTable				matches: anObject				resultsInto: aTestResults].	^(self parse: aCell resultsInto: aTestResults) = anObject</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser</class-id> <category>private</category><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| newInstance setUp |	newInstance := nil.	[newInstance := adapter newInstance] on: Error		do: 			[:ex |						[(PlugBoard lookupTarget findNewInstancePluginMethod: evaluator)				ifNotNil: 					[:fixturingMethod |					newInstance := fixturingMethod								invokeOnArguments: (Array with: adapter type)]]					on: Error					do: [:innerEx | ]].	setUp := DomainObjectSetUpTraverse systemUnderTest: newInstance				type: adapter.	setUp runtimeContext: evaluator runtimeContext.	setUp		interpretInnerTableWithinScope: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults.	^setUp systemUnderTest</body><body package="FitLibrary-Internals">table: aTable matches: anObject resultsInto: aTestResults	| traverse |	traverse := DomainObjectCheckTraverse systemUnderTest: anObject				type: adapter.	^traverse		doesInnerTablePass: aTable		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setAdapter: aTypeAdapter evaluator: anEvaluator	adapter := aTypeAdapter.	evaluator := anEvaluator.	finder := GenericFinder for: aTypeAdapter evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	(aCell hasEmbeddedTables: evaluator)		ifTrue: [^self parseTable: aCell embeddedTable resultsInto: aTestResults].	^finder find: (aCell resolvedText: evaluator)</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser</class-id> <category>testing</category><body package="FitLibrary-Internals">hasFinderMethod	^finder hasFinderMethod</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	^finder show: anObject</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^DomainObjectCheckTraverse typedSystemUnderTest: aTypedObject</body></methods><methods><class-id>FitlibraryInternals.DomainObjectParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">for: aTypeAdapter evaluator: anEvaluator	^self new setAdapter: aTypeAdapter evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.NotSubclassFromClassFactoryMethod class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">class: aClass superclass: aSuperclass	^self messageText: ('Not a subclass: class &lt;1s&gt; is not a subclass of &lt;2s&gt;'				expandMacrosWith: aClass name				with: aSuperclass name)</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownReferenceCounter</class-id> <category>private</category><body package="FitLibrary-Internals">addReferenceTo: anObject caller: aSetUpTearDownCaller	| oldCount |	oldCount := referenceCounts at: anObject				ifAbsentPut: 					[aSetUpTearDownCaller setUp: anObject.					0].	referenceCounts at: anObject put: oldCount + 1</body><body package="FitLibrary-Internals">removeReferenceTo: anObject caller: aSetUpTearDownCaller	| oldCount |	oldCount := referenceCounts at: anObject ifAbsent: [^self].	oldCount = 1 ifFalse: [^referenceCounts at: anObject put: oldCount - 1].	aSetUpTearDownCaller tearDown: anObject.	referenceCounts removeKey: anObject</body><body package="FitLibrary-Internals">sutChainOf: anObject do: aBlock	| sut |	sut := anObject.	[sut respondsTo: #systemUnderTest] whileTrue: 			[aBlock value: sut.			sut := sut systemUnderTest]</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownReferenceCounter</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	referenceCounts := IdentityDictionary new</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownReferenceCounter</class-id> <category>accessing</category><body package="FitLibrary-Internals">callSetUpOnNewReferences: anObject caller: aSetUpTearDownCaller	self sutChainOf: anObject do: [:sut | self addReferenceTo: sut caller: aSetUpTearDownCaller]</body><body package="FitLibrary-Internals">callTearDownOnExpiredReferences: anObject caller: aSetUpTearDownCaller	self sutChainOf: anObject		do: [:sut | self removeReferenceTo: sut caller: aSetUpTearDownCaller]</body></methods><methods><class-id>FitlibraryInternals.SetUpTearDownReferenceCounter class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.DelegateObjectSuperParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^delegate performMethod: parseMethod with: aString</body></methods><methods><class-id>FitlibraryInternals.DelegateObjectSuperParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setDelegate: anObject	super setDelegate: anObject.	parseMethod := (delegate class findSelector: #fitParse:)				ifNil: [^(Fit.Exceptions.NoSuchMethodException named: 'fitParse:') raise]				ifNotNil: #last</body></methods><methods><class-id>FitlibraryInternals.NoNullaryConstructor class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">className: aString	^self messageText: 'Class has no default constructor: '				, (ExtendedCamelCase camelClassName: aString)</body><body package="FitLibrary-Internals">forClass: aClass	^self		messageText: (aClass fitLibraryIsAbstract				ifTrue: ['Class is abstract: ']				ifFalse: ['Class has no default constructor: ']) , aClass shortName</body></methods><methods><class-id>FitlibraryInternals.SpecifyErrorReport</class-id> <category>private</category><body package="FitLibrary-Internals">actual: actualString expected: expectedString	^(String new writeStream)		nextPutAll: '. &lt;table border="1" cellspacing="0"&gt;';		nextPutAll: (self plainRowActual: 'Actual' expected: 'Expected');		nextPutAll: (self rowActual: actualString expected: expectedString);		nextPutAll: (self optionalEscapedRowActual: actualString					expected: expectedString);		nextPutAll: (self rowActual: actualString size printString					expected: expectedString size printString);		nextPutAll: '&lt;/table&gt;';		contents</body><body package="FitLibrary-Internals">escape: aString	^Fixture escape: aString</body><body package="FitLibrary-Internals">optionalEscapedRowActual: actualString expected: expectedString	| actualEscaped expectedEscaped |	actualEscaped := self escape: actualString.	expectedEscaped := self escape: expectedString.	(actualEscaped = actualString and: [expectedEscaped = expectedString])		ifTrue: [^String new].	^self rowActual: actualEscaped expected: expectedEscaped</body><body package="FitLibrary-Internals">plainRowActual: actualString expected: expectedString	^(String new writeStream)		nextPutAll: '&lt;tr&gt;&lt;td&gt;';		nextPutAll: actualString;		nextPutAll: '&lt;/td&gt;&lt;td&gt;';		nextPutAll: expectedString;		nextPutAll: '&lt;/td&gt;&lt;/tr&gt;';		nextPut: Character lf;		contents</body><body package="FitLibrary-Internals">rowActual: actualString expected: expectedString	^(String new writeStream)		nextPutAll: '&lt;tr&gt;&lt;td&gt;';		nextPutAll: actualString;		nextPutAll: (PlugBoard stringDifferencing differencesActual: actualString					expected: expectedString);		nextPutAll: '&lt;/td&gt;&lt;td&gt;';		nextPutAll: expectedString;		nextPutAll: '&lt;/td&gt;&lt;/tr&gt;';		nextPut: Character lf;		contents</body></methods><methods><class-id>FitlibraryInternals.SpecifyErrorReport</class-id> <category>errors</category><body package="FitLibrary-Internals">cellTextWrongActual: actualString expected: expectedString path: pathString	self showAfterTable: ('Cell text differs at &lt;1s&gt;&lt;2s&gt;'				expandMacrosWith: pathString				with: (self actual: actualString expected: expectedString))</body><body package="FitLibrary-Internals">leaderWrongActual: actualString expected: expectedString path: pathString	self		showAfterTable: ('Leader differs at &lt;1s&gt;&lt;2s&gt;' expandMacrosWith: pathString				with: (self actual: actualString expected: expectedString))</body><body package="FitLibrary-Internals">sizeWrongActual: actualInteger expected: expectedInteger path: pathString	self showAfterTable: ('Size differs at &lt;1s&gt;. Was &lt;2p&gt;. Expected &lt;3p&gt;'				expandMacrosWith: pathString				with: actualInteger				with: expectedInteger)</body><body package="FitLibrary-Internals">tagLineWrongActual: actualString expected: expectedString path: pathString	self showAfterTable: ('Tag line differs at &lt;1s&gt;&lt;2s&gt;'				expandMacrosWith: pathString				with: (self actual: actualString expected: expectedString))</body><body package="FitLibrary-Internals">trailerWrongActual: actualString expected: expectedString path: pathString	self		showAfterTable: ('Trailer differs at &lt;1s&gt;&lt;2s&gt;' expandMacrosWith: pathString				with: (self actual: actualString expected: expectedString))</body></methods><methods><class-id>FitlibraryInternals.SpecifyErrorReport</class-id> <category>showing</category><body package="FitLibrary-Internals">actualResult: aTables	aTables print: 'actual'</body><body package="FitLibrary-Internals">showAfterTable: aString	showAfter showAsAfterTableTitle: 'Logs' contents: aString</body></methods><methods><class-id>FitlibraryInternals.SpecifyErrorReport</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setShowAfter: aTraverse	showAfter := aTraverse</body></methods><methods><class-id>FitlibraryInternals.SpecifyErrorReport class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">showAfter: aTraverse	^self new setShowAfter: aTraverse</body></methods><methods><class-id>FitlibraryInternals.ArrayParser</class-id> <category>private</category><body package="FitLibrary-Internals">expected: expectedArray matches: actualArray resultsInto: aTestResults	expectedArray size = actualArray size ifFalse: [^false].	expectedArray with: actualArray		do: 			[:expected :actual |						[(componentParser				expectedCell: (Cell withString: expected fitToString)				matches: actual				resultsInto: aTestResults) ifFalse: [^false]]					on: Error					do: [:ex | ^false]].	^true</body><body package="FitLibrary-Internals">expectedTable: aTable matches: anObject resultsInto: aTestResults	^(ArrayTraverse array: anObject parser: componentParser)		doesInnerTablePass: aTable		runtimeContext: runtimeContext		resultsInto: aTestResults</body><body package="FitLibrary-Internals">parseString: aString resultsInto: aTestResults	^Array		withAll: ((aString runsFailing: [:each | each = $,]) collect: 					[:each |					componentParser parse: (Cell withString: each fitTrimSeparators)						resultsInto: aTestResults])</body><body package="FitLibrary-Internals">parseTable: aTable resultsInto: aTestResults	| setUp |	setUp := ArraySetUpTraverse valueParser: componentParser.	setUp		interpretWithinScope: aTable		runtimeContext: runtimeContext		resultsInto: aTestResults.	^setUp results</body></methods><methods><class-id>FitlibraryInternals.ArrayParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anArray	| ws |	anArray ifNil: [^''].	ws := WriteStream on: (String new: anArray size * 5).	anArray do: [:each | ws nextPutAll: (componentParser show: each)]		separatedBy: [ws nextPutAll: ', '].	^ws contents</body></methods><methods><class-id>FitlibraryInternals.ArrayParser</class-id> <category>accessing</category><body package="FitLibrary-Internals">traverseFor: aTypedObject	^ArrayTraverse typedArray: aTypedObject</body></methods><methods><class-id>FitlibraryInternals.ArrayParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setEvaluator: anEvaluator componentType: aTypeAdapter	runtimeContext := anEvaluator runtimeContext.	componentParser := aTypeAdapter resultParser: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.ArrayParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	(aCell hasEmbeddedTables: runtimeContext)		ifTrue: [^self parseTable: aCell embeddedTable resultsInto: aTestResults].	^self parseString: (aCell resolvedText: runtimeContext)		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.ArrayParser</class-id> <category>matching</category><body package="FitLibrary-Internals">expectedCell: aCell matches: anObject resultsInto: aTestResults	(aCell hasEmbeddedTables: runtimeContext)		ifTrue: 			[^self				expectedTable: aCell embeddedTable				matches: anObject				resultsInto: aTestResults].	^self		expected: (self parse: aCell resultsInto: aTestResults)		matches: anObject		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.ArrayParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">evaluator: anEvaluator componentType: aTypeAdapter	^self new setEvaluator: anEvaluator componentType: aTypeAdapter</body></methods><methods><class-id>FitlibraryInternals.AmbiguousActionException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">messageText: aString	^super messageText: 'Ambiguity between: ' , aString</body></methods><methods><class-id>FitlibraryInternals.StringMatchStats</class-id> <category>testing</category><body package="FitLibrary-Internals">isLowQualityMatch	^sameButTwo * 10 &gt; same and: [longestMatch &lt; 3]</body></methods><methods><class-id>FitlibraryInternals.StringMatchStats</class-id> <category>accessing</category><body package="FitLibrary-Internals">noteMatchOfSize: anInteger	same := same + anInteger.	anInteger &lt;= 2 ifTrue: [sameButTwo := sameButTwo + 1].	longestMatch := longestMatch max: anInteger</body></methods><methods><class-id>FitlibraryInternals.StringMatchStats</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">initialize	super initialize.	same := 0.	sameButTwo := 0.	longestMatch := 0</body></methods><methods><class-id>FitlibraryInternals.StringMatchStats class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^super new initialize</body></methods><methods><class-id>FitlibraryInternals.ActionSpecial</class-id> <category>testing</category><body package="FitLibrary-Internals">isAmbiguous	^(positionedTargets select: #isFound) size &gt; 1</body><body package="FitLibrary-Internals">isPartiallyValid	^positionedTargets size = 1		and: [positionedTargets first isPartiallyValid]</body><body package="FitLibrary-Internals">isValid	^positionedTargets size = 1 and: [positionedTargets first isFound]</body></methods><methods><class-id>FitlibraryInternals.ActionSpecial</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	^positionedTargets first		run: aRow		runtimeContext: evaluator runtimeContext		resultsInto: aTestResults</body></methods><methods><class-id>FitlibraryInternals.ActionSpecial</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	| and ws message |	and := ' AND '.	ws := String new writeStream.	(positionedTargets select: #isFound) do: 			[:each |			ws				nextPutAll: and;				nextPutAll: each ambiguityErrorMessage].	message := ws contents.	^message copyFrom: and size + 1 to: message size</body><body package="FitLibrary-Internals">partialErrorMessage	^positionedTargets first partialErrorMessage</body></methods><methods><class-id>FitlibraryInternals.ActionSpecial</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRow: aRow evaluator: anEvaluator sequencing: aBoolean lookupTarget: aLookupMethodTarget	| cells |	evaluator := anEvaluator.	cells := Array new: aRow size.	1 to: aRow size		do: [:index | cells at: index put: (aRow resolvedTextAt: index resolver: anEvaluator)].	positionedTargets := aLookupMethodTarget				findActionSpecialMethodFrom: cells				sequencing: aBoolean				evaluator: anEvaluator</body></methods><methods><class-id>FitlibraryInternals.ActionSpecial class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">row: aRow evaluator: anEvaluator sequencing: aBoolean lookupTarget: aLookupMethodTarget	^self new		setRow: aRow		evaluator: anEvaluator		sequencing: aBoolean		lookupTarget: aLookupMethodTarget</body></methods><methods><class-id>FitlibraryInternals.ShowAfterTableAppender</class-id> <category>logging</category><body package="FitLibrary-Internals">append: aString	runtimeContext showAsAfterTableTitle: 'Logging' contents: aString , '&lt;br/&gt;'</body></methods><methods><class-id>FitlibraryInternals.ShowAfterTableAppender</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRuntimeContext: aRuntimeContext	runtimeContext := aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.ShowAfterTableAppender class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">runtimeContext: aRuntimeContext	^self new setRuntimeContext: aRuntimeContext</body></methods><methods><class-id>FitlibraryInternals.CycleException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">cycle: aString between: aDomainAdapter and: anObject	^self messageText: ('&lt;1s&gt; cycle between &lt;2s&gt; and &lt;3s&gt;'				expandMacrosWith: aString				with: aDomainAdapter class fullName				with: anObject class fullName)		page: 'SutCycle'</body></methods><methods><class-id>FitlibraryInternals.ExtraCellsException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">details: aString	^self messageText: 'Extra table cells' page: 'ExtraCells.' , aString</body></methods><methods><class-id>FitlibraryInternals.FailingDelegateParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aString	^(CouldNotParseException class: type text: aString) raise</body></methods><methods><class-id>FitlibraryInternals.FailingDelegateParser</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setClass: aClass	type := aClass</body></methods><methods><class-id>FitlibraryInternals.FailingDelegateParser class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">forClass: aClass	^self new setClass: aClass</body></methods><methods><class-id>FitlibraryInternals.ClassMethodTarget</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setClass: aClass evaluator: anEvaluator actual: aTypedObject	componentType := aClass.	evaluator := anEvaluator.	actualType := aTypedObject classType</body></methods><methods><class-id>FitlibraryInternals.ClassMethodTarget</class-id> <category>accessing</category><body package="FitLibrary-Internals">result	^actualType shortName</body></methods><methods><class-id>FitlibraryInternals.ClassMethodTarget</class-id> <category>running</category><body package="FitLibrary-Internals">invokeAndCheckCell: aCell matchedAlready: aBoolean resultsInto: aTestResults		[(self matches: aCell resultsInto: aTestResults)		ifTrue: 			[aBoolean ifTrue: [aCell pass: aTestResults].			^true]		ifFalse: 			[aBoolean				ifTrue: 					[aCell						fail: aTestResults						withMessage: self result						variableResolver: evaluator]]]			on: Error			do: [:ex | aCell error: ex resultsInto: aTestResults].	^false</body><body package="FitLibrary-Internals">matches: aCell resultsInto: aTestResults		[| expectedType |	expectedType := PlugBoard lookupTarget				findClassFromFactoryMethod: (aCell resolvedText: evaluator)				baseType: componentType				evaluator: evaluator.	^actualType == expectedType]			on: Error			do: 				[:ex |				aCell error: ex resultsInto: aTestResults.				^false]</body></methods><methods><class-id>FitlibraryInternals.ClassMethodTarget class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">forClass: aClass evaluator: anEvaluator actual: aTypedObject	^self new setClass: aClass evaluator: anEvaluator actual: aTypedObject</body></methods><methods><class-id>FitlibraryInternals.RelativeFileHandler</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">fileNameIs: aString	file := (LocalFile named: aString) asFilename</body></methods><methods><class-id>FitlibraryInternals.CellProxy</class-id> <category>markup</category><body package="FitLibrary-Internals">errorMessage: aString	aString isEmpty ifTrue: [^cell error: testResultsBlock value].	cell errorMessage: aString resultsInto: testResultsBlock value</body><body package="FitLibrary-Internals">fail	cell fail: testResultsBlock value</body><body package="FitLibrary-Internals">failWithMessage: aString	aString isEmpty ifTrue: [^self fail].	cell		fail: testResultsBlock value		withMessage: aString		variableResolver: variableResolver</body><body package="FitLibrary-Internals">pass	cell pass: testResultsBlock value</body></methods><methods><class-id>FitlibraryInternals.CellProxy</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setCell: aCell variableResolver: aVariableResolver testResultsBlock: aBlock	cell := aCell.	variableResolver := aVariableResolver.	testResultsBlock := aBlock</body></methods><methods><class-id>FitlibraryInternals.CellProxy class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">onCell: aCell variableResolver: aVariableResolver testResultsBlock: aBlock	^self new setCell: aCell variableResolver: aVariableResolver testResultsBlock: aBlock</body></methods><methods><class-id>FitlibraryInternals.NestedTableExpectedException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">new	^self messageText: 'Nested table expected'</body></methods><methods><class-id>FitlibraryInternals.NestedTable</class-id> <category>accessing</category><body package="FitLibrary-Internals">at: i at: j at: k	^self class parse: (parse at: i at: j at: k) parts</body><body package="FitLibrary-Internals">parse	^parse</body><body package="FitLibrary-Internals">stringAt: i at: j at: k	| nested |	nested := parse at: i at: j at: k.	^nested body ifNil: [^'null'] ifNotNil: [nested text]</body></methods><methods><class-id>FitlibraryInternals.NestedTable</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setParse: aParse	parse := aParse</body></methods><methods><class-id>FitlibraryInternals.NestedTable</class-id> <category>converting</category><body package="FitLibrary-Internals">toTable	^self</body></methods><methods><class-id>FitlibraryInternals.NestedTable</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitToString	^parse debugString</body></methods><methods><class-id>FitlibraryInternals.NestedTable</class-id> <category>comparing</category><body package="FitLibrary-Internals">= aNestedTable	^parse = aNestedTable parse</body><body package="FitLibrary-Internals">hash	^parse hash</body></methods><methods><class-id>FitlibraryInternals.NestedTable class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">parse: aParse	^self new setParse: aParse</body><body package="FitLibrary-Internals">parseTable: aParse	^self parse: aParse</body></methods><methods><class-id>FitlibraryInternals.NestedTable class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitTypeAdapter	^TypeAdapterParserBridge type: self		parserBlock: [TableParser forClass: self]</body></methods><methods><class-id>FitlibraryInternals.PostFixSpecialCaller</class-id> <category>running</category><body package="FitLibrary-Internals">run: aRow resultsInto: aTestResults	^specialMethod		invokeTypedOnArguments: (Array with: aTestResults with: aRow)</body></methods><methods><class-id>FitlibraryInternals.PostFixSpecialCaller</class-id> <category>testing</category><body package="FitLibrary-Internals">isValid	^specialMethod notNil and: [self isProblem not]</body></methods><methods><class-id>FitlibraryInternals.PostFixSpecialCaller</class-id> <category>private</category><body package="FitLibrary-Internals">findMethodForInnerAction: aRow evaluator: anEvaluator sequencing: aBoolean		[PlugBoard lookupTarget		findMethodByArityIn: aRow		from: 1		to: aRow size - 2		doStyle: aBoolean not		evaluator: anEvaluator]			on: Error			do: [:ex | self problem: ex]</body></methods><methods><class-id>FitlibraryInternals.PostFixSpecialCaller</class-id> <category>accessing</category><body package="FitLibrary-Internals">ambiguityErrorMessage	^'#withResults:' , methodName , ':'</body></methods><methods><class-id>FitlibraryInternals.PostFixSpecialCaller</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRow: aRow evaluator: anEvaluator sequencing: aBoolean	aRow size &gt;= 2 ifFalse: [^self].	methodName := aRow resolvedTextAt: aRow size - 1 resolver: anEvaluator.	specialMethod := (PlugBoard lookupTarget				findPostfixSpecialMethodNamed: methodName				evaluator: anEvaluator) ifNil: [^self].	self		findMethodForInnerAction: aRow		evaluator: anEvaluator		sequencing: aBoolean</body></methods><methods><class-id>FitlibraryInternals.PostFixSpecialCaller class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">row: aRow evaluator: anEvaluator sequencing: aBoolean	^self new setRow: aRow evaluator: anEvaluator sequencing: aBoolean</body></methods><methods><class-id>FitlibraryInternals.TableParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	anObject ifNil: [^'null'].	^anObject toTable fitToString</body></methods><methods><class-id>FitlibraryInternals.TableParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	(aCell hasEmbeddedTables: GlobalDynamicVariables new)		ifFalse: [^MissingTablesException raise].	^targetClass parseTable: aCell embeddedTable asParse</body></methods><methods><class-id>FitlibraryInternals.TypeAdapterParserBridge</class-id> <category>parsing</category><body package="FitLibrary-Internals">findTypeBasedParser: anEvaluator	^parserBlock cull: anEvaluator cull: componentAdapters</body></methods><methods><class-id>FitlibraryInternals.TypeAdapterParserBridge</class-id> <category>testing</category><body package="FitLibrary-Internals">isGeneric	^componentAdapters notNil</body></methods><methods><class-id>FitlibraryInternals.TypeAdapterParserBridge</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">componentAdapters: aCollection	componentAdapters := aCollection</body><body package="FitLibrary-Internals">setType: aClass parserBlock: aBlock	self type: aClass.	parserBlock := aBlock.	componentAdapters := OrderedCollection new</body></methods><methods><class-id>FitlibraryInternals.TypeAdapterParserBridge class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">type: aClass parserBlock: aBlock	^self new setType: aClass parserBlock: aBlock</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPage</class-id> <category>private</category><body package="FitLibrary-Internals">fileToPageName: aFilename	| page root rootIndex directoryIndex |	page := aFilename asAbsoluteFilename asString.	root := 'FitNesseRoot' copyWith: Filename separator.	rootIndex := page findString: root startingAt: 1.	rootIndex isZero		ifFalse: [page := page copyFrom: rootIndex + root size to: page size].	directoryIndex := page lastIndexOf: Filename separator.	directoryIndex isZero		ifFalse: [page := page copyFrom: 1 to: directoryIndex - 1].	^(page replaceAll: $\ with: $.) replaceAll: $/ with: $.</body><body package="FitLibrary-Internals">processPagesAsFiles: aString	| errorStream pages directory |	errorStream := String new writeStream.	pages := aString tokensBasedOn: $..	directory := pages inject: self fitnesseDirectory / rootLocation				into: [:dir :each | dir / each].	directory fitlibraryRecursiveFilenamesMatching: '*.txt'		do: 			[:each |			| wiki html stream |			stream := each readStream lineEndAuto.			wiki := [stream contents] ensure: [stream close].			html := SimpleWikiTranslator translate: wiki.						[| tables |			(html findString: '&lt;table' startingAt: 1) isZero				ifFalse: 					[| filename |					filename := (each asAbsoluteFilename asString replaceAll: $/ with: $.)								replaceAll: $\								with: $..					tables := Tables fromString: html.					self						parseDefinitions: tables						className: (self determineClassNameFromPrefix: '' pageName: filename)						pageName: (self fileToPageName: each)]]					on: Error					do: 						[:ex |						errorStream							nextPutAll: '&lt;li&gt;';							nextPutAll: ex errorString;							nextPutAll: '&lt;/li&gt;';							nextPut: Character lf]].	^errorStream contents</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPage</class-id> <category>processing</category><body package="FitLibrary-Internals">process	| errors |	errors := self				processPagesAsFiles: (topPageName copyFrom: 2 to: topPageName size).	errors isEmpty		ifFalse: 			[^FitLibraryExceptionInHtml raiseErrorString: '&lt;ul&gt;' , errors , '&lt;/ul&gt;']</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPage</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setRootLocation: locationString	rootLocation := locationString</body><body package="FitLibrary-Internals">setTopPageName: topPageNameString runtimeContext: aRuntimeContext	super setTopPageName: topPageNameString runtimeContext: aRuntimeContext.	rootLocation := 'FitNesseRoot'</body></methods><methods><class-id>FitlibraryInternals.DefineActionsOnPage class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">page: topPageNameString rootLocation: locationString runtimeContext: aRuntimeContext	^(self page: topPageNameString runtimeContext: aRuntimeContext)		setRootLocation: locationString</body></methods><methods><class-id>FitlibraryInternals.ExtendedCamelCase class</class-id> <category>private</category><body package="FitLibrary-Internals">hideSmalltalkKeyword: aString andJavaKeywordToo: aBoolean	| keywords |	keywords := #('self' 'super' 'true' 'false' 'nil').	aBoolean ifTrue: [keywords := keywords , self javaKeywords].	(keywords includes: aString) ifTrue: [^aString , '_'].	^aString</body><body package="FitLibrary-Internals">initializeReplacements	Replacements := (Dictionary new)				at: '!' put: ' bang ';				at: '"' put: ' quote ';				at: '#' put: ' hash ';				at: '$' put: ' dollar ';				at: '%' put: ' percent ';				at: '&amp;' put: ' ampersand ';				at: '''' put: ' single quote ';				at: '(' put: ' left parenthesis ';				at: ')' put: ' right parenthesis ';				at: '*' put: ' star ';				at: '+' put: ' plus ';				at: ',' put: ' comma ';				at: '-' put: ' minus ';				at: '.' put: ' dot ';				at: '/' put: ' slash ';				at: ':' put: ' colon ';				at: ';' put: ' semicolon ';				at: '&lt;' put: ' less than ';				at: '&gt;' put: ' greater than ';				at: '=' put: ' equals ';				at: '?' put: ' question ';				at: '@' put: ' at ';				at: '[' put: ' left square bracket ';				at: ']' put: ' right square bracket ';				at: '\' put: ' backslash ';				at: '^' put: ' caret ';				at: '`' put: ' backquote ';				at: '{' put: ' left brace ';				at: '}' put: ' right brace ';				at: '|' put: ' bar ';				at: '~' put: ' tilde ';				yourself</body><body package="FitLibrary-Internals">javaKeywords	^#('abstract' 'assert' 'boolean' 'break' 'byte' 'case' 'catch' 'char' 'class' 'const' 'continue' 'default' 'do' 'double' 'else' 'enum' 'extends' 'false' 'final' 'finally' 'float' 'for' 'goto' 'if' 'implements' 'import' 'instanceof' 'int' 'interface' 'long' 'native' 'new' 'null' 'package' 'private' 'protected' 'public' 'return' 'short' 'static' 'strictfp' 'super' 'switch' 'synchronized' 'this' 'throw' 'throws' 'transient' 'true' 'try' 'void' 'volatile' 'while')</body><body package="FitLibrary-Internals">mapNumber: aCharacter 	| words |	words := #('zero ' 'one ' 'two ' 'three ' 'four ' 'five ' 'six ' 'seven ' 'eight ' 'nine ').	^words at: aCharacter digitValue + 1</body><body package="FitLibrary-Internals">replacements	Replacements ifNil: [self initializeReplacements].	^Replacements</body><body package="FitLibrary-Internals">resetReplacements	Replacements := nil</body></methods><methods><class-id>FitlibraryInternals.ExtendedCamelCase class</class-id> <category>utility</category><body package="FitLibrary-Internals">camel: aString 	^self camel: aString hideJavaKeywordToo: false</body><body package="FitLibrary-Internals">camel: aString hideJavaKeywordToo: aBoolean	"Normally aBoolean is false, but there's one FitLibrary spec test that tests Java keywords, so we do this to fake it enough to pass that test"	| result |	result := aString fitTrimSeparators.	result isEmpty ifTrue: [^'blank'].	self replacements		keysAndValuesDo: [:key :value | result := result copyReplaceAll: key with: value].	result first isDigit		ifTrue: [result := (self mapNumber: result first) , (result allButFirst: 1)].	^self hideSmalltalkKeyword: (Fixture camelCase: result)		andJavaKeywordToo: aBoolean</body><body package="FitLibrary-Internals">camelClassName: aString	| camelName |	(aString includes: Character space) ifFalse: [^aString].	camelName := self camel: 't ' , aString.	^camelName copyFrom: 2 to: camelName size</body></methods><methods><class-id>FitlibraryInternals.PassFail</class-id> <category>accessing</category><body package="FitLibrary-Internals">result	^result</body></methods><methods><class-id>FitlibraryInternals.PassFail</class-id> <category>testing</category><body package="FitLibrary-Internals">hasPassed	^hasPassed</body></methods><methods><class-id>FitlibraryInternals.PassFail</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setPassed: aBoolean result: anObject	hasPassed := aBoolean.	result := anObject</body></methods><methods><class-id>FitlibraryInternals.PassFail class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">passed: aBoolean result: anObject	^self new setPassed: aBoolean result: anObject</body></methods><methods><class-id>FitlibraryInternals.Eventually</class-id> <category>private</category><body package="FitLibrary-Internals">delay	^self now - start</body><body package="FitLibrary-Internals">hasTimedOut	^self delay &gt; timeout</body><body package="FitLibrary-Internals">now	^Time millisecondClockValue</body><body package="FitLibrary-Internals">sleep	sleepPeriod milliseconds wait</body></methods><methods><class-id>FitlibraryInternals.Eventually</class-id> <category>constants</category><body package="FitLibrary-Internals">divSleep	^50</body><body package="FitLibrary-Internals">maxSleep	^10</body><body package="FitLibrary-Internals">minSleep	^2</body></methods><methods><class-id>FitlibraryInternals.Eventually</class-id> <category>polling</category><body package="FitLibrary-Internals">poll: aBlock	| answer |	answer := PassFail passed: false result: nil.	start := self now.		[answer := aBlock value.	answer hasPassed ifTrue: [^answer].	self hasTimedOut		ifTrue: [true]		ifFalse: 			[self sleep.			false]]			whileFalse.	^answer</body></methods><methods><class-id>FitlibraryInternals.Eventually</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">setTimeout: aTimeout	timeout := aTimeout.	sleepPeriod := self maxSleep				min: (self minSleep max: timeout / self divSleep).	start := self now</body></methods><methods><class-id>FitlibraryInternals.Eventually class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">timeout: anInteger	^self new setTimeout: anInteger</body></methods><methods><class-id>FitlibraryInternals.VoidMethodException class</class-id> <category>instance creation</category><body package="FitLibrary-Internals">selector: selectorString page: pageString	^self messageText: 'Method ' , selectorString , ' is void.'		page: 'VoidMethod.' , pageString</body></methods><methods><class-id>FitlibraryInternals.TableConversion class</class-id> <category>utility</category><body package="FitLibrary-Internals">convertCell: aCell to: aClass	| result |	result := aClass withString: aCell fullText.	result		leader: aCell leader;		trailer: aCell trailer;		tagLine: aCell tagLine.	aCell		do: [:each | result add: (self convertTable: each to: aClass elementClass)].	^result</body><body package="FitLibrary-Internals">convertRow: aRow to: aClass	| result |	result := aClass new.	result		leader: aRow leader;		trailer: aRow trailer;		tagLine: aRow tagLine.	aRow		do: [:each | result add: (self convertCell: each to: aClass elementClass)].	^result</body><body package="FitLibrary-Internals">convertTable: aTable to: aClass	| result |	result := aClass new.	result		leader: aTable leader;		trailer: aTable trailer;		tagLine: aTable tagLine.	aTable		do: [:each | result add: (self convertRow: each to: aClass elementClass)].	^result</body><body package="FitLibrary-Internals">convertTables: aTables to: aClass	| result |	result := aClass new.	aTables		do: [:each | result add: (self convertTable: each to: aClass elementClass)].	^result</body></methods><methods><class-id>FitlibraryInternals.TaggedStringParser</class-id> <category>parsing</category><body package="FitLibrary-Internals">parse: aCell resultsInto: aTestResults	^TaggedString string: aCell fullText</body></methods><methods><class-id>FitlibraryInternals.TaggedStringParser</class-id> <category>showing</category><body package="FitLibrary-Internals">show: anObject	anObject ifNil: [^'null'].	^anObject fitToString</body></methods><methods><class-id>FitlibraryInternals.NoSystemUnderTestException</class-id> <category>printing</category><body package="FitLibrary-Internals">description	^'SystemUnderTest needs to be defined'</body></methods><methods><class-id>FitlibraryInternals.AbstractFileHandler</class-id> <category>accessing</category><body package="FitLibrary-Internals">absolutePath	&lt;fitReturns: #String&gt;	^file asAbsoluteFilename asString</body><body package="FitLibrary-Internals">lastModified	&lt;fitReturns: #Timestamp&gt;	^file modificationTimestamp</body><body package="FitLibrary-Internals">length	&lt;fitReturns: #Integer&gt;	^file fileSize</body><body package="FitLibrary-Internals">list	&lt;fitReturns: #OrderedCollection&gt;	file isDirectory ifFalse: [^OrderedCollection new].	^file directoryContents</body></methods><methods><class-id>FitlibraryInternals.AbstractFileHandler</class-id> <category>actions</category><body package="FitLibrary-Internals">append: aString	&lt;fitTakes: #String&gt;	self write: aString to: file appendStream</body><body package="FitLibrary-Internals">delete	&lt;fitReturns: #Boolean&gt;	file delete.	^true</body><body package="FitLibrary-Internals">read	&lt;fitReturns: #String&gt;	| rs |	rs := file readStream lineEndAuto.	^[rs contents] ensure: [rs close]</body><body package="FitLibrary-Internals">write: aString	&lt;fitTakes: #String&gt;	| cr |	cr := String with: Character cr.	self write: (aString copyReplaceAll: '\n' with: cr) to: file writeStream</body><body package="FitLibrary-Internals">writeUnicode: aString	&lt;fitTakes: #String&gt;	| cr |	cr := String with: Character cr.	self write: (aString copyReplaceAll: '\n' with: cr)		to: (file withEncoding: #utf8) writeStream</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>showing</category><body package="FitLibrary-Internals">logText: aString	&lt;fitTakes: #String&gt;	runtime logConfiguration log: aString</body><body package="FitLibrary-Internals">showAsAfterTable: titleString _: contentsString	&lt;fitTakes: #(#String #String)&gt;	self showAsAfterTableTitle: titleString contents: contentsString</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>accessing</category><body package="FitLibrary-Internals">becomesTimeout	&lt;fitReturns: #Integer&gt;	^self timeoutAt: 'becomes'</body><body package="FitLibrary-Internals">becomesTimeout: anInteger	&lt;fitTakes: #Integer&gt;	self timeoutAt: 'becomes' put: anInteger</body><body package="FitLibrary-Internals">runtimeConfiguration	&lt;fitReturns: #SuiteWideRuntimeContext&gt;	^runtime configuration</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>special actions</category><body package="FitLibrary-Internals">abandonStorytest	&lt;fitReturns: #Void&gt;	runtime abandon: true</body><body package="FitLibrary-Internals">addDynamicVariablesFromFile: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^self dynamicVariables addFromPropertiesFile: aString</body><body package="FitLibrary-Internals">addDynamicVariablesFromUnicodeFile: aString	&lt;fitTakes: #String&gt;	self dynamicVariables addFromUnicodePropertiesFile: aString</body><body package="FitLibrary-Internals">asString: aDoAction	&lt;fitTakes: #DoAction&gt;	&lt;fitReturns: #StringAdapter&gt;	^aDoAction run ifNotNil: [:result | StringAdapter on: result fitToString]</body><body package="FitLibrary-Internals">autoTranslateDefinedActionParameters	&lt;fitReturns: #Void&gt;	self dynamicVariableAt: DefineAction autoTranslateDefinedActionParameters		put: 'true'</body><body package="FitLibrary-Internals">clearDefinedActions	&lt;fitReturns: #Void&gt;	TemporaryPlugBoardForRuntime definedActionsRepository clear</body><body package="FitLibrary-Internals">comment	&lt;fitReturns: #TraverseBase&gt;	^CommentTraverse new</body><body package="FitLibrary-Internals">contains: aDoAction _: aString	&lt;fitTakes: #(#DoAction #String)&gt;	| result |	aString		ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'expected is null'].	result := aDoAction run fitToString.	result ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'result is null'].	(result findString: aString startingAt: 1) isZero		ifTrue: [(aDoAction cellAt: 2) failWithMessage: result]		ifFalse: [(aDoAction cellAt: 2) pass]</body><body package="FitLibrary-Internals">defineAction	&lt;fitReturns: #DefineAction&gt;	^DefineAction new</body><body package="FitLibrary-Internals">defineAction: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #DefineAction&gt;	^(DefineAction wikiClassName: aString)		runtimeContext: runtime;		yourself</body><body package="FitLibrary-Internals">defineActionsAt: aString	&lt;fitTakes: #String&gt;	(DefineActionsOnPage page: aString runtimeContext: runtime) process</body><body package="FitLibrary-Internals">defineActionsAt: pageNameString from: rootLocationString	&lt;fitTakes: #(#String #String)&gt;	(DefineActionsOnPage		page: pageNameString		rootLocation: rootLocationString		runtimeContext: runtime) process</body><body package="FitLibrary-Internals">defineActionsSlowlyAt: aString	&lt;fitTakes: #String&gt;	(DefineActionsOnPageSlowly page: aString runtimeContext: runtime) process</body><body package="FitLibrary-Internals">doesNotContain: aDoAction _: aString	&lt;fitTakes: #(#DoAction #String)&gt;	| result cell |	aString		ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'expected is null'].	result := aDoAction run fitToString.	result ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'result is null'].	cell := aDoAction cellAt: 2.	(result findString: aString startingAt: 1) isZero		ifTrue: [cell pass]		ifFalse: 			[result = aString				ifTrue: [cell fail]				ifFalse: [cell failWithMessage: result]]</body><body package="FitLibrary-Internals">doesNotMatch: aDoAction _: aString	&lt;fitTakes: #(#DoAction #String)&gt;	| result cell |	aString		ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'expected is null'].	result := aDoAction run fitToString.	result ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'result is null'].	cell := aDoAction cellAt: 2.	(result matchesRegex: '.*' , aString , '.*')		ifFalse: [cell pass]		ifTrue: 			[result = aString				ifTrue: [cell fail]				ifFalse: [cell failWithMessage: result]]</body><body package="FitLibrary-Internals">ensure: aDoAction	&lt;fitTakes: #DoAction&gt;	&lt;fitReturns: #Boolean&gt;	| result |	result := aDoAction run.	(result isKindOf: Boolean) ifTrue: [^result].	result ifNil: [^true].	^nil</body><body package="FitLibrary-Internals">eventuallyContains: aDoAction _: aString	&lt;fitTakes: #(#DoAction #String)&gt;	| result eventually answer cell |	aString		ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'expected is null'].	eventually := Eventually timeout: self becomesTimeout.	answer := eventually poll: 					[result := aDoAction run fitToString.					PassFail passed: (result findString: aString startingAt: 1) isZero not						result: result].	cell := aDoAction cellAt: 2.	(answer isNil or: [answer result isNil])		ifTrue: [^cell failWithMessage: 'result is null'].	answer hasPassed		ifTrue: [cell pass]		ifFalse: [cell failWithMessage: result]</body><body package="FitLibrary-Internals">eventuallyMatches: aDoAction _: aString	&lt;fitTakes: #(#DoAction #String)&gt;	| result eventually answer cell regex |	aString		ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'expected is null'].	regex := '.*' , aString , '.*'.	eventually := Eventually timeout: self becomesTimeout.	answer := eventually poll: 					[result := aDoAction run fitToString.					PassFail passed: (result matchesRegex: regex) result: result].	cell := aDoAction cellAt: 2.	(answer isNil or: [answer result isNil])		ifTrue: [^cell failWithMessage: 'result is null'].	answer hasPassed		ifTrue: [cell pass]		ifFalse: [cell failWithMessage: result]</body><body package="FitLibrary-Internals">file: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #FileHandler&gt;	^FileHandler filename: aString</body><body package="FitLibrary-Internals">get: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^aString</body><body package="FitLibrary-Internals">getSymbolNamed: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Object&gt;	^Fixture symbolAt: aString</body><body package="FitLibrary-Internals">greaterThan: aDoAction _: anObject	&lt;fitTakes: #(#DoAction #Object)&gt;	self compareAction: aDoAction expected: anObject using: #&gt;</body><body package="FitLibrary-Internals">greaterThanEquals: aDoAction _: anObject	&lt;fitTakes: #(#DoAction #Object)&gt;	self compareAction: aDoAction expected: anObject using: #&gt;=</body><body package="FitLibrary-Internals">harvest: anArray usingPattern: patternString from: aString	&lt;fitTakes: #(#( #String )  #String   #String )&gt;	&lt;fitReturns: #Boolean&gt;	| matcher groups |	matcher := patternString asRegex.	(matcher matches: aString)		ifFalse: [^FitLibraryException raiseErrorString: 'Pattern doesn''t match'].	groups := matcher subexpressionCount - 1.	"the first group is the entire sub-expression"	anArray size &gt; groups		ifTrue: 			[^FitLibraryException raiseErrorString: ('Expected &lt;1s&gt;, but there &lt;2s&gt;'						expandMacrosWith: (self expectedGroups: anArray)						with: (self actualGroups: groups))].	anArray keysAndValuesDo: 			[:index :each |			self dynamicVariableAt: each put: (matcher subexpression: index + 1)].	^true</body><body package="FitLibrary-Internals">ignore	&lt;fitReturns: #CommentTraverse&gt;	^CommentTraverse markAsIgnored: true</body><body package="FitLibrary-Internals">ignoreTable	&lt;fitReturns: #CommentTraverse&gt;	^self ignore</body><body package="FitLibrary-Internals">ignored	&lt;fitReturns: #TraverseBase&gt;	^self ignore</body><body package="FitLibrary-Internals">informOnFailOrErrorInStorytest: aDoAction	&lt;fitTakes: #DoAction&gt;	| result |	result := aDoAction run.	(result isKindOf: OnError)		ifFalse: 			[^FitLibraryException raiseErrorString: 'Must be an object of type OnError'].	runtime registerOnErrorHandler: result</body><body package="FitLibrary-Internals">lessThan: aDoAction _: anObject	&lt;fitTakes: #(#DoAction #Object)&gt;	self compareAction: aDoAction expected: anObject using: #&lt;</body><body package="FitLibrary-Internals">lessThanEquals: aDoAction _: anObject	&lt;fitTakes: #(#DoAction #Object)&gt;	self compareAction: aDoAction expected: anObject using: #&lt;=</body><body package="FitLibrary-Internals">logged: aDoAction	&lt;fitTakes: #DoAction&gt;	aDoAction run		ifNotNil: [:result | runtime logConfiguration log: result fitToString]</body><body package="FitLibrary-Internals">matches: aDoAction _: aString	&lt;fitTakes: #(#DoAction #String)&gt;	| result |	aString		ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'expected is null'].	result := aDoAction run fitToString.	result ifNil: [^(aDoAction cellAt: 2) failWithMessage: 'result is null'].	(result matchesRegex: '.*' , aString , '.*')		ifTrue: [(aDoAction cellAt: 2) pass]		ifFalse: [(aDoAction cellAt: 2) failWithMessage: result]</body><body package="FitLibrary-Internals">not: aDoAction	&lt;fitTakes: #DoAction&gt;	| result |	result := nil.		[	[	[result := aDoAction runWithNoColoring.	(result isKindOf: Boolean) ifTrue: [^result not]]			on: IgnoredException			do: 				[:ex |				ex ignoredError					ifNotNil: [:ignoredError | aDoAction show: ignoredError errorString].				^true]]			on: FitLibraryShowException			do: 				[:ex |				aDoAction show: ex result htmlString.				^true]]			on: Error			do: [:ex | ^true].	result ifNil: [NotRejectedException raise].	^nil</body><body package="FitLibrary-Internals">notTrue: aDoAction	&lt;fitTakes: #DoAction&gt;	&lt;fitReturns: #Boolean&gt;	| result |	result := aDoAction run.	(result isKindOf: Boolean) ifTrue: [^result not].	^NotRejectedException raise</body><body package="FitLibrary-Internals">reject: aDoAction	&lt;fitTakes: #DoAction&gt;	^self not: aDoAction</body><body package="FitLibrary-Internals">relativeFile: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #FileHandler&gt;	^RelativeFileHandler filename: aString</body><body package="FitLibrary-Internals">select: aString	&lt;fitTakes: #String&gt;	runtime tableEvaluator select: aString</body><body package="FitLibrary-Internals">selectRandomly: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #TraverseBase&gt;	^RandomSelectTraverse variable: aString</body><body package="FitLibrary-Internals">setExpandDefinedActions: aBoolean	&lt;fitTakes: #Boolean&gt;	runtime expandDefinedActions: aBoolean</body><body package="FitLibrary-Internals">setStopOnError: aBoolean	&lt;fitTakes: #Boolean&gt;	runtime setStopOnError: aBoolean</body><body package="FitLibrary-Internals">setSystemProperty: nameString to: valueString	"Smalltalk doesn't have system properties like Java, so we ignore that part and just forward on to the dynamic variable system."	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #Boolean&gt;	self dynamicVariableAt: nameString put: valueString.	^true</body><body package="FitLibrary-Internals">setVariables	&lt;fitReturns: #SetVariableTraverse&gt;	^SetVariableTraverse new</body><body package="FitLibrary-Internals">show: aDoAction	&lt;fitTakes: #DoAction&gt;	aDoAction run ifNotNil: [:result | aDoAction showResult: result]</body><body package="FitLibrary-Internals">showAfter: aDoAction	&lt;fitTakes: #DoAction&gt;	aDoAction run ifNotNil: [:result | aDoAction showAfter: result]</body><body package="FitLibrary-Internals">showAfterAs: aString _: aDoAction	&lt;fitTakes: #(#String #DoAction)&gt;	aDoAction run		ifNotNil: [:result | aDoAction showAfter: result as: aString]</body><body package="FitLibrary-Internals">showEscaped: aDoAction	&lt;fitTakes: #DoAction&gt;	aDoAction run		ifNotNil: 			[:result |			aDoAction show: '&lt;pre&gt;' , (Fixture escape: result fitToString) , '&lt;/pre&gt;']</body><body package="FitLibrary-Internals">showPredefined: aDoAction	&lt;fitTakes: #DoAction&gt;	aDoAction run		ifNotNil: [:result | aDoAction show: '&lt;pre&gt;' , result fitToString , '&lt;/pre&gt;']</body><body package="FitLibrary-Internals">showWithTags: aDoAction	&lt;fitTakes: #DoAction&gt;	aDoAction run		ifNotNil: 			[:result |			aDoAction show: '&lt;pre&gt;' , (Fixture escape: result fitToString) , '&lt;/pre&gt;']</body><body package="FitLibrary-Internals">sleepFor: aMilliseconds	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #Boolean&gt;	aMilliseconds milliseconds wait.	^true</body><body package="FitLibrary-Internals">startStopWatch	&lt;fitReturns: #Void&gt;	self dynamicVariableAt: self class stopWatchKey put: StopWatch new</body><body package="FitLibrary-Internals">stopWatch	&lt;fitReturns: #Integer&gt;	^self findStopWatch delay</body><body package="FitLibrary-Internals">suite	&lt;fitReturns: #SuiteFixture&gt;	^SuiteFixture new</body><body package="FitLibrary-Internals">to: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^aString</body></methods><methods><class-id>FitlibraryInternals.GlobalActionScope</class-id> <category>logging</category><body package="FitLibrary-Internals">withFitLibraryLogger	&lt;fitReturns: #LogConfiguration&gt;	^runtime logConfiguration</body></methods><methods><class-id>FitlibraryInternals.SuiteWideRuntimeContext</class-id> <category>special actions</category><body package="FitLibrary-Internals">addTimings: aBoolean	&lt;fitTakes: #Boolean&gt;	addTimings := aBoolean</body><body package="FitLibrary-Internals">stopAfterErrors: errorsInteger orFails: failsInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	maxErrorsBeforeStopping := errorsInteger.	maxFailsBeforeStopping := failsInteger</body></methods><methods><class-id>FitlibraryInternals.Utility.MapElement</class-id> <category>accessing</category><body package="FitLibrary-Internals">key	&lt;fitReturns: #Object&gt;	^key</body><body package="FitLibrary-Internals">value	&lt;fitReturns: #Object&gt;	^value</body></methods><methods><class-id>FitlibraryInternals.Log.LogConfiguration</class-id> <category>accessing</category><body package="FitLibrary-Internals">level: aString	"ignored - not implemented"	&lt;fitTakes: #String&gt;</body></methods><methods><class-id>FitlibraryInternals.ListTree</class-id> <category>accessing</category><body package="FitLibrary-Internals">children	&lt;fitReturns: #OrderedCollection&gt;	^children</body><body package="FitLibrary-Internals">title	&lt;fitReturns: #String&gt;	^title</body></methods><methods><class-id>FitlibraryInternals.DomainAdapter.StringAdapter</class-id> <category>accessing</category><body package="FitLibrary-Internals">concat: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #String&gt;	^subject , aString</body><body package="FitLibrary-Internals">indexOf: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Integer&gt;	^(subject findString: aString startingAt: 1) - 1</body><body package="FitLibrary-Internals">indexOf: aString _: anInteger	&lt;fitTakes: #(#String #Integer)&gt;	&lt;fitReturns: #Integer&gt;	^(subject findString: aString startingAt: anInteger + 1) - 1</body><body package="FitLibrary-Internals">lastIndexOf: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Integer&gt;	^(subject findPreviousString: aString startingAt: subject size) - 1</body><body package="FitLibrary-Internals">length	&lt;fitReturns: #Integer&gt;	^subject size</body><body package="FitLibrary-Internals">replace: aCharacter _: replacementCharacter	&lt;fitTakes: #(#Character #Character)&gt;	&lt;fitReturns: #String&gt;	^subject copy replaceAll: aCharacter with: replacementCharacter</body><body package="FitLibrary-Internals">replaceAll: patternString _: replacementString	&lt;fitTakes: #(#String #String)&gt;	&lt;fitReturns: #String&gt;	^subject copyWithRegex: patternString		matchesReplacedWith: replacementString</body><body package="FitLibrary-Internals">split: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #(#String)&gt;	| splitChar |	splitChar := aString isEmpty				ifTrue: [Character space]				ifFalse: [aString = '\\n' ifTrue: [Character lf] ifFalse: [aString first]].	^subject tokensBasedOn: splitChar</body><body package="FitLibrary-Internals">substring: anInteger	&lt;fitTakes: #Integer&gt;	&lt;fitReturns: #String&gt;	^subject copyFrom: anInteger + 1 to: subject size</body><body package="FitLibrary-Internals">substring: startInteger _: endInteger	&lt;fitTakes: #(#Integer #Integer)&gt;	&lt;fitReturns: #String&gt;	^subject copyFrom: startInteger + 1 to: endInteger</body><body package="FitLibrary-Internals">toLowerCase	&lt;fitReturns: #String&gt;	^subject asLowercase</body><body package="FitLibrary-Internals">toString	&lt;fitReturns: #String&gt;	^subject</body><body package="FitLibrary-Internals">toUpperCase	&lt;fitReturns: #String&gt;	^subject asUppercase</body></methods><methods><class-id>FitlibraryInternals.DomainAdapter.StringAdapter</class-id> <category>testing</category><body package="FitLibrary-Internals">contains: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^(subject findString: aString startingAt: 1) isZero not</body><body package="FitLibrary-Internals">equalsIgnoreCase: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^subject equivalentTo: aString ignoreCase: true</body><body package="FitLibrary-Internals">isEquals: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^subject = aString</body><body package="FitLibrary-Internals">matches: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^subject matchesRegex: aString</body><body package="FitLibrary-Internals">startsWith: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Boolean&gt;	^subject beginsWith: aString</body></methods><methods><class-id>FitlibraryInternals.DomainAdapter.StringAdapter</class-id> <category>comparing</category><body package="FitLibrary-Internals">compareTo: aString	&lt;fitTakes: #String&gt;	&lt;fitReturns: #Integer&gt;	^subject &lt;=&gt; aString</body></methods><methods><class-id>Fit.ArrayTypeAdapter</class-id> <category>parsing</category><body package="FitLibrary-Internals">findTypeBasedParser: anEvaluator	^(componentAdapter isForPrimitiveType or: [componentAdapter isForArray])		ifTrue: [ArrayParser evaluator: anEvaluator componentType: componentAdapter]		ifFalse: 			[GenericListParser componentType: componentAdapter evaluator: anEvaluator]</body></methods><methods><class-id>Fit.ArrayTypeAdapter</class-id> <category>testing</category><body package="FitLibrary-Internals">isForArray	^true</body></methods><methods><class-id>Core.Object class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryIsPrimitive	^false</body></methods><methods><class-id>Core.Object</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">asFitLibraryTypedObject	^TypedObject subject: self</body><body package="FitLibrary-Internals">fitLibraryResolveInto: aTables	^Fixture escape: self fitToString</body><body package="FitLibrary-Internals">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	^false</body></methods><methods><class-id>Core.Collection class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitParse: aString	^self withAll: ((aString runsFailing: [:each | each = $,])				collect: [:each | String fitParse: each fitTrimSeparators])</body></methods><methods><class-id>Core.Collection</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryActualsInto: aCollectionTraverse	aCollectionTraverse setCollectionActuals: self</body><body package="FitLibrary-Internals">fitLibraryAutoWrappedFor: aTypedObject evaluator: anEvaluator	^aTypedObject traverse: anEvaluator</body><body package="FitLibrary-Internals">fitToString	| ws |	ws := WriteStream on: (String new: self size * 5).	self do: [:each | ws nextPutAll: each fitToString]		separatedBy: [ws nextPutAll: ', '].	^ws contents</body></methods><methods><class-id>Core.Character class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryIsPrimitive	^true</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>parsing</category><body package="FitLibrary-Internals">findPropertyEditorBasedParser: anEvaluator	^PropertyEditorBasedParser findParserForType: self evaluator: anEvaluator</body><body package="FitLibrary-Internals">findSelfParser	^(SelfParser findSelfParser: self type)		ifNil: [SelfConstructorParser findSelfConstructorParser: self type]</body><body package="FitLibrary-Internals">findTypeBasedParser: anEvaluator	(self findPropertyEditorBasedParser: anEvaluator)		ifNotNil: [:parser | ^parser].	(isRegex or: [self isForPrimitiveType])		ifTrue: [^SimpleParser for: self evaluator: anEvaluator].	self findSelfParser		ifNotNil: 			[:parser |			^DelegatingParser delegateParser: parser evaluator: anEvaluator type: self].	^nil</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>testing</category><body package="FitLibrary-Internals">isForArray	^false</body><body package="FitLibrary-Internals">isForPrimitiveType	^self type fitLibraryIsPrimitive</body><body package="FitLibrary-Internals">isGeneric	^false</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>instantiating</category><body package="FitLibrary-Internals">newInstance	^type fitLibraryNewInstance</body></methods><methods><class-id>Fit.TypeAdapter</class-id> <category>parsing</category><body package="FitLibrary-Internals">parameterParser: anEvaluator	^self parser: anEvaluator isResult: false</body><body package="FitLibrary-Internals">parser: anEvaluator isResult: aBoolean	| domainObjectParser |	(ParseDelegation delegateForClass: self type)		ifNotNil: [:delegate | ^delegate parser: anEvaluator type: self type].	domainObjectParser := DomainObjectParser for: self evaluator: anEvaluator.	domainObjectParser hasFinderMethod ifTrue: [^domainObjectParser].	(self findTypeBasedParser: anEvaluator) ifNotNil: [:parser | ^parser].	self type == Object ifFalse: [^domainObjectParser].	aBoolean		ifTrue: 			[^ByStringParser				variableResolver: anEvaluator runtimeContext variableResolver].	^DelegatingParser		delegateParser: (FailingDelegateParser forClass: self type)		evaluator: anEvaluator		type: self</body><body package="FitLibrary-Internals">resultParser: anEvaluator	^self parser: anEvaluator isResult: true</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="FitLibrary-Internals">fitlibraryRecursiveFilenamesMatching: aString do: aBlock	(self filenamesMatching: aString) do: aBlock.	self directoryContents do: 			[:each |			| filename |			filename := self construct: each.			((#('.' '..') includes: each) not and: [filename isDirectory])				ifTrue: [filename fitlibraryRecursiveFilenamesMatching: aString do: aBlock]				ifFalse: []]</body></methods><methods><class-id>OS.Filename</class-id> <category>type access</category><body package="FitLibrary-Internals">signatureFor: aSymbol	(#(#isDirectory #exists) includes: aSymbol) ifTrue: [^Boolean].	^nil</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitTypeAdapter	^TypeAdapterParserBridge type: self		parserBlock: 			[:evaluator :componentTypes |			componentTypes isEmpty				ifTrue: [ListParser evaluator: evaluator]				ifFalse: 					[GenericListParser componentType: componentTypes any evaluator: evaluator]]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>type access</category><body package="FitLibrary-Internals">signatureFor: aSymbol	aSymbol == #endsWith:		ifTrue: [^MethodSignature with: String returning: Boolean].	aSymbol == #isEmpty ifTrue: [^Boolean].	^nil</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitParse: aString	^self withAll: ((aString runsFailing: [:each | each = $,])				collect: [:each | Association fitParse: each fitTrimSeparators])</body><body package="FitLibrary-Internals">fitTypeAdapter	^TypeAdapterParserBridge type: self		parserBlock: 			[:evaluator :componentTypes |			componentTypes isEmpty				ifTrue: [MapParser evaluator: evaluator]				ifFalse: 					[GenericMapParser						keyType: componentTypes first						valueType: (componentTypes at: 2)						evaluator: evaluator]]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryActualsInto: aCollectionTraverse	aCollectionTraverse setDictionaryActuals: self</body><body package="FitLibrary-Internals">fitToString	| ws |	ws := WriteStream on: (String new: self size * 5).	self associations do: [:each | ws nextPutAll: each fitToString]		separatedBy: [ws nextPutAll: ', '].	^ws contents</body></methods><methods><class-id>Core.Set class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitTypeAdapter	^TypeAdapterParserBridge type: self		parserBlock: 			[:evaluator :componentTypes |			componentTypes isEmpty				ifTrue: [SetParser evaluator: evaluator]				ifFalse: 					[FitlibraryInternals.GenericSetParser componentType: componentTypes any						evaluator: evaluator]]</body></methods><methods><class-id>Core.Number class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryIsPrimitive	^true</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="FitLibrary-Internals">fitLibraryAllSelectorsDo: aBlock	| pivotClass |	pivotClass := self.	[pivotClass isNil] whileFalse: 			[pivotClass				selectorsAndMethodsDo: [:eachSelector :ignored | aBlock value: eachSelector].			pivotClass := pivotClass superclass]</body></methods><methods><class-id>Core.Behavior</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">fitLibraryCreateElement: anEvaluator	(PlugBoard lookupTarget findNewInstancePluginMethod: anEvaluator)		ifNotNil: 			[:fixturingMethod |			(fixturingMethod invokeOnArguments: (Array with: self))				ifNotNil: [:element | ^element]].	^self fitLibraryNewInstance</body></methods><methods><class-id>Core.Behavior</class-id> <category>testing</category><body package="FitLibrary-Internals">fitLibraryIsAbstract	"We construct the symbol from a string to avoid having the Browser generate a	subclassResponsibility stub for us every time we create a class."	^(self whichSelectorsReferTo: 'subclassResponsibility' asSymbol) notEmpty</body></methods><methods><class-id>Core.Behavior</class-id> <category>initialize-release</category><body package="FitLibrary-Internals">fitLibraryNewInstance	self fitLibraryIsAbstract		ifTrue: [^(ClassIsAbstract forClass: self) raise].	^self new</body></methods><methods><class-id>Core.Association class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitParse: aString	| tokens |	tokens := aString fitLibrarySplit: '-&gt;'.	^tokens first fitTrimSeparators -&gt; tokens last fitTrimSeparators</body></methods><methods><class-id>Core.Association</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitToString	^key fitToString , '-&gt;' , value fitToString</body></methods><methods><class-id>Core.Boolean class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryIsPrimitive	^true</body></methods><methods><class-id>Fit.DelegateAdapter</class-id> <category>parsing</category><body package="FitLibrary-Internals">findTypeBasedParser: anEvaluator	^SimpleParser for: self evaluator: anEvaluator</body></methods><methods><class-id>Fit.Fixture</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryAutoWrappedFor: aTypedObject evaluator: anEvaluator	^self</body><body package="FitLibrary-Internals">fitLibraryRunTableFromContext: anInnerTableContext for: aDoFlowOnTable resultsInto: aTestResults	| remainingTable resultTable originalTable rowIndex flowEvaluator startTime |	self class == Fixture		ifTrue: 			["Ignore it, as it does nothing"			^false].	startTime := Time millisecondClockValue.	originalTable := anInnerTableContext table.	rowIndex := anInnerTableContext rowIndex.	flowEvaluator := anInnerTableContext evaluator.	remainingTable := (originalTable from: rowIndex) asTableOnParse.	flowEvaluator fitHandler		doTable: remainingTable		fixture: self		evaluator: flowEvaluator		resultsInto: aTestResults.	resultTable := remainingTable asTableOnList.	resultTable		keysAndValuesDo: [:index :each | originalTable replaceAt: rowIndex + index - 1 with: each].	aDoFlowOnTable addTimeTextTo: anInnerTableContext row startTime: startTime.	^true</body></methods><methods><class-id>Core.CharacterArray class</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryIsPrimitive	^true</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>fit-utilities</category><body package="FitLibrary-Internals">fitLibraryAutoWrappedFor: aTypedObject evaluator: anEvaluator	^self</body><body package="FitLibrary-Internals">fitLibrarySplit: aString	"Answer an OrderedCollection of the sub-sequences	 of the receiver that are separated by aString.  	Similar to #tokesnBasedOn:, but allows for more than one character."	| rs tokens |	rs := self readStream.	tokens := OrderedCollection new.	[rs atEnd]		whileFalse: [tokens addLast: (rs upToAndSkipThroughAll: aString)].	(self endsWith: aString) ifTrue: [tokens addLast: (self copyEmpty: 0)].	^tokens</body></methods><methods><class-id>Core.GenericException</class-id> <category>fitLibrary</category><body package="FitLibrary-Internals">fitLibraryAddToMissingMethodMessage: aMissingMethodMessage	aMissingMethodMessage addMissingMethod: self errorString</body><body package="FitLibrary-Internals">fitLibraryExceptionMessage	| aString stackTrace |	stackTrace := self initialContext				ifNil: ['no stack available']				ifNotNil: #fitStackTrace.	aString := '&lt;1s&gt;&lt;n&gt;&lt;2s&gt;' expandMacrosWith: self errorString				with: stackTrace.	^'&lt;hr&gt;&lt;pre&gt;&lt;div class="fit_stacktrace"&gt;' , aString , '&lt;/div&gt;&lt;/pre&gt;'</body></methods><methods><class-id>Fit.MethodSignature</class-id> <category>testing</category><body package="FitLibrary-Internals">isNullary	^self numArgs = 1 and: [parameterAdapters first isForClass: DoAction]</body><body package="FitLibrary-Internals">isPostfix	^self numArgs &gt; 1 and: [parameterAdapters first isForClass: DoAction]</body><body package="FitLibrary-Internals">isPrefix	^self numArgs &gt; 1 and: [parameterAdapters last isForClass: DoAction]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>TypeAdapter</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target field method type isRegex allowNil </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>ArrayTypeAdapter</name><environment>Fit</environment><super>Fit.TypeAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class><class><name>MethodSignature</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterAdapters resultAdapter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>Fit</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>AbstractFitServer</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments outputStream socket socketOutput socketReader </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>DelegateAdapter</name><environment>Fit</environment><super>Fit.TypeAdapter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FitLibrary</category><attributes><package>Fit</package></attributes></class><class><name>Fixture</name><environment>Fit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>counts summary arguments listener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit Framework</category><attributes><package>Fit</package></attributes></class></st-source>