<?xml version="1.0"?><st-source><!-- Name: Fit-Book-RPSNotice:                     GNU GENERAL PUBLIC LICENSE                       Version 2, June 1991 Copyright (C) 1989, 1991 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.                            Preamble  The licenses for most software are designed to take away yourfreedom to share and change it.  By contrast, the GNU General PublicLicense is intended to guarantee your freedom to share and change freesoftware- to make sure the software is free for all its users.  ThisGeneral Public License applies to most of the Free SoftwareFoundation's software and to any other program whose authors commit tousing it.  (Some other Free Software Foundation software is covered bythe GNU Lesser General Public License instead.)  You can apply it toyour programs, too.  When we speak of free software, we are referring to freedom, notprice.  Our General Public Licenses are designed to make sure that youhave the freedom to distribute copies of free software (and charge forthis service if you wish), that you receive source code or can get itif you want it, that you can change the software or use pieces of itin new free programs; and that you know you can do these things.  To protect your rights, we need to make restrictions that forbidanyone to deny you these rights or to ask you to surrender the rights.These restrictions translate to certain responsibilities for you if youdistribute copies of the software, or if you modify it.  For example, if you distribute copies of such a program, whethergratis or for a fee, you must give the recipients all the rights thatyou have.  You must make sure that they, too, receive or can get thesource code.  And you must show them these terms so they know theirrights.  We protect your rights with two steps: (1) copyright the software, and(2) offer you this license which gives you legal permission to copy,distribute and/or modify the software.  Also, for each author's protection and ours, we want to make certainthat everyone understands that there is no warranty for this freesoftware.  If the software is modified by someone else and passed on, wewant its recipients to know that what they have is not the original, sothat any problems introduced by others will not reflect on the originalauthors' reputations.  Finally, any free program is threatened constantly by softwarepatents.  We wish to avoid the danger that redistributors of a freeprogram will individually obtain patent licenses, in effect making theprogram proprietary.  To prevent this, we have made it clear that anypatent must be licensed for everyone's free use or not licensed at all.  The precise terms and conditions for copying, distribution andmodification follow.                    GNU GENERAL PUBLIC LICENSE   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION  0. This License applies to any program or other work which containsa notice placed by the copyright holder saying it may be distributedunder the terms of this General Public License.  The "Program", below,refers to any such program or work, and a "work based on the Program"means either the Program or any derivative work under copyright law:that is to say, a work containing the Program or a portion of it,either verbatim or with modifications and/or translated into anotherlanguage.  (Hereinafter, translation is included without limitation inthe term "modification".)  Each licensee is addressed as "you".Activities other than copying, distribution and modification are notcovered by this License; they are outside its scope.  The act ofrunning the Program is not restricted, and the output from the Programis covered only if its contents constitute a work based on theProgram (independent of having been made by running the Program).Whether that is true depends on what the Program does.  1. You may copy and distribute verbatim copies of the Program'ssource code as you receive it, in any medium, provided that youconspicuously and appropriately publish on each copy an appropriatecopyright notice and disclaimer of warranty; keep intact all thenotices that refer to this License and to the absence of any warranty;and give any other recipients of the Program a copy of this Licensealong with the Program.You may charge a fee for the physical act of transferring a copy, andyou may at your option offer warranty protection in exchange for a fee.  2. You may modify your copy or copies of the Program or any portionof it, thus forming a work based on the Program, and copy anddistribute such modifications or work under the terms of Section 1above, provided that you also meet all of these conditions:    a) You must cause the modified files to carry prominent notices    stating that you changed the files and the date of any change.    b) You must cause any work that you distribute or publish, that in    whole or in part contains or is derived from the Program or any    part thereof, to be licensed as a whole at no charge to all third    parties under the terms of this License.    c) If the modified program normally reads commands interactively    when run, you must cause it, when started running for such    interactive use in the most ordinary way, to print or display an    announcement including an appropriate copyright notice and a    notice that there is no warranty (or else, saying that you provide    a warranty) and that users may redistribute the program under    these conditions, and telling the user how to view a copy of this    License.  (Exception: if the Program itself is interactive but    does not normally print such an announcement, your work based on    the Program is not required to print an announcement.)These requirements apply to the modified work as a whole.  Ifidentifiable sections of that work are not derived from the Program,and can be reasonably considered independent and separate works inthemselves, then this License, and its terms, do not apply to thosesections when you distribute them as separate works.  But when youdistribute the same sections as part of a whole which is a work basedon the Program, the distribution of the whole must be on the terms ofthis License, whose permissions for other licensees extend to theentire whole, and thus to each and every part regardless of who wrote it.Thus, it is not the intent of this section to claim rights or contestyour rights to work written entirely by you; rather, the intent is toexercise the right to control the distribution of derivative orcollective works based on the Program.In addition, mere aggregation of another work not based on the Programwith the Program (or with a work based on the Program) on a volume ofa storage or distribution medium does not bring the other work underthe scope of this License.  3. You may copy and distribute the Program (or a work based on it,under Section 2) in object code or executable form under the terms ofSections 1 and 2 above provided that you also do one of the following:    a) Accompany it with the complete corresponding machine-readable    source code, which must be distributed under the terms of Sections    1 and 2 above on a medium customarily used for software interchange; or,    b) Accompany it with a written offer, valid for at least three    years, to give any third party, for a charge no more than your    cost of physically performing source distribution, a complete    machine-readable copy of the corresponding source code, to be    distributed under the terms of Sections 1 and 2 above on a medium    customarily used for software interchange; or,    c) Accompany it with the information you received as to the offer    to distribute corresponding source code.  (This alternative is    allowed only for noncommercial distribution and only if you    received the program in object code or executable form with such    an offer, in accord with Subsection b above.)The source code for a work means the preferred form of the work formaking modifications to it.  For an executable work, complete sourcecode means all the source code for all modules it contains, plus anyassociated interface definition files, plus the scripts used tocontrol compilation and installation of the executable.  However, as aspecial exception, the source code distributed need not includeanything that is normally distributed (in either source or binaryform) with the major components (compiler, kernel, and so on) of theoperating system on which the executable runs, unless that componentitself accompanies the executable.If distribution of executable or object code is made by offeringaccess to copy from a designated place, then offering equivalentaccess to copy the source code from the same place counts asdistribution of the source code, even though third parties are notcompelled to copy the source along with the object code.  4. You may not copy, modify, sublicense, or distribute the Programexcept as expressly provided under this License.  Any attemptotherwise to copy, modify, sublicense or distribute the Program isvoid, and will automatically terminate your rights under this License.However, parties who have received copies, or rights, from you underthis License will not have their licenses terminated so long as suchparties remain in full compliance.  5. You are not required to accept this License, since you have notsigned it.  However, nothing else grants you permission to modify ordistribute the Program or its derivative works.  These actions areprohibited by law if you do not accept this License.  Therefore, bymodifying or distributing the Program (or any work based on theProgram), you indicate your acceptance of this License to do so, andall its terms and conditions for copying, distributing or modifyingthe Program or works based on it.  6. Each time you redistribute the Program (or any work based on theProgram), the recipient automatically receives a license from theoriginal licensor to copy, distribute or modify the Program subject tothese terms and conditions.  You may not impose any furtherrestrictions on the recipients' exercise of the rights granted herein.You are not responsible for enforcing compliance by third parties tothis License.  7. If, as a consequence of a court judgment or allegation of patentinfringement or for any other reason (not limited to patent issues),conditions are imposed on you (whether by court order, agreement orotherwise) that contradict the conditions of this License, they do notexcuse you from the conditions of this License.  If you cannotdistribute so as to satisfy simultaneously your obligations under thisLicense and any other pertinent obligations, then as a consequence youmay not distribute the Program at all.  For example, if a patentlicense would not permit royalty-free redistribution of the Program byall those who receive copies directly or indirectly through you, thenthe only way you could satisfy both it and this License would be torefrain entirely from distribution of the Program.If any portion of this section is held invalid or unenforceable underany particular circumstance, the balance of the section is intended toapply and the section as a whole is intended to apply in othercircumstances.It is not the purpose of this section to induce you to infringe anypatents or other property right claims or to contest validity of anysuch claims; this section has the sole purpose of protecting theintegrity of the free software distribution system, which isimplemented by public license practices.  Many people have madegenerous contributions to the wide range of software distributedthrough that system in reliance on consistent application of thatsystem; it is up to the author/donor to decide if he or she is willingto distribute software through any other system and a licensee cannotimpose that choice.This section is intended to make thoroughly clear what is believed tobe a consequence of the rest of this License.  8. If the distribution and/or use of the Program is restricted incertain countries either by patents or by copyrighted interfaces, theoriginal copyright holder who places the Program under this Licensemay add an explicit geographical distribution limitation excludingthose countries, so that distribution is permitted only in or amongcountries not thus excluded.  In such case, this License incorporatesthe limitation as if written in the body of this License.  9. The Free Software Foundation may publish revised and/or new versionsof the General Public License from time to time.  Such new versions willbe similar in spirit to the present version, but may differ in detail toaddress new problems or concerns.Each version is given a distinguishing version number.  If the Programspecifies a version number of this License which applies to it and "anylater version", you have the option of following the terms and conditionseither of that version or of any later version published by the FreeSoftware Foundation.  If the Program does not specify a version number ofthis License, you may choose any version ever published by the Free SoftwareFoundation.  10. If you wish to incorporate parts of the Program into other freeprograms whose distribution conditions are different, write to the authorto ask for permission.  For software which is copyrighted by the FreeSoftware Foundation, write to the Free Software Foundation; we sometimesmake exceptions for this.  Our decision will be guided by the two goalsof preserving the free status of all derivatives of our free software andof promoting the sharing and reuse of software generally.                            NO WARRANTY  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTYFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHENOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIESPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSEDOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OFMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK ASTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THEPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,REPAIR OR CORRECTION.  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITINGWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/ORREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISINGOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITEDTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BYYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHERPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THEPOSSIBILITY OF SUCH DAMAGES.                     END OF TERMS AND CONDITIONS            How to Apply These Terms to Your New Programs  If you develop a new program, and you want it to be of the greatestpossible use to the public, the best way to achieve this is to make itfree software which everyone can redistribute and change under these terms.  To do so, attach the following notices to the program.  It is safestto attach them to the start of each source file to most effectivelyconvey the exclusion of warranty; and each file should have at leastthe "copyright" line and a pointer to where the full notice is found.    <one line to give the program's name and a brief idea of what it does.>    Copyright (C) <year>  <name of author>    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.Also add information on how to contact you by electronic and paper mail.If the program is interactive, make it output a short notice like thiswhen it starts in an interactive mode:    Gnomovision version 69, Copyright (C) year name of author    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.    This is free software, and you are welcome to redistribute it    under certain conditions; type `show c' for details.The hypothetical commands `show w' and `show c' should show the appropriateparts of the General Public License.  Of course, the commands you use maybe called something other than `show w' and `show c'; they could even bemouse-clicks or menu items- whatever suits your program.You should also get your employer (if you work as a programmer) or yourschool, if any, to sign a "copyright disclaimer" for the program, ifnecessary.  Here is a sample; alter the names:  Yoyodyne, Inc., hereby disclaims all copyright interest in the program  `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989  Ty Coon, President of ViceThis General Public License does not permit incorporating your program intoproprietary programs.  If your program is a subroutine library, you mayconsider it more useful to permit linking proprietary applications with thelibrary.  If this is what you want to do, use the GNU Lesser GeneralPublic License instead of this License.Comment: This package contains the domain code for the Rent-A-Party Software (RPS) examples in [Fit for Developing Software"](http://www.amazon.com/Fit-Developing-Software-Framework-Integrated/dp/0321269349) by Rick Mugridge and Ward Cunningham.This is an updated version of the RPS example that shipped with FitLibrary2.# Smalltalk FitSmalltalk Fit is a Smalltalk implementation of Ward Cunningham's [Framework for Integrated Tests](http://fit.c2.com), [Fitnesse](http://www.fitnesse.org), and Rick Mugridge's [FitLibrary](http://fitlibrary.sourceforge.net).This version contains the equivalent features of:* fit-java-1.1* fitnesse-20121220* FitLibrary-2.0   Copyright (C) 2004-2013 Randy Coulman    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.See the copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.DbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1541DbUsername: randyDbVersion: 10DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Regex11' ''))PackageName: Fit-Book-RPSParcel: #('Fit-Book-RPS')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Regex11'))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Regex11' ''))PrintStringCache: (10,randy)Version: 10Date: 7:21:06 AM May 24, 2013 --><time-stamp>From VisualWorks® Personal Use Edition, 7.9.1 of October 18, 2012 on May 24, 2013 at 7:21:06 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>RPS</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Fit-Book-RPS</category><attributes><package>Fit-Book-RPS</package></attributes></name-space><class><name>RpsException</name><environment>RPS</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>MissingException</name><environment>RPS</environment><super>RPS.RpsException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Person</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name rentals phoneNumber creator currentTransaction bookings deliveries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Client</name><environment>RPS</environment><super>RPS.Person</super><private>false</private><indexed-type>none</indexed-type><inst-vars>amountOwing bonusPoints city zone address email </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>TransactionItem</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ClientTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>RentEz</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clock rentalItemTypes clients staffMembers pendingClientTransactions pendingAdminTransactions buyItemTypes rentalTemplates itemRestrictions deliveryRates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit-Book-RPS</category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>CancelDeliveryTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count hireItemType period booking </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Reservation</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hireItemType startDate duration reservedItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>CreditCardType</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Discover</name><environment>RPS</environment><super>RPS.CreditCardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ChangePeriodOfBookingTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count hireItemType bookingDate originalPeriod newPeriod booking reservation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Transaction</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startDate rentEz staffMember transactionItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ClientTransaction</name><environment>RPS</environment><super>RPS.Transaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client droppedTransactionItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>MyDate</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AddIdentifiedHireItemTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id type lastMaintainedDate monthsBetweenMaintenance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>DeleteFromTemplateTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>template itemType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>CancelBookingTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hireItemType count bookingDate period booking </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>VoucherPaymentTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>voucher payment client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Rates</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hourly daily weekly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>CreditCardPaymentTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Template</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AddDeliveryRateTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>city zone flatFee rate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Delivery</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date city zone deliveryAddress item itemCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AddHireItemTypeTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count type rates bond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>BuyItemType</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name count sellingPrice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>BookTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count itemType startDate period reservation deliveryRate address </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>SalesPaymentTransaction</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count buyItemType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>RemoveForRepairTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AdminTransaction</name><environment>RPS</environment><super>RPS.Transaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ItemRestriction</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Mastercard</name><environment>RPS</environment><super>RPS.CreditCardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>DeliveryRate</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>city zone flatFee rate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>BonusPointPaymentTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>points client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>DeleteDeliveryRateTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>city zone </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>DuplicateException</name><environment>RPS</environment><super>RPS.RpsException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ChangeDeliveryTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hireItemType count bookingDate period delivery newAddress newZone </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>InvalidCreditCardException</name><environment>RPS</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ReturnFromRepairTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>SystemClock</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ReturnItemsTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count rentalItemType costToFix </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>RentalItemType</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name rates deposit hireItems itemRestrictions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Money</name><environment>RPS</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Fit-Book-DomainCode</category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>CashPaymentTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AccountPaymentTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>RefundAccountTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>amount client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AddToTemplateTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>template itemType count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>RentalItem</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identifier rentalItemType currentRental reservations lastMaintained beingRepaired monthsBetweenMaintenance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Use</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reservation client staffMember </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Booking</name><environment>RPS</environment><super>RPS.Use</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delivery </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>MaintenanceCompleteTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itemIdentifier hireItemType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>BonusPoints</name><environment>RPS</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>ChangeDeliveryRateTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>city zone oldFlatFee rate newFlatFee </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Voucher</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value expiryDate amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>DinersClub</name><environment>RPS</environment><super>RPS.CreditCardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Visa</name><environment>RPS</environment><super>RPS.CreditCardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>MockClock</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AcceptBookingTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hireItemType count bookingDate period booking </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>StaffMember</name><environment>RPS</environment><super>RPS.Person</super><private>false</private><indexed-type>none</indexed-type><inst-vars>commissionRate commissionEarnings discountRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>Rental</name><environment>RPS</environment><super>RPS.Use</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>CreditCard</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cardType cardNumber expiryDate rentEz </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>TemplateItem</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itemType count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>AmericanExpress</name><environment>RPS</environment><super>RPS.CreditCardType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>RefundCashTransactionItem</name><environment>RPS</environment><super>RPS.TransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>refund </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>RentalTransactionItem</name><environment>RPS</environment><super>RPS.ClientTransactionItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reservation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fit-Book-RPS</package></attributes></class><class><name>DurationRPS</name><environment>RPS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours days weeks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Fit-Book-RPS</package></attributes></class><methods><class-id>RPS.Person</class-id> <category>accessing</category><body package="Fit-Book-RPS">bookingWith: anInteger of: aRentalItemType startDate: startMyDate endDate: endMyDate	^self		bookingWith: anInteger		of: aRentalItemType		startDate: startMyDate		endDate: endMyDate		delivery: nil</body><body package="Fit-Book-RPS">bookingWith: anInteger of: aRentalItemType startDate: startMyDate endDate: endMyDate delivery: aDelivery	^bookings detect: 			[:each |			each startDate = startMyDate and: 					[each endDate = endMyDate and: 							[each hireItemType = aRentalItemType								and: [aDelivery isNil or: [each delivery = aDelivery]]]]]		ifNone: [nil]</body><body package="Fit-Book-RPS">bookings	^bookings</body><body package="Fit-Book-RPS">creator	^creator</body><body package="Fit-Book-RPS">deliveries	^deliveries</body><body package="Fit-Book-RPS">rentals	^rentals</body></methods><methods><class-id>RPS.Person</class-id> <category>adding</category><body package="Fit-Book-RPS">addBooking: aBooking	| existing |	existing := bookings detect: 					[:each |					(each datesMatch: aBooking)						and: [each hireItemType = aBooking hireItemType]]				ifNone: [^bookings add: aBooking].	existing reservation addRentalItems: aBooking reservation</body><body package="Fit-Book-RPS">addDelivery: aDelivery	deliveries add: aDelivery</body><body package="Fit-Book-RPS">addRental: aRental	rentals add: aRental</body></methods><methods><class-id>RPS.Person</class-id> <category>transactions</category><body package="Fit-Book-RPS">clearCurrentTransaction	currentTransaction := nil</body><body package="Fit-Book-RPS">startTransaction: aTransaction	currentTransaction ifNotNil: [^false].	currentTransaction := aTransaction.	^true</body><body package="Fit-Book-RPS">transactionComplete	currentTransaction ifNil: [^false].	currentTransaction := nil.	^true</body></methods><methods><class-id>RPS.Person</class-id> <category>private</category><body package="Fit-Book-RPS">currentTransaction	^currentTransaction</body></methods><methods><class-id>RPS.Person</class-id> <category>comparing</category><body package="Fit-Book-RPS">= aPerson	self species = aPerson species ifFalse: [^false].	^name = aPerson name		and: [phoneNumber = aPerson phone and: [creator = aPerson creator]]</body><body package="Fit-Book-RPS">hash	^(name hash hashMultiply bitXor: phoneNumber hash) hashMultiply		bitXor: creator hash</body></methods><methods><class-id>RPS.Person</class-id> <category>removing</category><body package="Fit-Book-RPS">removeBooking: aBooking	aBooking delivery		ifNotNil: [:delivery | deliveries remove: delivery ifAbsent: []].	bookings remove: aBooking</body><body package="Fit-Book-RPS">removeRental: aRental	rentals remove: aRental</body></methods><methods><class-id>RPS.Person</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setName: nameString phoneNumber: phoneString creator: aStaffMember	name := nameString.	phoneNumber := phoneString.	creator := aStaffMember.	rentals := OrderedCollection new.	bookings := OrderedCollection new.	deliveries := OrderedCollection new</body></methods><methods><class-id>RPS.Person class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">named: nameString phoneNumber: phoneString creator: aStaffMember	^self new setName: nameString phoneNumber: phoneString creator: aStaffMember</body></methods><methods><class-id>RPS.Client</class-id> <category>hires</category><body package="Fit-Book-RPS">return: anInteger hiresOf: aRentalItemType	| count |	count := anInteger.	(rentals select: [:each | each hireItemType == aRentalItemType])		do: [:each | count := count - (each returnRental: count)]</body></methods><methods><class-id>RPS.Client</class-id> <category>accessing</category><body package="Fit-Book-RPS">amountOwing	^amountOwing</body><body package="Fit-Book-RPS">bonusPoints	^bonusPoints</body></methods><methods><class-id>RPS.Client</class-id> <category>operations</category><body package="Fit-Book-RPS">payOnAccount: aMoney	amountOwing := amountOwing + aMoney</body><body package="Fit-Book-RPS">reduceBonusPoints: aBonusPoints	bonusPoints := bonusPoints - aBonusPoints</body><body package="Fit-Book-RPS">refundToAccount: aMoney	amountOwing := amountOwing - aMoney</body><body package="Fit-Book-RPS">topupBonusPoints: aBonusPoints	bonusPoints := bonusPoints + aBonusPoints</body></methods><methods><class-id>RPS.Client</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">initialize	super initialize.	amountOwing := Money zero.	bonusPoints := BonusPoints zero.	city := ''.	zone := ''.	address := ''</body><body package="Fit-Book-RPS">setEmail: emailString city: cityString zone: zoneString address: addressString	email := emailString.	city := cityString.	zone := zoneString.	address := addressString</body></methods><methods><class-id>RPS.Client class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">named: nameString phoneNumber: phoneString email: emailString city: cityString zone: zoneString address: addressString creator: aStaffMember	^(self named: nameString phoneNumber: phoneString creator: aStaffMember)		setEmail: emailString		city: cityString		zone: zoneString		address: addressString</body><body package="Fit-Book-RPS">new	^super new initialize</body></methods><methods><class-id>RPS.Client class</class-id> <category>utility</category><body package="Fit-Book-RPS">isValidEmail: aString	^aString matchesRegex: '[\w.]+@\w+(\.\w+)+'</body></methods><methods><class-id>RPS.TransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">startDate	^transaction startDate</body><body package="Fit-Book-RPS">totalCost	^self subclassResponsibility</body></methods><methods><class-id>RPS.TransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setTransaction: aTransaction	transaction := aTransaction</body></methods><methods><class-id>RPS.TransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	^self subclassResponsibility</body></methods><methods><class-id>RPS.TransactionItem</class-id> <category>private</category><body package="Fit-Book-RPS">rentEz	^transaction rentEz</body></methods><methods><class-id>RPS.TransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">transaction: aTransaction	^self new setTransaction: aTransaction</body></methods><methods><class-id>RPS.ClientTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">client	^transaction client</body><body package="Fit-Book-RPS">staffMember	^transaction staffMember</body></methods><methods><class-id>RPS.RentEz</class-id> <category>accessing</category><body package="Fit-Book-RPS">adminStaff	^self staffMemberNamed: 'Admin'</body><body package="Fit-Book-RPS">allIdentifiedHireItems	^rentalItemTypes inject: OrderedCollection new		into: 			[:result :each |			result				addAll: (each identifiedHireItems select: #hasMaintenanceDate);				yourself]</body><body package="Fit-Book-RPS">buyItemNamed: aString	^buyItemTypes at: aString ifAbsent: [nil]</body><body package="Fit-Book-RPS">buyItems	^buyItemTypes values</body><body package="Fit-Book-RPS">clientNamed: aString	^clients at: aString		ifAbsent: [MissingException raiseErrorString: 'Unknown client: ' , aString]</body><body package="Fit-Book-RPS">clients	^clients values asSet</body><body package="Fit-Book-RPS">deliveryRateForCity: cityString zone: zoneString	^deliveryRates		detect: [:each | each city = cityString and: [each zone = zoneString]]		ifNone: [nil]</body><body package="Fit-Book-RPS">deliveryRateForClient: aClient	^self deliveryRateForCity: aClient city zone: aClient zone</body><body package="Fit-Book-RPS">deliveryRates	^deliveryRates</body><body package="Fit-Book-RPS">forMaintenance	^rentalItemTypes inject: Set new		into: 			[:result :each |			each forMaintenanceAsOf: clock now into: result.			result]</body><body package="Fit-Book-RPS">itemsNeedingRepairAsOf: aMyDate	^((self allIdentifiedHireItems		select: [:each | each needsMaintenanceAsOf: aMyDate]) collect: #identifier)		sorted</body><body package="Fit-Book-RPS">pendingClientTransactions	^pendingClientTransactions values</body><body package="Fit-Book-RPS">rentalItemTypeFor: aString	^rentalItemTypes detect: [:each | each hasIdentifiedItem: aString]		ifNone: [nil]</body><body package="Fit-Book-RPS">rentalItemTypeNamed: aString	^rentalItemTypes at: aString		ifAbsent: [^self error: 'Unknown rental: ' , aString]</body><body package="Fit-Book-RPS">rentalItemTypes	^rentalItemTypes</body><body package="Fit-Book-RPS">salesItemTypeNamed: aString	^buyItemTypes at: aString		ifAbsent: [^self error: 'No such ' , aString , ' exists']</body><body package="Fit-Book-RPS">staffMemberNamed: aString	^staffMembers at: aString		ifAbsent: 			[MissingException raiseErrorString: 'Unknown staff member: ' , aString]</body><body package="Fit-Book-RPS">staffMembers	^staffMembers values</body><body package="Fit-Book-RPS">templateNamed: aString	^rentalTemplates at: aString ifAbsent: [nil]</body><body package="Fit-Book-RPS">time	^clock now</body></methods><methods><class-id>RPS.RentEz</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">clock: aClock	clock := aClock</body><body package="Fit-Book-RPS">initialize	clock := SystemClock new.	clients := Dictionary new.	staffMembers := Dictionary new.	rentalItemTypes := Dictionary new.	buyItemTypes := Dictionary new.	rentalTemplates := Dictionary new.	itemRestrictions := Dictionary new.	pendingClientTransactions := Dictionary new.	pendingAdminTransactions := Dictionary new.	deliveryRates := OrderedCollection new.	self createStaffMember: 'Admin' phone: '' creator: nil</body></methods><methods><class-id>RPS.RentEz</class-id> <category>transactions</category><body package="Fit-Book-RPS">beginAdminTransaction: aString	| transaction |	transaction := AdminTransaction				rentEz: self				startDate: clock now				staffMember: (self staffMemberNamed: aString).	pendingAdminTransactions at: aString put: transaction.	^transaction</body><body package="Fit-Book-RPS">beginClientTransaction: clientNameString staff: staffNameString	^self		beginClientTransaction: clientNameString		staff: staffNameString		startDate: clock now</body><body package="Fit-Book-RPS">beginClientTransaction: clientNameString staff: staffNameString startDate: aMyDate	^self		beginClientTransaction: clientNameString		staff: staffNameString		startDate: aMyDate		deliver: false</body><body package="Fit-Book-RPS">beginClientTransaction: clientNameString staff: staffNameString startDate: aMyDate deliver: aBoolean	| transaction |	transaction := ClientTransaction				rentEz: self				startDate: aMyDate				staffMember: (self staffMemberNamed: staffNameString)				client: (self clientNamed: clientNameString)				deliver: aBoolean.	pendingClientTransactions at: clientNameString put: transaction.	^transaction</body><body package="Fit-Book-RPS">removePendingTransactionForClientNamed: aString	pendingClientTransactions removeKey: aString ifAbsent: []</body><body package="Fit-Book-RPS">resumeAdminTransaction: aString	| transaction |	transaction := pendingAdminTransactions at: aString				ifAbsent: [^self error: 'No Such Transaction'].	(transaction staffMember resumeAdminTransaction: transaction)		ifFalse: [^nil].	^transaction</body><body package="Fit-Book-RPS">resumeClientTransaction: aString	| transaction |	transaction := pendingClientTransactions at: aString				ifAbsent: [^self error: 'No Such Transaction'].	(transaction staffMember resumeClientTransaction: transaction)		ifFalse: [^nil].	^transaction</body></methods><methods><class-id>RPS.RentEz</class-id> <category>private</category><body package="Fit-Book-RPS">addBuyItemType: aBuyItemType	| name |	name := aBuyItemType name.	(buyItemTypes includesKey: name)		ifTrue: 			[^DuplicateException				raiseErrorString: 'BuyItemType ' , name , ' already exists'].	buyItemTypes at: name put: aBuyItemType</body><body package="Fit-Book-RPS">addClient: aClient	| name |	name := aClient name.	(clients includesKey: name)		ifTrue: 			[^DuplicateException raiseErrorString: 'Client ' , name , ' already exists'].	clients at: name put: aClient.	^true</body><body package="Fit-Book-RPS">addItemRestriction: anItemRestriction	| id |	id := anItemRestriction id.	(itemRestrictions includesKey: id)		ifTrue: 			[^DuplicateException				raiseErrorString: 'ItemRestriction id ' , id printString						, ' already exists'].	itemRestrictions at: id put: anItemRestriction.	^true</body><body package="Fit-Book-RPS">addRentalItemType: aRentalItemType	| name |	name := aRentalItemType name.	(rentalItemTypes includesKey: name)		ifTrue: [^self error: 'RentalItemType ' , name , ' already exists'].	rentalItemTypes at: name put: aRentalItemType</body><body package="Fit-Book-RPS">addStaffMember: aStaffMember	| name |	name := aStaffMember name.	(staffMembers includesKey: name)		ifTrue: 			[^DuplicateException				raiseErrorString: 'Staff Member ' , name , ' already exists'].	staffMembers at: name put: aStaffMember</body></methods><methods><class-id>RPS.RentEz</class-id> <category>creating</category><body package="Fit-Book-RPS">addTemplateNamed: aString	| template |	template := Template new.	rentalTemplates at: aString put: template.	^template</body><body package="Fit-Book-RPS">createBuyItemType: aString count: anInteger sellingPrice: aMoney	self addBuyItemType: (BuyItemType				named: aString				count: anInteger				sellingPrice: aMoney)</body><body package="Fit-Book-RPS">createClient: nameString phone: phoneString city: cityString zone: zoneString address: addressString creator: aStaffMember	self addClient: (Client				named: nameString				phoneNumber: phoneString				email: ''				city: cityString				zone: zoneString				address: addressString				creator: aStaffMember)</body><body package="Fit-Book-RPS">createClient: nameString phone: phoneString creator: aStaffMember	self addClient: (Client				named: nameString				phoneNumber: phoneString				creator: aStaffMember)</body><body package="Fit-Book-RPS">createDeliveryZone: aDeliveryRate	deliveryRates add: aDeliveryRate</body><body package="Fit-Book-RPS">createItemRestrictionId: anInteger constraint: aString	self		addItemRestriction: (ItemRestriction id: anInteger constraint: aString)</body><body package="Fit-Book-RPS">createRentalItemType: aString initialCount: anInteger rates: aRates deposit: aMoney	self addRentalItemType: (RentalItemType				named: aString				initialCount: anInteger				rates: aRates				deposit: aMoney)</body><body package="Fit-Book-RPS">createStaffMember: nameString phone: phoneString commissionRate: aFloat creator: aStaffMember	self addStaffMember: (StaffMember				named: nameString				phoneNumber: phoneString				commissionRate: aFloat				creator: aStaffMember)</body><body package="Fit-Book-RPS">createStaffMember: nameString phone: phoneString commissionRate: commissionFloat discountRate: discountFloat creator: aStaffMember	self addStaffMember: (StaffMember				named: nameString				phoneNumber: phoneString				commissionRate: commissionFloat				discountRate: discountFloat				creator: aStaffMember)</body><body package="Fit-Book-RPS">createStaffMember: nameString phone: phoneString creator: aStaffMember	self addStaffMember: (StaffMember				named: nameString				phoneNumber: phoneString				creator: aStaffMember)</body></methods><methods><class-id>RPS.RentEz</class-id> <category>testing</category><body package="Fit-Book-RPS">containsHireItemType: aString	^rentalItemTypes includesKey: aString</body><body package="Fit-Book-RPS">containsHireItemTypeAnywhere: aString	(self containsHireItemType: aString) ifTrue: [^true].	^pendingAdminTransactions		anySatisfy: [:each | each hireItemExistsInTransaction: aString]</body></methods><methods><class-id>RPS.RentEz</class-id> <category>repairs</category><body package="Fit-Book-RPS">removeForRepair: anInteger ofType: aString	^(self rentalItemTypeNamed: aString) removeForRepair: anInteger</body><body package="Fit-Book-RPS">returnFromRepair: anInteger ofType: aString on: aMyDate	^(self rentalItemTypeNamed: aString) return: anInteger		itemsFromRepairOn: aMyDate</body></methods><methods><class-id>RPS.RentEz</class-id> <category>operations</category><body package="Fit-Book-RPS">applyRestriction: anInteger toItem: aString	| itemType restriction |	(itemRestrictions includesKey: anInteger)		ifFalse: 			[^self				error: 'ItemRestriction id ' , anInteger printString , ' does not exist'].	(rentalItemTypes includesKey: aString)		ifFalse: [^self error: 'RentalItemType ' , aString , ' does not exist'].	itemType := self rentalItemTypeNamed: aString.	restriction := itemRestrictions at: anInteger.	itemType addItemRestriction: restriction</body><body package="Fit-Book-RPS">changeDeliveryRateCity: cityString zone: zoneString oldFlatFee: oldMoney rate: aDouble newFlatFee: newMoney	(self deliveryRateForCity: cityString zone: zoneString) flatFee: newMoney</body></methods><methods><class-id>RPS.RentEz</class-id> <category>removing</category><body package="Fit-Book-RPS">removeClientNamed: aString	| client |	client := clients at: aString ifAbsent: [^false].	client bookings isEmpty ifFalse: [^false].	clients removeKey: aString.	^true</body><body package="Fit-Book-RPS">removeDeliveryCity: cityString zone: zoneString	deliveryRates		remove: (self deliveryRateForCity: cityString zone: zoneString)</body><body package="Fit-Book-RPS">removeRentalItemTypeNamed: aString	rentalItemTypes removeKey: aString ifAbsent: []</body></methods><methods><class-id>RPS.RentEz class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">new	^super new initialize</body></methods><methods><class-id>RPS.CancelDeliveryTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setDelivery: aDelivery count: anInteger itemType: aRentalItemType bookingDate: aMyDate period: aDurationRPS	count := anInteger.	hireItemType := aRentalItemType.	period := aDurationRPS.	booking := self client				bookingWith: count				of: hireItemType				startDate: aMyDate				endDate: (period dateAfter: aMyDate)				delivery: aDelivery.	booking ifNil: [^self error: 'No delivery found for booking']</body></methods><methods><class-id>RPS.CancelDeliveryTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	| rentalCost |	rentalCost := hireItemType totalRentalCostForDuration: period				quantity: count.	^booking delivery		ifNil: [rentalCost negated]		ifNotNil: 			[:delivery |			rentalCost negated				- ((self rentEz deliveryRateForCity: delivery city zone: delivery zone)						deliveryCostForAmount: rentalCost)]</body></methods><methods><class-id>RPS.CancelDeliveryTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	booking cancel</body></methods><methods><class-id>RPS.CancelDeliveryTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">delivery: aDelivery quantity: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS transaction: aTransaction	^(self transaction: aTransaction)		setDelivery: aDelivery		count: anInteger		itemType: aRentalItemType		bookingDate: aMyDate		period: aDurationRPS</body></methods><methods><class-id>RPS.Reservation</class-id> <category>accessing</category><body package="Fit-Book-RPS">count	^reservedItems size</body><body package="Fit-Book-RPS">dueDate	^duration dateAfter: startDate</body><body package="Fit-Book-RPS">hireItemType	^hireItemType</body><body package="Fit-Book-RPS">hiredDuration	^duration</body><body package="Fit-Book-RPS">period	^duration</body><body package="Fit-Book-RPS">reservedItems	^reservedItems</body><body package="Fit-Book-RPS">startDate	^startDate</body><body package="Fit-Book-RPS">totalRentalCost	^hireItemType totalRentalCostForDuration: duration		quantity: reservedItems size</body></methods><methods><class-id>RPS.Reservation</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setQuantity: anInteger type: aRentalItemType duration: aDuration startDate: aMyDate	| dueDate itemsToBeReserved |	hireItemType := aRentalItemType.	startDate := aMyDate.	duration := aDuration.	reservedItems := Dictionary new.	dueDate := aDuration dateAfter: aMyDate.	itemsToBeReserved := aRentalItemType				reserve: anInteger				from: aMyDate				to: dueDate				forReservation: self.	itemsToBeReserved		do: [:each | reservedItems at: each identifier put: each]</body></methods><methods><class-id>RPS.Reservation</class-id> <category>renting</category><body package="Fit-Book-RPS">addRentalItems: aReservation	reservedItems addAll: aReservation reservedItems</body><body package="Fit-Book-RPS">hireItems: aRental client: aClient staffMember: aStaffMember	reservedItems do: 			[:each |			each				doHire: aRental				reservation: self				client: aClient				staffMember: aStaffMember]</body><body package="Fit-Book-RPS">returnItems: aCollection	aCollection		do: [:each | reservedItems removeKey: each identifier ifAbsent: []]</body></methods><methods><class-id>RPS.Reservation</class-id> <category>enumerating</category><body package="Fit-Book-RPS">hireItems	^reservedItems values</body></methods><methods><class-id>RPS.Reservation</class-id> <category>removing</category><body package="Fit-Book-RPS">removeAll	reservedItems do: [:each | each removeReservation: self].	reservedItems := Dictionary new</body></methods><methods><class-id>RPS.Reservation class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">quantity: anInteger of: aRentalItemType for: aDuration startingOn: aMyDate	^self new		setQuantity: anInteger		type: aRentalItemType		duration: aDuration		startDate: aMyDate</body></methods><methods><class-id>RPS.CreditCardType</class-id> <category>private</category><body package="Fit-Book-RPS">addDigitsOf: anInteger	anInteger &lt; 10 ifTrue: [^anInteger].	^1 + anInteger - 10</body><body package="Fit-Book-RPS">cardHasExpired: aCreditCard	^(aCreditCard expiryDate afterMonths: 1) before: aCreditCard rentEz time</body><body package="Fit-Book-RPS">lengthOf: aCreditCard isOneOf: anArray	^anArray anySatisfy: [:each | aCreditCard creditCardNumber size = each]</body><body package="Fit-Book-RPS">mod10Test: aCreditCard	| even total |	even := false.	total := aCreditCard creditCardNumber reverse inject: 0				into: 					[:sum :each |					| wasEven |					wasEven := even.					even := even not.					sum + (self valueOfDigit: each even: wasEven)].	^(total \\ 10) isZero</body><body package="Fit-Book-RPS">prefixOf: aCreditCard isOneOf: anArray	^anArray		anySatisfy: [:each | aCreditCard creditCardNumber beginsWith: each]</body><body package="Fit-Book-RPS">valueOfDigit: aCharacter even: aBoolean	| value |	value := aCharacter digitValue.	aBoolean ifFalse: [^value].	^self addDigitsOf: value * 2</body></methods><methods><class-id>RPS.CreditCardType</class-id> <category>constants</category><body package="Fit-Book-RPS">validLengths	^self subclassResponsibility</body><body package="Fit-Book-RPS">validPrefixes	^self subclassResponsibility</body></methods><methods><class-id>RPS.CreditCardType</class-id> <category>testing</category><body package="Fit-Book-RPS">isValidCreditCard: aCreditCard	(self cardHasExpired: aCreditCard) ifTrue: [^false].	(self prefixOf: aCreditCard isOneOf: self validPrefixes) ifFalse: [^false].	(self lengthOf: aCreditCard isOneOf: self validLengths) ifFalse: [^false].	^self mod10Test: aCreditCard</body></methods><methods><class-id>RPS.CreditCardType class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">named: aString	| class |	class := self subclasses detect: [:each | each name asString = aString]				ifNone: 					[^InvalidCreditCardException raiseErrorString: 'No such Credit Card type'].	^class new</body></methods><methods><class-id>RPS.Discover</class-id> <category>constants</category><body package="Fit-Book-RPS">validLengths	^#(16)</body><body package="Fit-Book-RPS">validPrefixes	^#('6011')</body></methods><methods><class-id>RPS.ChangePeriodOfBookingTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	originalPeriod &lt; newPeriod		ifTrue: [booking extendInto: reservation]		ifFalse: [booking shrinkTo: newPeriod]</body></methods><methods><class-id>RPS.ChangePeriodOfBookingTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^hireItemType totalRentalCostForDuration: newPeriod - originalPeriod		quantity: count</body></methods><methods><class-id>RPS.ChangePeriodOfBookingTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setQuantity: anInteger itemType: aRentalItemType bookingDate: aMyDate originalPeriod: oldDurationRPS newPeriod: newDurationRPS	count := anInteger.	hireItemType := aRentalItemType.	bookingDate := aMyDate.	originalPeriod := oldDurationRPS.	newPeriod := newDurationRPS.	booking := self client				bookingWith: count				of: hireItemType				startDate: bookingDate				endDate: (originalPeriod dateAfter: bookingDate).	originalPeriod &lt; newPeriod		ifTrue: [reservation := booking reserveForExtendedPeriod: newPeriod]</body></methods><methods><class-id>RPS.ChangePeriodOfBookingTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">change: anInteger of: aRentalItemType on: aMyDate from: oldDurationRPS to: newDurationRPS transaction: aTransaction	^(self transaction: aTransaction)		setQuantity: anInteger		itemType: aRentalItemType		bookingDate: aMyDate		originalPeriod: oldDurationRPS		newPeriod: newDurationRPS</body></methods><methods><class-id>RPS.Transaction</class-id> <category>accessing</category><body package="Fit-Book-RPS">paymentTotal	^transactionItems inject: Money zero		into: 			[:sum :each |			((each isKindOf: CashPaymentTransactionItem)				or: [each isKindOf: RefundCashTransactionItem])					ifTrue: [sum + each totalCost]					ifFalse: [sum]]</body><body package="Fit-Book-RPS">rentEz	^rentEz</body><body package="Fit-Book-RPS">staffMember	^staffMember</body><body package="Fit-Book-RPS">startDate	^startDate</body><body package="Fit-Book-RPS">subTotal	^transactionItems inject: Money zero		into: 			[:sum :each |			(each isKindOf: ClientTransactionItem)				ifTrue: [sum + each totalCost]				ifFalse: [sum]]</body><body package="Fit-Book-RPS">total	^transactionItems inject: Money zero		into: [:sum :each | sum + each totalCost]</body></methods><methods><class-id>RPS.Transaction</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setRentEz: aRentEz startDate: aMyDate staffMember: aStaffMember	transactionItems := OrderedCollection new.	rentEz := aRentEz.	(aStaffMember startTransaction: self)		ifFalse: [^self error: 'Staff member must not have a pending transaction'].	startDate := aMyDate.	staffMember := aStaffMember</body></methods><methods><class-id>RPS.Transaction</class-id> <category>adding</category><body package="Fit-Book-RPS">addTransactionItem: aTransactionItem	(transactionItems includes: aTransactionItem) ifTrue: [^false].	transactionItems add: aTransactionItem.	^true</body></methods><methods><class-id>RPS.Transaction</class-id> <category>operations</category><body package="Fit-Book-RPS">abort	transactionItems removeAll.	^true</body><body package="Fit-Book-RPS">cancel	^self paymentTotal isZero</body><body package="Fit-Book-RPS">complete	self total isZero		ifFalse: [^self error: 'Cash outstanding: ' , self total printString].	transactionItems do: #complete.	staffMember transactionComplete		ifFalse: [^self error: 'Staff member incomplete'].	transactionItems removeAll.	^true</body></methods><methods><class-id>RPS.Transaction</class-id> <category>removing</category><body package="Fit-Book-RPS">removeLastTransactionItem	transactionItems removeLast</body><body package="Fit-Book-RPS">removeTransactionItem: aTransactionItem	transactionItems remove: aTransactionItem</body></methods><methods><class-id>RPS.Transaction class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">rentEz: aRentEz startDate: aMyDate staffMember: aStaffMember	^self new setRentEz: aRentEz startDate: aMyDate staffMember: aStaffMember</body></methods><methods><class-id>RPS.ClientTransaction</class-id> <category>accessing</category><body package="Fit-Book-RPS">client	^client</body><body package="Fit-Book-RPS">owing	^self paymentTotal</body><body package="Fit-Book-RPS">staff	^staffMember name</body></methods><methods><class-id>RPS.ClientTransaction</class-id> <category>testing</category><body package="Fit-Book-RPS">isStaffHiringFromThemselves	^client name = staffMember name</body><body package="Fit-Book-RPS">isStaffTransaction	[rentEz staffMemberNamed: client name] on: MissingException		do: [:ex | ^false].	^true</body></methods><methods><class-id>RPS.ClientTransaction</class-id> <category>operations</category><body package="Fit-Book-RPS">acceptBooking: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS	| item |	item := AcceptBookingTransactionItem				acceptBooking: anInteger				of: aRentalItemType				on: aMyDate				for: aDurationRPS				transaction: self.	self addTransactionItem: item.	^item totalCost</body><body package="Fit-Book-RPS">book: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS	^self		book: anInteger		of: aRentalItemType		on: aMyDate		for: aDurationRPS		deliveryRate: nil</body><body package="Fit-Book-RPS">book: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS deliveryRate: aDeliveryRate	^self		book: anInteger		of: aRentalItemType		on: aMyDate		for: aDurationRPS		deliveryRate: aDeliveryRate		address: client address</body><body package="Fit-Book-RPS">book: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS deliveryRate: aDeliveryRate address: addressString	| item |	item := BookTransactionItem				book: anInteger				of: aRentalItemType				on: aMyDate				for: aDurationRPS				deliveryRate: aDeliveryRate				address: addressString				transaction: self.	self addTransactionItem: item.	^item totalCost</body><body package="Fit-Book-RPS">bookTemplate: aTemplate forPeople: anInteger on: aMyDate duration: aDurationRPS	| rentCount |	rentCount := 0.	aTemplate items do: 			[:each |			| itemsNeeded |			itemsNeeded := each itemsNeededForPeople: anInteger.						[(each itemType isKindOf: RentalItemType)				ifTrue: 					[self						book: itemsNeeded						of: each itemType						on: aMyDate						for: aDurationRPS.					rentCount := rentCount + 1]				ifFalse: [self buy: itemsNeeded of: each itemType]]					on: Error					do: 						[:ex |						rentCount timesRepeat: [self removeLastTransactionItem].						^false]].	^true</body><body package="Fit-Book-RPS">buy: anInteger of: aBuyItemType	| item |	item := SalesPaymentTransaction				quantity: anInteger				of: aBuyItemType				transaction: self.	self addTransactionItem: item.	^item totalCost</body><body package="Fit-Book-RPS">cancel	super cancel ifFalse: [^false].	client clearCurrentTransaction.	self removeLastTransactionItem.	^true</body><body package="Fit-Book-RPS">cancelBooking: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS	| item |	item := CancelBookingTransactionItem				cancel: anInteger				of: aRentalItemType				on: aMyDate				for: aDurationRPS				transaction: self.	self addTransactionItem: item.	^item totalCost</body><body package="Fit-Book-RPS">cancelDelivery: anInteger of: aRentalItemType toAddress: addressString inZone: zoneString ofCity: cityString for: aDurationRPS on: aMyDate	| item |	item := 			[CancelDeliveryTransactionItem				delivery: (Delivery						quantity: anInteger						of: aRentalItemType name						toAddress: addressString						inZone: zoneString						ofCity: cityString						onDate: aMyDate)				quantity: anInteger				of: aRentalItemType				on: aMyDate				for: aDurationRPS				transaction: self]					on: Error					do: [:ex | ^false].	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">changeDelivery: anInteger of: aRentalItemType toAddress: oldAddressString inZone: oldZoneString ofCity: cityString for: aDurationRPS on: aMyDate toNewZone: newZoneString address: newAddressString	| item |	item := ChangeDeliveryTransactionItem				delivery: (Delivery						quantity: anInteger						of: aRentalItemType name						toAddress: oldAddressString						inZone: oldZoneString						ofCity: cityString						onDate: aMyDate)				quantity: anInteger				of: aRentalItemType				on: aMyDate				for: aDurationRPS				newZone: newZoneString				address: newAddressString				transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">changePeriodOfBooking: anInteger of: aRentalItemType on: aMyDate from: oldDurationRPS to: newDurationRPS	| item |	item := ChangePeriodOfBookingTransactionItem				change: anInteger				of: aRentalItemType				on: aMyDate				from: oldDurationRPS				to: newDurationRPS				transaction: self.	self addTransactionItem: item.	^item totalCost</body><body package="Fit-Book-RPS">complete	| completed discountRate total discount |	self isStaffTransaction		ifTrue: 			[discountRate := (rentEz staffMemberNamed: client name) discountRate.			total := self subTotal.			discount := total * (discountRate / 100.0) negated.			self giveStaffDiscount: discount].	completed := super complete and: [client transactionComplete].	completed		ifTrue: [rentEz removePendingTransactionForClientNamed: client name].	^completed</body><body package="Fit-Book-RPS">dropRent: anInteger of: aRentalItemType for: aDurationRPS	| item |	item := transactionItems detect: 					[:each |					each isSameCount: anInteger type: aRentalItemType duration: aDurationRPS]				ifNone: [^false].	self		addDroppedTransactionItem: item;		removeTransactionItem: item.	^true</body><body package="Fit-Book-RPS">giveStaffDiscount: aMoney	| item |	self isStaffTransaction ifFalse: [^false].	item := RefundCashTransactionItem refund: aMoney transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">modifyRentalDetails: oldCountInteger of: aString for: oldDurationRPS toCount: newCountInteger duration: newDurationRPS	| item |	item := transactionItems detect: 					[:each |					(each isKindOf: RentalTransactionItem) and: 							[each isSameCount: oldCountInteger type: aString duration: oldDurationRPS]]				ifNone: [^false].	^item newCount: newCountInteger duration: newDurationRPS</body><body package="Fit-Book-RPS">payOnAccount: aMoney	| item |	item := AccountPaymentTransactionItem amount: aMoney transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">payWithBonusPoints: aBonusPoints	| item |	self voucherUsed ifTrue: [^false].	client bonusPoints &gt;= aBonusPoints ifFalse: [^false].	item := BonusPointPaymentTransactionItem				points: aBonusPoints				client: client				transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">payWithCash: aMoney	| item |	item := CashPaymentTransactionItem amount: aMoney transaction: self.	self addTransactionItem: item.	client topupBonusPoints: (BonusPoints forAmountSpent: aMoney).	^true</body><body package="Fit-Book-RPS">payWithCreditCard: aMoney cardType: typeString expiryString: expiryString cardNumber: numberString	| item |	CreditCard		type: typeString		expiryString: expiryString		number: numberString		rentEz: rentEz.	item := CreditCardPaymentTransactionItem amount: aMoney transaction: self.	self addTransactionItem: item.	client topupBonusPoints: (BonusPoints forAmountSpent: aMoney).	^true</body><body package="Fit-Book-RPS">payWithVoucher: aVoucher	| item |	(aVoucher isExpiredOn: rentEz time) ifTrue: [^false].	self bonusPointsUsed ifTrue: [^false].	item := VoucherPaymentTransactionItem				voucher: aVoucher				payment: self total				client: client				transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">purchaseVoucher: aMoney	client topupBonusPoints: (BonusPoints forAmountSpent: aMoney).	^true</body><body package="Fit-Book-RPS">refundAccount: aMoney	| item |	item := RefundAccountTransactionItem				amount: aMoney				client: client				transaction: self.	self addTransactionItem: item.	client reduceBonusPoints: (BonusPoints forAmountSpent: aMoney).	^true</body><body package="Fit-Book-RPS">refundCash: aMoney	| item |	item := RefundCashTransactionItem refund: aMoney transaction: self.	self addTransactionItem: item.	client reduceBonusPoints: (BonusPoints forAmountSpent: aMoney).	^true</body><body package="Fit-Book-RPS">rent: anInteger of: aRentalItemType for: aDurationRPS	^self		rent: anInteger		of: aRentalItemType		for: aDurationRPS		restrictionsSatisfied: #()</body><body package="Fit-Book-RPS">rent: anInteger of: aRentalItemType for: aDuration restrictionsSatisfied: anArray	| item |	(aRentalItemType canRentWithSatisfiedRestrictions: anArray)		ifFalse: [^self error: 'Transaction rejected - Restriction not met'].	item := RentalTransactionItem				rent: anInteger				of: aRentalItemType				for: aDuration				transaction: self.	self addTransactionItem: item.	^item totalCost</body><body package="Fit-Book-RPS">rentTemplate: aTemplate forPeople: anInteger duration: aDurationRPS	| rentCount |	rentCount := 0.	aTemplate items do: 			[:each |						[self				rent: (each itemsNeededForPeople: anInteger)				of: each itemType				for: aDurationRPS.			rentCount := rentCount + 1]					on: Error					do: 						[:ex |						rentCount timesRepeat: [self removeLastTransactionItem].						^false]].	^true</body><body package="Fit-Book-RPS">return: anInteger of: aRentalItemType costToFix: aMoney	| item |	item := ReturnItemsTransactionItem				return: anInteger				of: aRentalItemType				costToFix: aMoney				transaction: self.	self addTransactionItem: item.	^item totalCost</body><body package="Fit-Book-RPS">undropRent: anInteger of: aRentalItemType for: aDurationRPS	| item |	item := droppedTransactionItems detect: 					[:each |					each isSameCount: anInteger type: aRentalItemType duration: aDurationRPS]				ifNone: [^false].	self		removeDroppedTransactionItem: item;		addTransactionItem: item.	^true</body></methods><methods><class-id>RPS.ClientTransaction</class-id> <category>private</category><body package="Fit-Book-RPS">addDroppedTransactionItem: aTransactionItem	droppedTransactionItems add: aTransactionItem</body><body package="Fit-Book-RPS">bonusPointsUsed	^transactionItems		anySatisfy: [:each | each isKindOf: BonusPointPaymentTransactionItem]</body><body package="Fit-Book-RPS">removeDroppedTransactionItem: aTransactionItem	droppedTransactionItems remove: aTransactionItem</body><body package="Fit-Book-RPS">voucherUsed	^transactionItems		anySatisfy: [:each | each isKindOf: VoucherPaymentTransactionItem]</body></methods><methods><class-id>RPS.ClientTransaction</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setClient: aClient deliver: aBoolean	droppedTransactionItems := OrderedCollection new.	(aClient startTransaction: self)		ifFalse: [^self error: 'Client must not have a pending transaction'].	client := aClient.	self isStaffHiringFromThemselves		ifTrue: [^self error: 'Staff Hires are not allowed']</body></methods><methods><class-id>RPS.ClientTransaction class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">rentEz: aRentEz startDate: aMyDate staffMember: aStaffMember client: aClient deliver: aBoolean	^(self rentEz: aRentEz startDate: aMyDate staffMember: aStaffMember)		setClient: aClient deliver: aBoolean;		yourself</body></methods><methods><class-id>RPS.MyDate</class-id> <category>comparing</category><body package="Fit-Book-RPS">= aMyDate	self species = aMyDate species ifFalse: [^false].	^timestamp = aMyDate timestamp</body><body package="Fit-Book-RPS">after: aMyDate	^timestamp &gt; aMyDate timestamp</body><body package="Fit-Book-RPS">before: aMyDate	^timestamp &lt; aMyDate timestamp</body><body package="Fit-Book-RPS">hash	^timestamp hash</body></methods><methods><class-id>RPS.MyDate</class-id> <category>accessing</category><body package="Fit-Book-RPS">timestamp	^timestamp</body></methods><methods><class-id>RPS.MyDate</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setTimestamp: aTimestamp	timestamp := aTimestamp</body></methods><methods><class-id>RPS.MyDate</class-id> <category>printing</category><body package="Fit-Book-RPS">printOn: aStream	TimestampPrintPolicy print: timestamp on: aStream using: 'yyyy/mm/dd hh:mm'</body></methods><methods><class-id>RPS.MyDate</class-id> <category>arithmetic</category><body package="Fit-Book-RPS">+ aDurationRPS	^self class timestamp: timestamp + aDurationRPS asCoreDuration</body><body package="Fit-Book-RPS">afterMonths: anInteger	^self class timestamp: (timestamp rpsAddMonths: anInteger)</body><body package="Fit-Book-RPS">durationTo: aMyDate	| difference days |	difference := aMyDate timestamp - timestamp.	days := difference days.	^DurationRPS		hours: difference hours		days: days \\ 7		weeks: days // 7</body></methods><methods><class-id>RPS.MyDate class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">fitParse: aString	| timestamp |	timestamp := (TimestampReader newFor: #fitLibrary)				readTimestampFrom: aString readStream.	^self timestamp: timestamp</body><body package="Fit-Book-RPS">fromMilliseconds: anInteger	^self timestamp: (Timestamp fromMilliseconds: anInteger)</body><body package="Fit-Book-RPS">new	^self timestamp: Timestamp now</body><body package="Fit-Book-RPS">timestamp: aTimestamp	^self basicNew setTimestamp: aTimestamp</body></methods><methods><class-id>RPS.AddIdentifiedHireItemTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">id	^id</body><body package="Fit-Book-RPS">totalCost	^Money zero</body><body package="Fit-Book-RPS">type	^type</body></methods><methods><class-id>RPS.AddIdentifiedHireItemTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setId: idString type: typeString lastMaintainedDate: aMyDate monthsBetweenMaintenance: aDouble	id := idString.	type := typeString.	lastMaintainedDate := aMyDate.	monthsBetweenMaintenance := aDouble</body></methods><methods><class-id>RPS.AddIdentifiedHireItemTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	(self rentEz rentalItemTypeNamed: type)		addRentalItem: id		lastMaintained: lastMaintainedDate		monthsBetweenMaintenance: monthsBetweenMaintenance</body></methods><methods><class-id>RPS.AddIdentifiedHireItemTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">id: idString type: typeString lastMaintainedDate: aMyDate transaction: aTransaction monthsBetweenMaintenance: aDouble	^(self transaction: aTransaction)		setId: idString		type: typeString		lastMaintainedDate: aMyDate		monthsBetweenMaintenance: aDouble</body></methods><methods><class-id>RPS.DeleteFromTemplateTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	template deleteItem: itemType</body></methods><methods><class-id>RPS.DeleteFromTemplateTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.DeleteFromTemplateTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setTemplate: aTemplate itemType: aRentalItemType	template := aTemplate.	itemType := aRentalItemType</body></methods><methods><class-id>RPS.DeleteFromTemplateTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">template: aTemplate itemType: aRentalItemType transaction: aTransaction	^(self transaction: aTransaction) setTemplate: aTemplate		itemType: aRentalItemType</body></methods><methods><class-id>RPS.CancelBookingTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setQuantity: anInteger itemType: aRentalItemType bookingDate: aMyDate period: aDurationRPS	count := anInteger.	hireItemType := aRentalItemType.	bookingDate := aMyDate.	period := aDurationRPS.	booking := self client				bookingWith: count				of: hireItemType				startDate: bookingDate				endDate: (period dateAfter: bookingDate)</body></methods><methods><class-id>RPS.CancelBookingTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	booking cancel</body></methods><methods><class-id>RPS.CancelBookingTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	| rentalCost |	rentalCost := hireItemType totalRentalCostForDuration: period				quantity: count.	^booking delivery		ifNil: [rentalCost negated]		ifNotNil: 			[:delivery |			rentalCost negated				- ((self rentEz deliveryRateForCity: delivery city zone: delivery zone)						deliveryCostForAmount: rentalCost)]</body></methods><methods><class-id>RPS.CancelBookingTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">cancel: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS transaction: aTransaction	^(self transaction: aTransaction)		setQuantity: anInteger		itemType: aRentalItemType		bookingDate: aMyDate		period: aDurationRPS</body></methods><methods><class-id>RPS.VoucherPaymentTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setVoucher: aVoucher payment: aMoney client: aClient	voucher := aVoucher.	payment := aMoney.	client := aClient</body></methods><methods><class-id>RPS.VoucherPaymentTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	"Nothing to do"</body></methods><methods><class-id>RPS.VoucherPaymentTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^(voucher amount min: payment) negated</body></methods><methods><class-id>RPS.VoucherPaymentTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">voucher: aVoucher payment: aMoney client: aClient transaction: aTransaction	^(self transaction: aTransaction)		setVoucher: aVoucher		payment: aMoney		client: aClient</body></methods><methods><class-id>RPS.Rates</class-id> <category>accessing</category><body package="Fit-Book-RPS">costForPeriod: aDuration	| period |	period := self fairDuration: aDuration.	^hourly * period hours + (daily * period days)		+ (weekly * period weeks)</body><body package="Fit-Book-RPS">daily	^daily</body><body package="Fit-Book-RPS">fairDuration: aDuration	| hours days weeks |	hours := aDuration hours.	days := aDuration days.	weeks := aDuration weeks.	hourly * hours &gt;= daily		ifTrue: 			[hours := 0.			days := days + 1].	hourly * days * 24 &lt; (daily * days)		ifTrue: 			[hours := hours + (days * 24).			days := 0].	daily * days &gt;= weekly		ifTrue: 			[days := 0.			weeks := weeks + 1].	daily * weeks * 7 &lt; (weekly * weeks)		ifTrue: 			[days := days + (weeks * 7).			weeks := 0].	weeks &gt; 0 ifTrue: [hours := 0].	^DurationRPS hours: hours days: days weeks: weeks</body><body package="Fit-Book-RPS">hourly	^hourly</body><body package="Fit-Book-RPS">weekly	^weekly</body></methods><methods><class-id>RPS.Rates</class-id> <category>comparing</category><body package="Fit-Book-RPS">= aRates	^hourly = aRates hourly		and: [daily = aRates daily and: [weekly = aRates weekly]]</body><body package="Fit-Book-RPS">hash	^(hourly hash hashMultiply bitXor: daily hash) hashMultiply		bitXor: weekly hash</body></methods><methods><class-id>RPS.Rates</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setHourly: hourlyMoney daily: dailyMoney weekly: weeklyMoney	hourly := hourlyMoney.	daily := dailyMoney.	weekly := weeklyMoney.	daily isZero ifTrue: [daily := hourly * 24].	weekly isZero ifTrue: [weekly := daily * 7]</body></methods><methods><class-id>RPS.Rates class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">hourly: hourlyMoney daily: dailyMoney weekly: weeklyMoney	^self new setHourly: hourlyMoney daily: dailyMoney weekly: weeklyMoney</body></methods><methods><class-id>RPS.CreditCardPaymentTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^amount negated</body></methods><methods><class-id>RPS.CreditCardPaymentTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setAmount: aMoney	amount := aMoney</body></methods><methods><class-id>RPS.CreditCardPaymentTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	"Nothing to do"</body></methods><methods><class-id>RPS.CreditCardPaymentTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">amount: aMoney transaction: aTransaction	^(self transaction: aTransaction) setAmount: aMoney</body></methods><methods><class-id>RPS.Template</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">initialize	super initialize.	items := OrderedCollection new</body></methods><methods><class-id>RPS.Template</class-id> <category>filling</category><body package="Fit-Book-RPS">fillForPeople: anInteger duration: aDurationRPS	^items inject: Money zero		into: [:total :each | total + (each costForPeople: anInteger duration: aDurationRPS)]</body></methods><methods><class-id>RPS.Template</class-id> <category>adding</category><body package="Fit-Book-RPS">addItem: aRentalItemType forPeople: aFloat	| item |	item := self findItem: aRentalItemType				ifNone: 					[items add: (TemplateItem quantity: aFloat of: aRentalItemType).					^true].	item count: aFloat.	^true</body></methods><methods><class-id>RPS.Template</class-id> <category>private</category><body package="Fit-Book-RPS">findItem: aRentalItemType ifNone: aBlock	^items detect: [:each | each itemType name = aRentalItemType name]		ifNone: [aBlock value]</body></methods><methods><class-id>RPS.Template</class-id> <category>removing</category><body package="Fit-Book-RPS">deleteItem: aRentalItemType	| toDelete |	toDelete := self findItem: aRentalItemType ifNone: [^false].	items remove: toDelete.	^true</body></methods><methods><class-id>RPS.Template</class-id> <category>accessing</category><body package="Fit-Book-RPS">items	^items</body></methods><methods><class-id>RPS.Template class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">new	^super new initialize</body></methods><methods><class-id>RPS.AddDeliveryRateTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCity: cityString zone: zoneString flatFee: aMoney rate: aDouble	city := cityString.	zone := zoneString.	flatFee := aMoney.	rate := aDouble</body></methods><methods><class-id>RPS.AddDeliveryRateTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	self rentEz createDeliveryZone: (DeliveryRate				city: city				zone: zone				flatFee: flatFee				rate: rate)</body></methods><methods><class-id>RPS.AddDeliveryRateTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.AddDeliveryRateTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">city: cityString zone: zoneString flatFee: aMoney rate: aDouble transaction: aTransaction	^(self transaction: aTransaction)		setCity: cityString		zone: zoneString		flatFee: aMoney		rate: aDouble</body></methods><methods><class-id>RPS.Delivery</class-id> <category>accessing</category><body package="Fit-Book-RPS">changeZone: zoneString address: addressString	zone := zoneString.	deliveryAddress := addressString</body></methods><methods><class-id>RPS.Delivery</class-id> <category>comparing</category><body package="Fit-Book-RPS">= aDelivery	^date = aDelivery date and: 			[city = aDelivery city and: 					[zone = aDelivery zone and: 							[deliveryAddress = aDelivery deliveryAddress								and: [item = aDelivery item and: [itemCount = aDelivery itemCount]]]]]</body></methods><methods><class-id>RPS.Delivery</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setItemCount: anInteger itemType: itemTypeString deliveryAddress: addressString zone: zoneString city: cityString date: aMyDate	itemCount := anInteger.	item := itemTypeString.	deliveryAddress := addressString.	zone := zoneString.	city := cityString.	date := aMyDate printString</body></methods><methods><class-id>RPS.Delivery class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">quantity: anInteger of: itemTypeString toAddress: addressString inZone: zoneString ofCity: cityString onDate: aMyDate	^self new		setItemCount: anInteger		itemType: itemTypeString		deliveryAddress: addressString		zone: zoneString		city: cityString		date: aMyDate</body></methods><methods><class-id>RPS.AddHireItemTypeTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body><body package="Fit-Book-RPS">type	^type</body></methods><methods><class-id>RPS.AddHireItemTypeTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCount: anInteger type: aString rates: aRates bond: aMoney	count := anInteger.	type := aString.	rates := aRates.	bond := aMoney</body></methods><methods><class-id>RPS.AddHireItemTypeTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	self rentEz		createRentalItemType: type		initialCount: count		rates: rates		deposit: bond</body></methods><methods><class-id>RPS.AddHireItemTypeTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">count: anInteger of: aString rates: aRates bond: aMoney transaction: anAdminTransaction	^(self transaction: anAdminTransaction)		setCount: anInteger		type: aString		rates: aRates		bond: aMoney</body></methods><methods><class-id>RPS.BuyItemType</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setName: aString count: anInteger sellingPrice: aMoney	name := aString.	count := anInteger.	sellingPrice := aMoney</body></methods><methods><class-id>RPS.BuyItemType</class-id> <category>accessing</category><body package="Fit-Book-RPS">sellingPriceForQuantity: anInteger	^sellingPrice * anInteger</body></methods><methods><class-id>RPS.BuyItemType</class-id> <category>operations</category><body package="Fit-Book-RPS">add: anInteger	count := count + anInteger</body><body package="Fit-Book-RPS">sale: anInteger	anInteger &gt; count ifTrue: [^false].	count := count - anInteger.	^true</body></methods><methods><class-id>RPS.BuyItemType</class-id> <category>comparing</category><body package="Fit-Book-RPS">= aBuyItemType	^name = aBuyItemType name and: 			[count = aBuyItemType count and: [sellingPrice = aBuyItemType sellingPrice]]</body></methods><methods><class-id>RPS.BuyItemType class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">named: aString count: anInteger sellingPrice: aMoney	^self new setName: aString count: anInteger sellingPrice: aMoney</body></methods><methods><class-id>RPS.BookTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	| rentalCost |	rentalCost := itemType totalRentalCostForDuration: period quantity: count.	^deliveryRate		ifNil: [rentalCost]		ifNotNil: [rentalCost + (deliveryRate deliveryCostForAmount: rentalCost)]</body></methods><methods><class-id>RPS.BookTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	| delivery |	deliveryRate		ifNil: 			[^Booking				reservation: reservation				client: self client				staffMember: self staffMember].	delivery := Delivery				quantity: count				of: itemType name				toAddress: address				inZone: deliveryRate zone				ofCity: deliveryRate city				onDate: startDate.	Booking		reservation: reservation		client: self client		staffMember: self staffMember		delivery: delivery.	self client addDelivery: delivery</body></methods><methods><class-id>RPS.BookTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setQuantity: anInteger itemType: aRentalItemType startDate: aMyDate period: aDurationRPS deliveryRate: aDeliveryRate address: aString	count := anInteger.	itemType := aRentalItemType.	startDate := aMyDate.	period := aDurationRPS.	reservation := Reservation				quantity: anInteger				of: aRentalItemType				for: aDurationRPS				startingOn: aMyDate.	deliveryRate := aDeliveryRate.	address := aString ifNil: [self client address]</body></methods><methods><class-id>RPS.BookTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">book: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS deliveryRate: aDeliveryRate address: aString transaction: aTransaction	^(self transaction: aTransaction)		setQuantity: anInteger		itemType: aRentalItemType		startDate: aMyDate		period: aDurationRPS		deliveryRate: aDeliveryRate		address: aString</body></methods><methods><class-id>RPS.SalesPaymentTransaction</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^buyItemType sellingPriceForQuantity: count</body></methods><methods><class-id>RPS.SalesPaymentTransaction</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	(buyItemType sale: count)		ifFalse: [^self error: 'Could not complete sales payment']</body></methods><methods><class-id>RPS.SalesPaymentTransaction</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCount: anInteger buyItemType: aBuyItemType	count := anInteger.	buyItemType := aBuyItemType.	count &gt; buyItemType count		ifTrue: 			[^self error: ('Required &lt;1p&gt; but only &lt;2p&gt; left.' expandMacrosWith: count						with: buyItemType count)]</body></methods><methods><class-id>RPS.SalesPaymentTransaction class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">quantity: anInteger of: aBuyItemType transaction: aTransaction	^(self transaction: aTransaction) setCount: anInteger		buyItemType: aBuyItemType</body></methods><methods><class-id>RPS.RemoveForRepairTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.RemoveForRepairTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	(self rentEz removeForRepair: count ofType: type)		ifFalse: 			[^self				error: 'Could not remove ' , count printString , ' ' , type , ' for repair']</body></methods><methods><class-id>RPS.RemoveForRepairTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setType: aString count: anInteger	type := aString.	count := anInteger</body></methods><methods><class-id>RPS.RemoveForRepairTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">type: aString count: anInteger transaction: aTransaction	^(self transaction: aTransaction) setType: aString count: anInteger</body></methods><methods><class-id>RPS.AdminTransaction</class-id> <category>testing</category><body package="Fit-Book-RPS">checkItemToReturnFromRepair: aString count: anInteger	^(rentEz rentalItemTypeNamed: aString)		checkNumberOfItemsInRepair: anInteger</body><body package="Fit-Book-RPS">hireItemExistsInTransaction: aString	^transactionItems anySatisfy: 			[:each |			(each isKindOf: AddHireItemTypeTransactionItem) and: [each type = aString]]</body><body package="Fit-Book-RPS">hireItemTypeExistsInRentEz: aString	^self rentEz containsHireItemType: aString</body><body package="Fit-Book-RPS">transactionIncludesIdentifiedItem: idString ofType: typeString	^transactionItems anySatisfy: 			[:each |			(each isKindOf: AddIdentifiedHireItemTransactionItem)				and: [each type = typeString and: [each id = idString]]]</body></methods><methods><class-id>RPS.AdminTransaction</class-id> <category>adding</category><body package="Fit-Book-RPS">add: anInteger ofRentalItemType: aString rates: aRates bond: aMoney	| item |	(rentEz containsHireItemTypeAnywhere: aString) ifTrue: [^false].	item := AddHireItemTypeTransactionItem				count: anInteger				of: aString				rates: aRates				bond: aMoney				transaction: self.	^self addTransactionItem: item</body><body package="Fit-Book-RPS">addIdentifiedRentalItem: idString ofType: typeString lastMaintainedDate: aMyDate monthsBetweenMaintenance: aDouble	| item |	(self hireItemTypeExistsInRentEz: typeString)		ifTrue: 			[((self rentEz rentalItemTypeNamed: typeString) hasIdentifiedItem: idString)				ifTrue: [^false]]		ifFalse: 			[(self transactionIncludesIdentifiedItem: idString ofType: typeString)				ifTrue: [^false]].	item := AddIdentifiedHireItemTransactionItem				id: idString				type: typeString				lastMaintainedDate: aMyDate				transaction: self				monthsBetweenMaintenance: aDouble.	self addTransactionItem: item.	^true</body></methods><methods><class-id>RPS.AdminTransaction</class-id> <category>operations</category><body package="Fit-Book-RPS">addClient: aClient	^rentEz addClient: aClient</body><body package="Fit-Book-RPS">alterItem: itemNameString inTemplate: templateNameString people: aFloat	| item |	item := AddToTemplateTransactionItem				template: (rentEz templateNamed: templateNameString)				itemType: (rentEz rentalItemTypeNamed: itemNameString)				people: aFloat				transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">changeDeliveryZone: zoneString inCity: cityString flatFee: oldMoney rate: aDouble toFlatRate: newMoney	| item |	item := ChangeDeliveryRateTransactionItem				city: cityString				zone: zoneString				oldFlatFee: oldMoney				rate: aDouble				newFlatFee: newMoney				transaction: self.	^self addTransactionItem: item</body><body package="Fit-Book-RPS">createDeliveryZone: zoneString inCity: cityString flatFee: aMoney rate: aDouble	| item |	item := AddDeliveryRateTransactionItem				city: cityString				zone: zoneString				flatFee: aMoney				rate: aDouble				transaction: self.	^self addTransactionItem: item</body><body package="Fit-Book-RPS">deleteDeliveryZone: zoneString inCity: cityString	| item |	item := DeleteDeliveryRateTransactionItem				city: cityString				zone: zoneString				transaction: self.	^self addTransactionItem: item</body><body package="Fit-Book-RPS">deleteItem: itemNameString fromTemplate: templateNameString	| item |	item := DeleteFromTemplateTransactionItem				template: (rentEz templateNamed: templateNameString)				itemType: (rentEz rentalItemTypeNamed: itemNameString)				transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">maintenanceCompleteForItem: aString ofType: aRentalItemType	| item |	^	[item := MaintenanceCompleteTransactionItem				item: aString				type: aRentalItemType				transaction: self.	self addTransactionItem: item.	true]			on: Error			do: [:ex | false]</body><body package="Fit-Book-RPS">removeClientNamed: aString	^rentEz removeClientNamed: aString</body></methods><methods><class-id>RPS.ItemRestriction</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setId: anInteger constraint: aString	id := anInteger</body></methods><methods><class-id>RPS.ItemRestriction</class-id> <category>accessing</category><body package="Fit-Book-RPS">id	^id</body></methods><methods><class-id>RPS.ItemRestriction class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">id: anInteger constraint: aString	^self new setId: anInteger constraint: aString</body></methods><methods><class-id>RPS.Mastercard</class-id> <category>constants</category><body package="Fit-Book-RPS">validLengths	^#(16)</body><body package="Fit-Book-RPS">validPrefixes	^#('51' '52' '53' '54' '55')</body></methods><methods><class-id>RPS.DeliveryRate</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCity: cityString zone: zoneString flatFee: aMoney rate: aDouble	city := cityString.	zone := zoneString.	flatFee := aMoney.	rate := aDouble</body></methods><methods><class-id>RPS.DeliveryRate</class-id> <category>accessing</category><body package="Fit-Book-RPS">deliveryCostForAmount: aMoney	^aMoney * (rate / 100.0) + flatFee</body><body package="Fit-Book-RPS">flatFee: aMoney	flatFee := aMoney</body></methods><methods><class-id>RPS.DeliveryRate class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">city: cityString zone: zoneString flatFee: aMoney rate: aDouble	^self new		setCity: cityString		zone: zoneString		flatFee: aMoney		rate: aDouble</body></methods><methods><class-id>RPS.BonusPointPaymentTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^points value negated</body></methods><methods><class-id>RPS.BonusPointPaymentTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	client reduceBonusPoints: points</body></methods><methods><class-id>RPS.BonusPointPaymentTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setPoints: aBonusPoints client: aClient	points := aBonusPoints.	client := aClient</body></methods><methods><class-id>RPS.BonusPointPaymentTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">points: aBonusPoints client: aClient transaction: aTransaction	^(self transaction: aTransaction) setPoints: aBonusPoints client: aClient</body></methods><methods><class-id>RPS.DeleteDeliveryRateTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCity: cityString zone: zoneString	city := cityString.	zone := zoneString</body></methods><methods><class-id>RPS.DeleteDeliveryRateTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	self rentEz removeDeliveryCity: city zone: zone</body></methods><methods><class-id>RPS.DeleteDeliveryRateTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.DeleteDeliveryRateTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">city: cityString zone: zoneString transaction: aTransaction	^(self transaction: aTransaction) setCity: cityString zone: zoneString</body></methods><methods><class-id>RPS.ChangeDeliveryTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	| booking |	booking := self client				bookingWith: count				of: hireItemType				startDate: bookingDate				endDate: bookingDate + period				delivery: delivery.	booking ifNil: [^self].	booking changeDeliveryZone: newZone address: newAddress</body></methods><methods><class-id>RPS.ChangeDeliveryTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setDelivery: aDelivery count: anInteger itemType: aRentalItemType bookingDate: aMyDate period: aDurationRPS newZone: newZoneString newAddress: newAddressString	count := anInteger.	hireItemType := aRentalItemType.	bookingDate := aMyDate.	period := aDurationRPS.	delivery := aDelivery.	newAddress := newAddressString.	newZone := newZoneString</body></methods><methods><class-id>RPS.ChangeDeliveryTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	| rentalCost oldCost newCost |	rentalCost := hireItemType totalRentalCostForDuration: period				quantity: count.	oldCost := (self rentEz deliveryRateForCity: delivery city				zone: delivery zone) deliveryCostForAmount: rentalCost.	newCost := (self rentEz deliveryRateForCity: delivery city zone: newZone)				deliveryCostForAmount: rentalCost.	^newCost - oldCost</body></methods><methods><class-id>RPS.ChangeDeliveryTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">delivery: aDelivery quantity: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS newZone: newZoneString address: newAddressString transaction: aTransaction	^(self transaction: aTransaction)		setDelivery: aDelivery		count: anInteger		itemType: aRentalItemType		bookingDate: aMyDate		period: aDurationRPS		newZone: newZoneString		newAddress: newAddressString</body></methods><methods><class-id>RPS.ReturnFromRepairTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	(self rentEz		returnFromRepair: count		ofType: type		on: transaction startDate)			ifFalse: 				[^self error: 'Could not return ' , count printString , ' ' , type							, ' from repair']</body></methods><methods><class-id>RPS.ReturnFromRepairTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.ReturnFromRepairTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setType: aString count: anInteger	type := aString.	count := anInteger</body></methods><methods><class-id>RPS.ReturnFromRepairTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">type: aString count: anInteger transaction: aTransaction	^(self transaction: aTransaction) setType: aString count: anInteger</body></methods><methods><class-id>RPS.SystemClock</class-id> <category>accessing</category><body package="Fit-Book-RPS">now	^MyDate new</body></methods><methods><class-id>RPS.ReturnItemsTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	self client return: count hiresOf: rentalItemType</body></methods><methods><class-id>RPS.ReturnItemsTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCount: anInteger rentalItemType: aRentalItemType costToFix: aMoney	count := anInteger.	rentalItemType := aRentalItemType.	costToFix := aMoney.	(rentalItemType hasHiresToReturn: count)		ifFalse: 			[^self error: 'There aren''t ' , count printString , ' items to return']</body></methods><methods><class-id>RPS.ReturnItemsTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	| time refundOnReturn |	time := self rentEz time.	refundOnReturn := rentalItemType calculateRefundOnReturnOf: count				atTime: time.	^costToFix - (rentalItemType bondForItems: count) - refundOnReturn</body></methods><methods><class-id>RPS.ReturnItemsTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">return: anInteger of: aRentalItemType costToFix: aMoney transaction: aClientTransaction	^(self transaction: aClientTransaction)		setCount: anInteger		rentalItemType: aRentalItemType		costToFix: aMoney</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>accessing</category><body package="Fit-Book-RPS">bondForItems: anInteger	^deposit * anInteger</body><body package="Fit-Book-RPS">deposit	^deposit</body><body package="Fit-Book-RPS">hiresToReturn: anInteger	^((hireItems values select: #hasHireToReturn)		sorted: [:a :b | b endDate after: a endDate]) first: anInteger</body><body package="Fit-Book-RPS">identifiedHireItems	^hireItems values</body><body package="Fit-Book-RPS">rates	^rates</body><body package="Fit-Book-RPS">totalRentalCostForDuration: aRPSDuration quantity: anInteger	^((rates costForPeriod: aRPSDuration) + deposit) * anInteger</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>printing</category><body package="Fit-Book-RPS">printOn: aStream 	aStream nextPutAll: name</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>operations</category><body package="Fit-Book-RPS">calculateRefundOnReturnOf: anInteger atTime: aMyDate	^(self hiresToReturn: anInteger) inject: Money zero		into: 			[:refundAmount :each |			| hiredDuration actualDuration hiredCost actualCost |			hiredDuration := each hiredDuration.			actualDuration := each startDate durationTo: aMyDate.			hiredCost := rates costForPeriod: hiredDuration.			actualCost := rates costForPeriod: actualDuration.			refundAmount + hiredCost - actualCost]</body><body package="Fit-Book-RPS">forMaintenanceAsOf: aMyDate into: aSet	aSet		addAll: (hireItems select: [:each | each needsMaintenanceAsOf: aMyDate])</body><body package="Fit-Book-RPS">removeForRepair: anInteger	| count |	count := anInteger.	hireItems do: 			[:each |			count isZero ifTrue: [^true].			each repair.			count := count - 1].	^count isZero</body><body package="Fit-Book-RPS">reserve: anInteger from: startMyDate to: dueMyDate forReservation: aReservation	| pendingHireItems rs |	pendingHireItems := OrderedCollection new.	rs := hireItems values readStream.	[rs atEnd or: [pendingHireItems size = anInteger]] whileFalse: 			[| item |			item := rs next.			(item reserveFrom: startMyDate to: dueMyDate reservation: aReservation)				ifTrue: [pendingHireItems add: item]].	pendingHireItems size = anInteger		ifFalse: 			[pendingHireItems do: [:each | each unReserve: startMyDate].			^self error: ('Cannot reserve &lt;1p&gt; &lt;2s&gt;''s from &lt;3p&gt; to &lt;4p&gt;'						expandMacrosWith: anInteger						with: self name						with: startMyDate						with: dueMyDate)].	^pendingHireItems</body><body package="Fit-Book-RPS">return: anInteger itemsFromRepairOn: aMyDate	| rs count |	count := anInteger.	rs := (hireItems select: #isBeingRepaired) values readStream.	[rs atEnd or: [count isZero]] whileFalse: 			[rs next completeRepairOn: aMyDate.			count := count - 1].	^count isZero</body><body package="Fit-Book-RPS">returnItemNamed: aString fromRepairOn: aMyDate	| item |	item := hireItems at: aString ifAbsent: [nil].	item completeRepairOn: aMyDate</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>comparing</category><body package="Fit-Book-RPS">= aRentalItemType	^name = aRentalItemType name and: 			[self count = aRentalItemType count				and: [rates = aRentalItemType rates and: [deposit = aRentalItemType deposit]]]</body><body package="Fit-Book-RPS">hash	^((name hash hashMultiply bitXor: rates hash) hashMultiply		bitXor: deposit hash) hashMultiply		bitXor: hireItems hash</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>adding</category><body package="Fit-Book-RPS">addItemRestriction: anItemRestriction	| id |	id := anItemRestriction id.	(itemRestrictions includesKey: id)		ifTrue: 			[^self				error: 'ItemRestriction id ' , id printString , ' already exists in item '						, name].	itemRestrictions at: id put: anItemRestriction</body><body package="Fit-Book-RPS">addRentalItem: aString	| hireItem |	hireItem := RentalItem named: aString type: self.	hireItems at: aString put: hireItem</body><body package="Fit-Book-RPS">addRentalItem: aString lastMaintained: aMyDate monthsBetweenMaintenance: aDouble	| hireItem |	hireItem := RentalItem				named: aString				type: self				lastMaintained: aMyDate				monthsBetweenMaintenance: aDouble.	hireItems at: aString put: hireItem</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">count: anInteger	0 to: anInteger - 1		do: [:each | self addRentalItem: name , each printString]</body><body package="Fit-Book-RPS">setName: aString initialCount: anInteger rates: aRates deposit: aMoney	name := aString.	rates := aRates.	deposit := aMoney.	hireItems := Dictionary new.	itemRestrictions := Dictionary new.	self count: anInteger</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>testing</category><body package="Fit-Book-RPS">canRentWithSatisfiedRestrictions: anArray	^itemRestrictions keys allSatisfy: [:each | anArray includes: each]</body><body package="Fit-Book-RPS">checkNumberOfItemsInRepair: anInteger	^(hireItems select: #isBeingRepaired) size &gt;= anInteger</body><body package="Fit-Book-RPS">hasHiresToReturn: anInteger	^(hireItems select: #hasHireToReturn) size &gt;= anInteger</body><body package="Fit-Book-RPS">hasIdentifiedItem: aString	^hireItems includesKey: aString</body><body package="Fit-Book-RPS">identifiedItemIsInMaintenance: aString	| item |	item := hireItems at: aString ifAbsent: [^false].	^item isBeingRepaired</body></methods><methods><class-id>RPS.RentalItemType class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">named: aString initialCount: anInteger rates: aRates deposit: aMoney	^self new		setName: aString		initialCount: anInteger		rates: aRates		deposit: aMoney</body></methods><methods><class-id>RPS.Money</class-id> <category>comparing</category><body package="Fit-Book-RPS">&lt; aMoney 	^cents &lt; aMoney cents</body><body package="Fit-Book-RPS">= aMoney 	^self species == aMoney species and: [cents = aMoney cents]</body><body package="Fit-Book-RPS">hash	^cents hash</body></methods><methods><class-id>RPS.Money</class-id> <category>arithmetic</category><body package="Fit-Book-RPS">* aNumber 	^self class cents: (cents * aNumber) rounded</body><body package="Fit-Book-RPS">+ aMoney 	^self class cents: cents + aMoney cents</body><body package="Fit-Book-RPS">- aMoney 	^self class cents: cents - aMoney cents</body><body package="Fit-Book-RPS">negated	^self class cents: cents negated</body></methods><methods><class-id>RPS.Money</class-id> <category>accessing</category><body package="Fit-Book-RPS">cents	^cents</body></methods><methods><class-id>RPS.Money</class-id> <category>printing</category><body package="Fit-Book-RPS">printOn: aStream 	NumberPrintPolicy 		print: (cents / 100) asFloat		on: aStream		using: '0.00'</body></methods><methods><class-id>RPS.Money</class-id> <category>testing</category><body package="Fit-Book-RPS">isZero	^cents isZero</body></methods><methods><class-id>RPS.Money</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCents: anInteger	cents := anInteger</body></methods><methods><class-id>RPS.Money</class-id> <category>converting</category><body package="Fit-Book-RPS">asDouble	^Double fitParse: self printString</body></methods><methods><class-id>RPS.Money class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">cents: anInteger	^self new setCents: anInteger</body><body package="Fit-Book-RPS">dollars: aDouble 	^self cents: (aDouble * 100) rounded</body><body package="Fit-Book-RPS">zero	^self cents: 0</body></methods><methods><class-id>RPS.Money class</class-id> <category>fit-utilities</category><body package="Fit-Book-RPS">fitParse: aString	(aString matchesRegex: '-?[0-9]*(\.[0-9][0-9])?')		ifFalse: [^self error: 'Invalid money'].	^self dollars: (Number fitParse: aString)</body></methods><methods><class-id>RPS.CashPaymentTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^amount negated</body></methods><methods><class-id>RPS.CashPaymentTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	"nothing to do"</body></methods><methods><class-id>RPS.CashPaymentTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setAmount: aMoney	amount := aMoney</body></methods><methods><class-id>RPS.CashPaymentTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">amount: aMoney transaction: aTransaction	^(self transaction: aTransaction)		setAmount: aMoney;		yourself</body></methods><methods><class-id>RPS.AccountPaymentTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^amount negated</body></methods><methods><class-id>RPS.AccountPaymentTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setAmount: aMoney	amount := aMoney</body></methods><methods><class-id>RPS.AccountPaymentTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	self client payOnAccount: amount</body></methods><methods><class-id>RPS.AccountPaymentTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">amount: aMoney transaction: aTransaction	^(self transaction: aTransaction) setAmount: aMoney</body></methods><methods><class-id>RPS.RefundAccountTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setAmount: aMoney client: aClient	amount := aMoney.	client := aClient</body></methods><methods><class-id>RPS.RefundAccountTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	client refundToAccount: amount</body></methods><methods><class-id>RPS.RefundAccountTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^amount</body></methods><methods><class-id>RPS.RefundAccountTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">amount: aMoney client: aClient transaction: aTransaction	^(self transaction: aTransaction) setAmount: aMoney client: aClient</body></methods><methods><class-id>RPS.AddToTemplateTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.AddToTemplateTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setTemplate: aTemplate itemType: aRentalItemType people: aFloat	template := aTemplate.	itemType := aRentalItemType.	count := aFloat</body></methods><methods><class-id>RPS.AddToTemplateTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	template addItem: itemType forPeople: count</body></methods><methods><class-id>RPS.AddToTemplateTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">template: aTemplate itemType: aRentalItemType people: aFloat transaction: aTransaction	^(self transaction: aTransaction)		setTemplate: aTemplate		itemType: aRentalItemType		people: aFloat</body></methods><methods><class-id>RPS.RentalItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">currentRental	^currentRental</body><body package="Fit-Book-RPS">endDate	^currentRental endDate</body><body package="Fit-Book-RPS">hireItemTypeName	^rentalItemType name</body><body package="Fit-Book-RPS">hiredDuration	^currentRental hiredDuration</body><body package="Fit-Book-RPS">startDate	^currentRental startDate</body></methods><methods><class-id>RPS.RentalItem</class-id> <category>reservations</category><body package="Fit-Book-RPS">doHire: aRental reservation: aReservation client: aClient staffMember: aStaffMember	reservations removeKey: aReservation startDate ifAbsent: [].	currentRental := aRental</body><body package="Fit-Book-RPS">removeReservation: aReservation	reservations removeKey: aReservation startDate ifAbsent: []</body><body package="Fit-Book-RPS">reserveFrom: startMyDate to: dueMyDate reservation: aReservation	(currentRental notNil and: [startMyDate before: currentRental endDate])		ifTrue: [^false].	reservations keysAndValuesDo: 			[:pendingStartDate :reservation |			| pendingDueDate |			pendingDueDate := reservation dueDate.			((startMyDate before: pendingStartDate)				or: [startMyDate after: pendingDueDate]) ifFalse: [^false].			((dueMyDate before: pendingStartDate)				or: [dueMyDate after: pendingDueDate]) ifFalse: [^false]].	reservations at: startMyDate put: aReservation.	^true</body><body package="Fit-Book-RPS">returnHire	currentRental := nil</body><body package="Fit-Book-RPS">unReserve: aMyDate	reservations removeKey: aMyDate</body></methods><methods><class-id>RPS.RentalItem</class-id> <category>testing</category><body package="Fit-Book-RPS">hasHireToReturn	^currentRental notNil</body><body package="Fit-Book-RPS">hasMaintenanceDate	^lastMaintained notNil</body><body package="Fit-Book-RPS">isBeingRepaired	^beingRepaired</body><body package="Fit-Book-RPS">isFree	^currentRental isNil and: [beingRepaired not]</body><body package="Fit-Book-RPS">needsMaintenanceAsOf: aMyDate	| time |	lastMaintained ifNil: [^false].	time := lastMaintained afterMonths: monthsBetweenMaintenance truncated.	(aMyDate before: time)		ifFalse: 			[self repair.			^true].	^false</body></methods><methods><class-id>RPS.RentalItem</class-id> <category>operations</category><body package="Fit-Book-RPS">completeRepairOn: aMyDate	beingRepaired := false.	lastMaintained := aMyDate</body><body package="Fit-Book-RPS">repair	beingRepaired := true</body></methods><methods><class-id>RPS.RentalItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setName: aString type: aRentalItemType lastMaintained: aMyDate monthsBetweenMaintenance: aDouble	identifier := aString.	rentalItemType := aRentalItemType.	lastMaintained := aMyDate.	monthsBetweenMaintenance := aDouble.	beingRepaired := false.	reservations := Dictionary new</body></methods><methods><class-id>RPS.RentalItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">named: aString type: aRentalItemType	^self		named: aString		type: aRentalItemType		lastMaintained: nil		monthsBetweenMaintenance: 0.0</body><body package="Fit-Book-RPS">named: aString type: aRentalItemType lastMaintained: aMyDate monthsBetweenMaintenance: aDouble	^self new		setName: aString		type: aRentalItemType		lastMaintained: aMyDate		monthsBetweenMaintenance: aDouble</body></methods><methods><class-id>RPS.Use</class-id> <category>accessing</category><body package="Fit-Book-RPS">client	^client</body><body package="Fit-Book-RPS">hireItemType	^reservation hireItemType</body><body package="Fit-Book-RPS">hiredDuration	^reservation hiredDuration</body><body package="Fit-Book-RPS">reservation	^reservation</body><body package="Fit-Book-RPS">staffMember	^staffMember</body></methods><methods><class-id>RPS.Use</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setReservation: aReservation client: aClient staffMember: aStaffMember	reservation := aReservation.	client := aClient.	staffMember := aStaffMember</body></methods><methods><class-id>RPS.Use</class-id> <category>testing</category><body package="Fit-Book-RPS">datesMatch: aUse	^self startDate = aUse startDate and: [self endDate = aUse endDate]</body></methods><methods><class-id>RPS.Use class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">reservation: aReservation client: aClient staffMember: aStaffMember	^self new		setReservation: aReservation		client: aClient		staffMember: aStaffMember</body></methods><methods><class-id>RPS.Booking</class-id> <category>operations</category><body package="Fit-Book-RPS">acceptOn: aMyDate	| count startDate newReservation |	client removeBooking: self.	staffMember removeBooking: self.	count := reservation count.	reservation removeAll.	startDate := (aMyDate before: reservation startDate)				ifTrue: [aMyDate]				ifFalse: [reservation startDate].	newReservation := Reservation				quantity: count				of: reservation hireItemType				for: reservation period				startingOn: startDate.	Rental reservation: newReservation client: client staffMember: staffMember</body><body package="Fit-Book-RPS">cancel	client removeBooking: self.	staffMember removeBooking: self.	reservation removeAll</body><body package="Fit-Book-RPS">changeDeliveryZone: zoneString address: addressString	delivery ifNil: [^self].	delivery changeZone: zoneString address: addressString</body><body package="Fit-Book-RPS">extendInto: aReservation	| totalPeriod count |	totalPeriod := reservation period + aReservation period.	count := reservation count.	reservation removeAll.	reservation := Reservation				quantity: count				of: reservation hireItemType				for: totalPeriod				startingOn: reservation startDate</body><body package="Fit-Book-RPS">reserveForExtendedPeriod: aDurationRPS	| extension |	extension := aDurationRPS - reservation period.	^Reservation		quantity: reservation count		of: reservation hireItemType		for: extension		startingOn: reservation dueDate</body></methods><methods><class-id>RPS.Booking</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setDelivery: aDelivery	delivery := aDelivery</body><body package="Fit-Book-RPS">setReservation: aReservation client: aClient staffMember: aStaffMember	super setReservation: aReservation client: aClient staffMember: aStaffMember.	staffMember addBooking: self.	client addBooking: self</body></methods><methods><class-id>RPS.Booking</class-id> <category>accessing</category><body package="Fit-Book-RPS">delivery	^delivery</body></methods><methods><class-id>RPS.Booking class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">reservation: aReservation client: aClient staffMember: aStaffMember delivery: aDelivery	^(self reservation: aReservation client: aClient staffMember: aStaffMember)		setDelivery: aDelivery</body></methods><methods><class-id>RPS.MaintenanceCompleteTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.MaintenanceCompleteTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setItem: aString type: aRentalItemType	itemIdentifier := aString.	hireItemType := aRentalItemType.	(hireItemType identifiedItemIsInMaintenance: aString)		ifFalse: 			[^self error: hireItemType name , ' ' , itemIdentifier						, ' is not currently being maintained']</body></methods><methods><class-id>RPS.MaintenanceCompleteTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	hireItemType returnItemNamed: itemIdentifier fromRepairOn: transaction startDate</body></methods><methods><class-id>RPS.MaintenanceCompleteTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">item: aString type: aRentalItemType transaction: aTransaction	^(self transaction: aTransaction) setItem: aString type: aRentalItemType</body></methods><methods><class-id>RPS.BonusPoints</class-id> <category>accessing</category><body package="Fit-Book-RPS">value	^value</body><body package="Fit-Book-RPS">valueInDouble	^Double fitParse: self printString</body></methods><methods><class-id>RPS.BonusPoints</class-id> <category>arithmetic</category><body package="Fit-Book-RPS">+ aBonusPoints	^self class value: value + aBonusPoints value</body><body package="Fit-Book-RPS">- aBonusPoints	^self class value: value - aBonusPoints value</body></methods><methods><class-id>RPS.BonusPoints</class-id> <category>comparing</category><body package="Fit-Book-RPS">&lt; aBonusPoints	^value &lt; aBonusPoints value</body><body package="Fit-Book-RPS">= aBonusPoints	^value = aBonusPoints value</body></methods><methods><class-id>RPS.BonusPoints</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setValue: aMoney	value := aMoney</body></methods><methods><class-id>RPS.BonusPoints</class-id> <category>printing</category><body package="Fit-Book-RPS">printOn: aStream	^value printOn: aStream</body></methods><methods><class-id>RPS.BonusPoints class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">cents: anInteger	^self value: (Money cents: anInteger)</body><body package="Fit-Book-RPS">dollars: aDouble	^self value: (Money dollars: aDouble)</body><body package="Fit-Book-RPS">fitParse: aString	^self value: (Money fitParse: aString)</body><body package="Fit-Book-RPS">forAmountSpent: aMoney	| totalBonus amountSpent bonus limit bonusRate overLimit |	totalBonus := Money zero.	amountSpent := aMoney asDouble.	totalBonus := self bonusPointParameters inject: Money zero				into: 					[:sum :each |					| bonusInCents |					limit := each key.					bonusRate := each value.					overLimit := amountSpent - limit max: 0.0d.					bonusInCents := overLimit * bonusRate.					bonus := ((bonusInCents * 100.0d) truncated / 100.0d) ceiling.					amountSpent := amountSpent min: limit.					sum + (Money cents: bonus)].	^self value: totalBonus</body><body package="Fit-Book-RPS">value: aMoney	^self new setValue: aMoney</body><body package="Fit-Book-RPS">zero	^self value: Money zero</body></methods><methods><class-id>RPS.BonusPoints class</class-id> <category>constants</category><body package="Fit-Book-RPS">bonusPointParameters	^OrderedCollection with: 500.0d -&gt; 10 with: 100.0d -&gt; 5</body></methods><methods><class-id>RPS.ChangeDeliveryRateTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCity: cityString zone: zoneString oldFlatFee: oldMoney rate: aDouble newFlatFee: newMoney	city := cityString.	zone := zoneString.	oldFlatFee := oldMoney.	rate := aDouble.	newFlatFee := newMoney</body></methods><methods><class-id>RPS.ChangeDeliveryRateTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.ChangeDeliveryRateTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	self rentEz		changeDeliveryRateCity: city		zone: zone		oldFlatFee: oldFlatFee		rate: rate		newFlatFee: newFlatFee</body></methods><methods><class-id>RPS.ChangeDeliveryRateTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">city: cityString zone: zoneString oldFlatFee: oldMoney rate: aDouble newFlatFee: newMoney transaction: aTransaction	^(self transaction: aTransaction)		setCity: cityString		zone: zoneString		oldFlatFee: oldMoney		rate: aDouble		newFlatFee: newMoney</body></methods><methods><class-id>RPS.Voucher</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setAmount: aMoney expiryDate: aMyDate	amount := aMoney.	expiryDate := aMyDate</body></methods><methods><class-id>RPS.Voucher</class-id> <category>testing</category><body package="Fit-Book-RPS">isExpiredOn: aMyDate	expiryDate ifNil: [^false].	^expiryDate before: aMyDate</body></methods><methods><class-id>RPS.Voucher</class-id> <category>accessing</category><body package="Fit-Book-RPS">amount	^amount</body></methods><methods><class-id>RPS.Voucher class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">amount: aMoney	^self amount: aMoney expiryDate: nil</body><body package="Fit-Book-RPS">amount: aMoney expiryDate: aMyDate	^self new setAmount: aMoney expiryDate: aMyDate</body></methods><methods><class-id>RPS.DinersClub</class-id> <category>constants</category><body package="Fit-Book-RPS">validLengths	^#(14)</body><body package="Fit-Book-RPS">validPrefixes	^#('36' '38' '300' '301' '302' '303' '304' '305')</body></methods><methods><class-id>RPS.Visa</class-id> <category>constants</category><body package="Fit-Book-RPS">validLengths	^#(11 13 16)</body><body package="Fit-Book-RPS">validPrefixes	^#('4')</body></methods><methods><class-id>RPS.MockClock</class-id> <category>accessing</category><body package="Fit-Book-RPS">now	^currentTime</body><body package="Fit-Book-RPS">time: aMyDate	currentTime := aMyDate</body></methods><methods><class-id>RPS.AcceptBookingTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^Money zero</body></methods><methods><class-id>RPS.AcceptBookingTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	booking acceptOn: self startDate</body></methods><methods><class-id>RPS.AcceptBookingTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setQuantity: anInteger itemType: aRentalItemType bookingDate: aMyDate period: aDurationRPS	count := anInteger.	hireItemType := aRentalItemType.	bookingDate := aMyDate.	period := aDurationRPS.	booking := (self client				bookingWith: count				of: hireItemType				startDate: bookingDate				endDate: (period dateAfter: bookingDate))					ifNil: [^self error: 'No such booking']</body></methods><methods><class-id>RPS.AcceptBookingTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">acceptBooking: anInteger of: aRentalItemType on: aMyDate for: aDurationRPS transaction: aTransaction	^(self transaction: aTransaction)		setQuantity: anInteger		itemType: aRentalItemType		bookingDate: aMyDate		period: aDurationRPS</body></methods><methods><class-id>RPS.StaffMember</class-id> <category>transactions</category><body package="Fit-Book-RPS">resumeAdminTransaction: anAdminTransaction	currentTransaction := anAdminTransaction.	^true</body><body package="Fit-Book-RPS">resumeClientTransaction: aClientTransaction	currentTransaction := aClientTransaction.	^true</body><body package="Fit-Book-RPS">startTransaction: aTransaction	currentTransaction := aTransaction.	^true</body><body package="Fit-Book-RPS">transactionComplete	((currentTransaction isKindOf: ClientTransaction)		and: [currentTransaction isStaffTransaction not])			ifTrue: 				[| paymentTotal commission |				paymentTotal := currentTransaction paymentTotal.				commission := paymentTotal * (commissionRate / 100.0) negated.				commissionEarnings := commissionEarnings + commission].	^super transactionComplete</body></methods><methods><class-id>RPS.StaffMember</class-id> <category>accessing</category><body package="Fit-Book-RPS">commissionEarnings	^commissionEarnings</body><body package="Fit-Book-RPS">commissionRate	^commissionRate</body><body package="Fit-Book-RPS">discountRate	^discountRate</body></methods><methods><class-id>RPS.StaffMember</class-id> <category>comparing</category><body package="Fit-Book-RPS">= aStaffMember	^super = aStaffMember and: 			[currentTransaction = aStaffMember currentTransaction and: 					[commissionRate = aStaffMember commissionRate and: 							[discountRate = aStaffMember discountRate								and: [commissionEarnings = aStaffMember commissionEarnings]]]]</body><body package="Fit-Book-RPS">hash	^(Array		with: currentTransaction		with: commissionRate		with: discountRate		with: commissionEarnings) inject: super hash			into: [:result :each | result hashMultiply bitXor: each hash]</body></methods><methods><class-id>RPS.StaffMember</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCommissionRate: commissionFloat discountRate: discountFloat	commissionRate := commissionFloat.	discountRate := discountFloat</body><body package="Fit-Book-RPS">setName: nameString phoneNumber: phoneString creator: aStaffMember	super setName: nameString phoneNumber: phoneString creator: aStaffMember.	commissionRate := 0.0.	discountRate := 0.0.	commissionEarnings := Money zero</body></methods><methods><class-id>RPS.StaffMember class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">named: nameString phoneNumber: phoneString commissionRate: aFloat creator: aStaffMember	^self		named: nameString		phoneNumber: phoneString		commissionRate: aFloat		discountRate: 0.0		creator: aStaffMember</body><body package="Fit-Book-RPS">named: nameString phoneNumber: phoneString commissionRate: commissionFloat discountRate: discountFloat creator: aStaffMember	^(self named: nameString phoneNumber: phoneString creator: aStaffMember)		setCommissionRate: commissionFloat		discountRate: discountFloat</body></methods><methods><class-id>RPS.Rental</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setReservation: aReservation client: aClient staffMember: aStaffMember	super setReservation: aReservation client: aClient staffMember: aStaffMember.	aReservation hireItems: self client: aClient staffMember: aStaffMember.	staffMember addRental: self.	client addRental: self</body></methods><methods><class-id>RPS.Rental</class-id> <category>returning</category><body package="Fit-Book-RPS">returnRental: anInteger	| returnCount rs returnedItems rentalItem |	returnCount := 0.	rs := reservation hireItems readStream.	returnedItems := OrderedCollection new.	[rs atEnd or: [returnCount = anInteger]] whileFalse: 			[rentalItem := rs next.			rentalItem returnHire.			returnedItems add: rentalItem.			returnCount := returnCount + 1].	reservation returnItems: returnedItems.	self count isZero		ifTrue: 			[client removeRental: self.			staffMember removeRental: self].	^returnCount</body></methods><methods><class-id>RPS.Rental class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">quantity: anInteger of: aRentalItemType for: aRPSDuration startingOn: aMyDate client: aClient staffMember: aStaffMember	^self		reservation: (Reservation				quantity: anInteger				of: aRentalItemType				for: aRPSDuration				startingOn: aMyDate)		client: aClient		staffMember: aStaffMember</body></methods><methods><class-id>RPS.CreditCard</class-id> <category>accessing</category><body package="Fit-Book-RPS">creditCardNumber	^cardNumber</body><body package="Fit-Book-RPS">expiryDate	^expiryDate</body><body package="Fit-Book-RPS">rentEz	^rentEz</body></methods><methods><class-id>RPS.CreditCard</class-id> <category>private</category><body package="Fit-Book-RPS">withoutSpaces: aString	^aString copyWithout: Character space</body></methods><methods><class-id>RPS.CreditCard</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setType: typeString expiryDate: aMyDate number: numberString rentEz: aRentEz	cardType := CreditCardType named: (self withoutSpaces: typeString).	expiryDate := aMyDate.	cardNumber := self withoutSpaces: numberString.	rentEz := aRentEz.	(cardType isValidCreditCard: self)		ifFalse: 			[^InvalidCreditCardException raiseErrorString: 'Card Verification failed']</body></methods><methods><class-id>RPS.CreditCard class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">type: typeString expiryDate: aMyDate number: numberString rentEz: aRentEz	^self new		setType: typeString		expiryDate: aMyDate		number: numberString		rentEz: aRentEz</body><body package="Fit-Book-RPS">type: typeString expiryString: expiryString number: numberString rentEz: aRentEz	^self		type: typeString		expiryDate: (MyDate timestamp: (self parseExpiryDate: expiryString))		number: numberString		rentEz: aRentEz</body></methods><methods><class-id>RPS.CreditCard class</class-id> <category>private</category><body package="Fit-Book-RPS">parseExpiryDate: aString	| tokens month year |	tokens := (aString tokensBasedOn: $/) collect: #asNumber.	tokens size = 2 ifFalse: [^self error: 'Invalid expiry date format'].	month := tokens first.	year := tokens last.	year &lt; 100 ifTrue: [year := Date today year // 100 * 100 + year].	^(Date newDay: 1 monthNumber: month year: year) asTimestamp</body></methods><methods><class-id>RPS.TemplateItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">costForPeople: anInteger duration: aDurationRPS	| itemsNeeded |	itemsNeeded := self itemsNeededForPeople: anInteger.	^(itemType isKindOf: RentalItemType)		ifTrue: 			[itemType totalRentalCostForDuration: aDurationRPS quantity: itemsNeeded]		ifFalse: [itemType sellingPriceForQuantity: itemsNeeded]</body><body package="Fit-Book-RPS">count: aFloat	count := aFloat</body><body package="Fit-Book-RPS">itemType	^itemType</body><body package="Fit-Book-RPS">itemsNeededForPeople: anInteger	^(anInteger asFloat / count asFloat) ceiling</body></methods><methods><class-id>RPS.TemplateItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setCount: aFloat itemType: aRentalItemType	count := aFloat.	itemType := aRentalItemType</body></methods><methods><class-id>RPS.TemplateItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">quantity: aFloat of: aRentalItemType	^self new setCount: aFloat itemType: aRentalItemType</body></methods><methods><class-id>RPS.AmericanExpress</class-id> <category>constants</category><body package="Fit-Book-RPS">validLengths	^#(15)</body><body package="Fit-Book-RPS">validPrefixes	^#('34' '37')</body></methods><methods><class-id>RPS.RefundCashTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^refund</body></methods><methods><class-id>RPS.RefundCashTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	"Nothing to do"</body></methods><methods><class-id>RPS.RefundCashTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setRefund: aMoney	refund := aMoney</body></methods><methods><class-id>RPS.RefundCashTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">refund: aMoney transaction: aTransaction	^(self transaction: aTransaction) setRefund: aMoney</body></methods><methods><class-id>RPS.RentalTransactionItem</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setQuantity: anInteger itemType: aRentalItemType duration: actualDuration	reservation := Reservation				quantity: anInteger				of: aRentalItemType				for: actualDuration				startingOn: self startDate</body></methods><methods><class-id>RPS.RentalTransactionItem</class-id> <category>actions</category><body package="Fit-Book-RPS">complete	Rental		reservation: reservation		client: self client		staffMember: self staffMember</body><body package="Fit-Book-RPS">newCount: anInteger duration: aDurationRPS	| oldCount itemType oldStartDate oldDuration |	oldCount := reservation count.	itemType := reservation hireItemType.	oldStartDate := reservation startDate.	oldDuration := reservation period.		[reservation removeAll.	reservation := Reservation				quantity: anInteger				of: itemType				for: aDurationRPS				startingOn: oldStartDate]			on: Error			do: 				[:ex |				reservation := Reservation							quantity: oldCount							of: itemType							for: oldDuration							startingOn: oldStartDate.				^false].	^true</body></methods><methods><class-id>RPS.RentalTransactionItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">totalCost	^reservation totalRentalCost</body></methods><methods><class-id>RPS.RentalTransactionItem</class-id> <category>testing</category><body package="Fit-Book-RPS">isSameCount: anInteger type: aRentalItemType duration: aDurationRPS	^reservation count = anInteger and: 			[reservation hireItemType name = aRentalItemType name				and: [reservation period = aDurationRPS]]</body></methods><methods><class-id>RPS.RentalTransactionItem class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">rent: anInteger of: aRentalItemType for: aDuration transaction: aClientTransaction	| actualDuration |	actualDuration := aRentalItemType rates fairDuration: aDuration.	^(self transaction: aClientTransaction)		setQuantity: anInteger		itemType: aRentalItemType		duration: actualDuration</body></methods><methods><class-id>RPS.DurationRPS</class-id> <category>printing</category><body package="Fit-Book-RPS">printOn: aStream	| ws |	ws := String new writeStream.	self		print: hours suffix: 'hour' on: ws;		print: days suffix: 'day' on: ws;		print: weeks suffix: 'week' on: ws.	aStream nextPutAll: ws contents trimBlanks</body></methods><methods><class-id>RPS.DurationRPS</class-id> <category>accessing</category><body package="Fit-Book-RPS">dateAfter: aMyDate	^aMyDate + self</body><body package="Fit-Book-RPS">days	^days</body><body package="Fit-Book-RPS">hours	^hours</body><body package="Fit-Book-RPS">totalHours	^(weeks * 7 + days) * 24 + hours</body><body package="Fit-Book-RPS">weeks	^weeks</body></methods><methods><class-id>RPS.DurationRPS</class-id> <category>initialize-release</category><body package="Fit-Book-RPS">setHours: hoursInteger days: daysInteger weeks: weeksInteger	hours := hoursInteger.	days := daysInteger.	weeks := weeksInteger</body></methods><methods><class-id>RPS.DurationRPS</class-id> <category>comparing</category><body package="Fit-Book-RPS">&lt; aDurationRPS	^self totalHours &lt; aDurationRPS totalHours</body><body package="Fit-Book-RPS">= aDuration 	^weeks = aDuration weeks 		and: [days = aDuration days and: [hours = aDuration hours]]</body><body package="Fit-Book-RPS">hash	^(weeks hash hashMultiply bitXor: days hash) hashMultiply		bitXor: hours hash</body></methods><methods><class-id>RPS.DurationRPS</class-id> <category>converting</category><body package="Fit-Book-RPS">asCoreDuration	^Duration		days: weeks * 7 + days		hours: hours		minutes: 0		seconds: 0</body></methods><methods><class-id>RPS.DurationRPS</class-id> <category>private</category><body package="Fit-Book-RPS">print: anInteger suffix: aString on: aStream	anInteger isZero ifTrue: [^self].	aStream		space;		print: anInteger;		space;		nextPutAll: aString.	anInteger &gt; 1 ifTrue: [aStream nextPut: $s]</body></methods><methods><class-id>RPS.DurationRPS</class-id> <category>arithmetic</category><body package="Fit-Book-RPS">+ aDurationRPS	^self class		hours: hours + aDurationRPS hours		days: days + aDurationRPS days		weeks: weeks + aDurationRPS weeks</body><body package="Fit-Book-RPS">- aDurationRPS	^self class		hours: hours - aDurationRPS hours		days: days - aDurationRPS days		weeks: weeks - aDurationRPS weeks</body></methods><methods><class-id>RPS.DurationRPS class</class-id> <category>instance creation</category><body package="Fit-Book-RPS">days: anInteger	^self hours: 0 days: anInteger weeks: 0</body><body package="Fit-Book-RPS">hours: anInteger	^self hours: anInteger days: 0 weeks: 0</body><body package="Fit-Book-RPS">hours: hoursInteger days: daysInteger weeks: weeksInteger	^self new setHours: hoursInteger days: daysInteger weeks: weeksInteger</body><body package="Fit-Book-RPS">weeks: anInteger	^self hours: 0 days: 0 weeks: anInteger</body></methods><methods><class-id>RPS.DurationRPS class</class-id> <category>fit-utilities</category><body package="Fit-Book-RPS">fitParse: aString	| tokens hours days weeks |	hours := 0.	days := 0.	weeks := 0.	tokens := aString runsFailing: #isSeparator.	tokens size odd ifTrue: [^self error: 'Missing units'].	[tokens isEmpty] whileFalse: 			[| number units |			number := Number fitParse: tokens removeFirst.			units := tokens removeFirst.			(#('hour' 'hours') includes: units) ifTrue: [hours := number].			(#('day' 'days') includes: units) ifTrue: [days := number].			(#('week' 'weeks') includes: units) ifTrue: [weeks := number]].	^self hours: hours days: days weeks: weeks</body></methods><methods><class-id>Core.Timestamp</class-id> <category>arithmetic</category><body package="Fit-Book-RPS">rpsAddMonths: anInteger	| copy |	copy := self copy.	copy month: copy month + anInteger.	[copy month &gt; 12] whileTrue: 			[copy year: copy year + 1.			copy month: copy month - 12].	^copy</body></methods><methods><class-id>RPS.Person</class-id> <category>accessing</category><body package="Fit-Book-RPS">name	&lt;fitReturns: #String&gt;	^name</body><body package="Fit-Book-RPS">phone	&lt;fitReturns: #String&gt;	^phoneNumber</body></methods><methods><class-id>RPS.Client</class-id> <category>accessing</category><body package="Fit-Book-RPS">address	&lt;fitReturns: #String&gt;	^address</body><body package="Fit-Book-RPS">city	&lt;fitReturns: #String&gt;	^city</body><body package="Fit-Book-RPS">email	&lt;fitReturns: #String&gt;	^email</body><body package="Fit-Book-RPS">zone	&lt;fitReturns: #String&gt;	^zone</body></methods><methods><class-id>RPS.Delivery</class-id> <category>accessing</category><body package="Fit-Book-RPS">city	&lt;fitReturns: #String&gt;	^city</body><body package="Fit-Book-RPS">date	&lt;fitReturns: #String&gt;	^date</body><body package="Fit-Book-RPS">deliveryAddress	&lt;fitReturns: #String&gt;	^deliveryAddress</body><body package="Fit-Book-RPS">item	&lt;fitReturns: #String&gt;	^item</body><body package="Fit-Book-RPS">itemCount	&lt;fitReturns: #Integer&gt;	^itemCount</body><body package="Fit-Book-RPS">zone	&lt;fitReturns: #String&gt;	^zone</body></methods><methods><class-id>RPS.BuyItemType</class-id> <category>accessing</category><body package="Fit-Book-RPS">count	&lt;fitReturns: #Integer&gt;	^count</body><body package="Fit-Book-RPS">name	&lt;fitReturns: #String&gt;	^name</body><body package="Fit-Book-RPS">sellingPrice	&lt;fitReturns: #Money&gt;	^sellingPrice</body></methods><methods><class-id>RPS.AdminTransaction</class-id> <category>operations</category><body package="Fit-Book-RPS">removeForRepair: aString _: anInteger	&lt;fitTakes: #(#String #Integer)&gt;	&lt;fitReturns: #Boolean&gt;	| item |	item := RemoveForRepairTransactionItem				type: aString				count: anInteger				transaction: self.	self addTransactionItem: item.	^true</body><body package="Fit-Book-RPS">returnFromRepair: aString _: anInteger	&lt;fitTakes: #(#String #Integer)&gt;	&lt;fitReturns: #Boolean&gt;	| item |	(self checkItemToReturnFromRepair: aString count: anInteger)		ifFalse: [^false].	item := ReturnFromRepairTransactionItem				type: aString				count: anInteger				transaction: self.	self addTransactionItem: item.	^true</body></methods><methods><class-id>RPS.DeliveryRate</class-id> <category>accessing</category><body package="Fit-Book-RPS">city	&lt;fitReturns: #String&gt;	^city</body><body package="Fit-Book-RPS">deliveryRateFlatFee	&lt;fitReturns: #Money&gt;	^flatFee</body><body package="Fit-Book-RPS">deliveryRatePercent	&lt;fitReturns: #Double&gt;	^rate</body><body package="Fit-Book-RPS">zone	&lt;fitReturns: #String&gt;	^zone</body></methods><methods><class-id>RPS.RentalItemType</class-id> <category>accessing</category><body package="Fit-Book-RPS">bond	&lt;fitReturns: #Money&gt;	^self deposit</body><body package="Fit-Book-RPS">count	&lt;fitReturns: #Integer&gt;	^hireItems size</body><body package="Fit-Book-RPS">dailyRate	&lt;fitReturns: #Money&gt;	^rates daily</body><body package="Fit-Book-RPS">freeCount	&lt;fitReturns: #Integer&gt;	^(hireItems select: #isFree) size</body><body package="Fit-Book-RPS">hourlyRate	&lt;fitReturns: #Money&gt;	^rates hourly</body><body package="Fit-Book-RPS">name	&lt;fitReturns: #String&gt;	^name</body><body package="Fit-Book-RPS">weeklyRate	&lt;fitReturns: #Money&gt;	^rates weekly</body></methods><methods><class-id>RPS.RentalItem</class-id> <category>accessing</category><body package="Fit-Book-RPS">identifier	&lt;fitReturns: #String&gt;	^identifier</body><body package="Fit-Book-RPS">lastMaintained	&lt;fitReturns: #MyDate&gt;	^lastMaintained</body></methods><methods><class-id>RPS.Use</class-id> <category>accessing</category><body package="Fit-Book-RPS">count	&lt;fitReturns: #Integer&gt;	^reservation count</body><body package="Fit-Book-RPS">endDate	&lt;fitReturns: #MyDate&gt;	^reservation dueDate</body><body package="Fit-Book-RPS">rentalItem	&lt;fitReturns: #String&gt;	^self hireItemType name</body><body package="Fit-Book-RPS">startDate	&lt;fitReturns: #MyDate&gt;	^reservation startDate</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>